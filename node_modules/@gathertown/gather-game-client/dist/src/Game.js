"use strict";
/*

The main interface to the Game Server.

*/
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.Game = exports.MoveDirection = void 0;
var gather_game_common_1 = require("@gathertown/gather-game-common");
exports.MoveDirection = gather_game_common_1.MoveDirection;
var Engine_1 = require("./Engine");
var Utils_1 = require("./Utils");
var uuid_1 = require("uuid");
var lodash_1 = require("lodash");
var recursive_diff_1 = require("recursive-diff");
var axios_1 = __importDefault(require("axios"));
// todo: move this and associated functions into Engine.ts
var fetchGameServerAssignment = function (spaceId) { return __awaiter(void 0, void 0, void 0, function () {
    var res, error_1, error_2;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!Utils_1.isBrowser) return [3 /*break*/, 5];
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4 /*yield*/, axios_1["default"].post("/api/getGameServer", {
                        room: spaceId
                    })];
            case 2:
                res = _a.sent();
                return [3 /*break*/, 4];
            case 3:
                error_1 = _a.sent();
                console.log("Error fetching getGameServer in browser: spaceId is ", spaceId, " error is ", error_1.response.data);
                throw error_1;
            case 4: return [3 /*break*/, 8];
            case 5:
                _a.trys.push([5, 7, , 8]);
                return [4 /*yield*/, axios_1["default"].post("https://gather.town/api/getGameServer", {
                        room: spaceId
                    })];
            case 6:
                res = _a.sent();
                return [3 /*break*/, 8];
            case 7:
                error_2 = _a.sent();
                console.log("Error fetching getGameServer: spaceId is ", spaceId, " error is ", error_2.response.data);
                throw error_2;
            case 8: return [2 /*return*/, res.data];
        }
    });
}); };
var Game = /** @class */ (function () {
    /* SETUP */
    // Params
    // ------
    // getAuth
    //   A function that returns an auth token/key that the game client
    //   should use to authenticate itself with the game server.
    // onInput
    //   Callback to be fired whenever moving in the game. Used for Client
    //   Prediction - see ClientPrediction.ts
    function Game(getAuth, onInput) {
        var _this = this;
        this.connected = false;
        this._connectedAtMs = 0;
        this._didReportFirstMapLoadTime = false;
        this._timeToFirstMapDataMs = -1;
        this.subscriptions = {};
        this.legacySubscriptions = {};
        this.legacySubscriptionsConnection = {};
        this.legacySubscriptionsReconnected = {};
        this.legacySubscriptionsLatency = {};
        this._encIdMapping = {};
        this.players = {};
        this._fullyDefinedPlayersSet = new Set();
        this._completePlayers = {}; // this completePlayers nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
        // map state for bandwidth saving reasons
        this.maps = {};
        // state to restore on reconnect
        this.entrances = 0;
        this.inputId = 1; // server needs this to be uint so its lastInputId inits to 0
        this.getGameServerUrl = function (space) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.debugOverrideServer) {
                            return [2 /*return*/, this.debugOverrideServer];
                        }
                        return [4 /*yield*/, fetchGameServerAssignment(space)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); };
        this.getAuth = getAuth;
        this.onInput = onInput;
        // for local development, force us to use localhost as our server
        if (Utils_1.isBrowser && window.location.hostname === "localhost") {
            this.overrideServer("ws://" + window.location.host + "/__dev-websocket");
        }
        // this is really just here to avoid a bunch of null checks
        // not a great pattern but hopefully soon we can just connect on initialization of the Game.
        //   not really a good reason not to imo.
        // also, avoiding all those null checks is ok-ish since the engine won't do anything until we call connect, where it's actually initialized
        this.engine = new Engine_1.Engine(this.getAuth, this.getGameServerUrl, "");
    }
    Game.prototype.overrideServer = function (server) {
        this.debugOverrideServer = server;
    };
    Game.prototype.getPlayer = function (uid) {
        return this.players[uid];
    };
    Game.prototype.connect = function (space) {
        var _this = this;
        console.log("connecting", space);
        if (this.connected) {
            return;
        }
        var newEngine = new Engine_1.Engine(this.getAuth, this.getGameServerUrl, space);
        this.engine = newEngine;
        this.connected = true;
        this.engine.onevent = function (serverClientEvent) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
            var event = serverClientEvent.event;
            if (!event) {
                console.error("Nullish client server action; this shouldn't happen! ", serverClientEvent);
                return;
            }
            var playerDeltas = {};
            // we need to track this because some other code depends on the first delta being emitted actually having the full player data. fml
            var fullPlayerBeforeUpdate = {}; // this fullPlayerBeforeUpdate nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
            switch (event.$case) {
                // These events mutate the player state in a way that does not send a declarative change in state (e.g deleting something).
                // You can *usually* write your code in a way that it does not demand one of these, but if you need it, you can implement it here.
                case "playerExits": {
                    var encId = event.playerExits.encId;
                    var uid = _this._encIdMapping[encId];
                    fullPlayerBeforeUpdate[uid] = _this._playerIsFullyDefined(uid); // this fullPlayerBeforeUpdate nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
                    playerDeltas[uid] = gather_game_common_1.GAME_STATE_PLAYER_DISCONNECT_SYMBOL;
                    _this._fullyDefinedPlayersSet["delete"](uid);
                    delete _this.players[uid];
                    delete _this._completePlayers[uid]; // this completePlayers nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
                    for (var key in _this.legacySubscriptions) {
                        // send only complete players
                        (_b = (_a = _this.legacySubscriptions[key]).onPlayers) === null || _b === void 0 ? void 0 : _b.call(_a, _this._completePlayers, playerDeltas);
                    }
                    break;
                }
                case "playerLeavesWhisper": {
                    var encId = event.playerLeavesWhisper.encId;
                    var uid = _this._encIdMapping[encId];
                    fullPlayerBeforeUpdate[uid] = _this._playerIsFullyDefined(uid); // this fullPlayerBeforeUpdate nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
                    playerDeltas[uid] = { whisperId: "" };
                    if (!_this.players[uid]) {
                        _this.players[uid] = {};
                    }
                    _this.players[uid].whisperId = "";
                    if (_this._completePlayers[uid]) {
                        // this completePlayers nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
                        _this._completePlayers[uid].whisperId = "";
                    }
                    break;
                }
                case "playerRings": {
                    var ringInfo_1 = {
                        type: "ring"
                    };
                    Object.values((_c = _this.legacySubscriptions) !== null && _c !== void 0 ? _c : {}).forEach(function (f) {
                        var _a;
                        (_a = f.onMessage) === null || _a === void 0 ? void 0 : _a.call(f, ringInfo_1);
                    });
                    break;
                }
                case "playerInteracts": {
                    var _r = event.playerInteracts, objId = _r.objId, encId = _r.encId, dataJson = _r.dataJson;
                    var uid = _this._encIdMapping[encId];
                    var data = dataJson ? JSON.parse(dataJson) : undefined;
                    var interactInfo_1 = {
                        user: uid,
                        type: "interact",
                        objId: objId,
                        data: data
                    };
                    Object.values((_d = _this.legacySubscriptions) !== null && _d !== void 0 ? _d : {}).forEach(function (f) {
                        var _a;
                        (_a = f.onMessage) === null || _a === void 0 ? void 0 : _a.call(f, interactInfo_1);
                    });
                    break;
                }
                case "playerSetsImagePointer": {
                    var _s = event.playerSetsImagePointer, objectId = _s.objectId, x = _s.x, y = _s.y;
                    var pointerInfo_1 = {
                        type: "pointer",
                        objectId: parseInt(objectId),
                        x: x,
                        y: y
                    };
                    Object.values((_e = _this.legacySubscriptions) !== null && _e !== void 0 ? _e : {}).forEach(function (f) {
                        var _a;
                        (_a = f.onMessage) === null || _a === void 0 ? void 0 : _a.call(f, pointerInfo_1);
                    });
                    break;
                }
                case "playerChats": {
                    var _t = event.playerChats, senderId_1 = _t.senderId, recipient_1 = _t.recipient, contents_1 = _t.contents, senderName_1 = _t.senderName, unixTime_1 = _t.unixTime, messageType_1 = _t.messageType;
                    if (unixTime_1 == null) {
                        return;
                    }
                    Object.values((_f = _this.legacySubscriptions) !== null && _f !== void 0 ? _f : {}).forEach(function (f) {
                        var _a;
                        (_a = f.onChat) === null || _a === void 0 ? void 0 : _a.call(f, {
                            senderId: senderId_1,
                            recipient: recipient_1,
                            msg: contents_1,
                            senderName: senderName_1,
                            messageType: messageType_1,
                            timestamp: {
                                _seconds: unixTime_1,
                                _nanoseconds: 0
                            }
                        });
                    });
                    break;
                }
                case "mapUpdates": {
                    var _u = event.mapUpdates, mapId_1 = _u.mapId, diffJson = _u.diffJson;
                    var diff = JSON.parse(diffJson);
                    _this.maps[mapId_1] = recursive_diff_1.applyDiff(_this.maps[mapId_1], diff);
                    Object.values((_g = _this.legacySubscriptions) !== null && _g !== void 0 ? _g : {}).forEach(function (f) {
                        var _a;
                        (_a = f.onMap) === null || _a === void 0 ? void 0 : _a.call(f, mapId_1, _this.maps[mapId_1]);
                    });
                    break;
                }
                case "mapOverwrites": {
                    var _v = event.mapOverwrites, mapId_2 = _v.mapId, mapJson = _v.mapJson;
                    var map = JSON.parse(mapJson);
                    _this.maps[mapId_2] = map;
                    Object.values((_h = _this.legacySubscriptions) !== null && _h !== void 0 ? _h : {}).forEach(function (f) {
                        var _a;
                        (_a = f.onMap) === null || _a === void 0 ? void 0 : _a.call(f, mapId_2, _this.maps[mapId_2]);
                    });
                    break;
                }
                case "spaceOverwrites":
                    break;
                case "spaceIsClosed": {
                    var closedInfo_1 = {
                        type: "closed"
                    };
                    Object.values((_j = _this.legacySubscriptions) !== null && _j !== void 0 ? _j : {}).forEach(function (f) {
                        var _a;
                        (_a = f.onMessage) === null || _a === void 0 ? void 0 : _a.call(f, closedInfo_1);
                    });
                    break;
                }
                case "spaceSetsIdMapping": {
                    var _w = event.spaceSetsIdMapping, uid = _w.uid, encId = _w.encId;
                    _this._encIdMapping[encId] = uid;
                    break;
                }
                case "playerEntersPortal": {
                    var targetUrl = event.playerEntersPortal.targetUrl;
                    var portalInfo_1 = {
                        type: "portal-space",
                        targetUrl: targetUrl
                    };
                    Object.values((_k = _this.legacySubscriptions) !== null && _k !== void 0 ? _k : {}).forEach(function (f) {
                        var _a;
                        (_a = f.onMessage) === null || _a === void 0 ? void 0 : _a.call(f, portalInfo_1);
                    });
                    break;
                }
                case "respawnComplete": {
                    var confirmRespawnInfo_1 = {
                        type: "respawnConfirmed"
                    };
                    Object.values((_l = _this.legacySubscriptions) !== null && _l !== void 0 ? _l : {}).forEach(function (f) {
                        var _a;
                        (_a = f.onMessage) === null || _a === void 0 ? void 0 : _a.call(f, confirmRespawnInfo_1);
                    });
                    break;
                }
                case "playerShootsConfetti": {
                    var encId = event.playerShootsConfetti.encId;
                    var playerId = _this._encIdMapping[encId];
                    var shootConfettiInfo_1 = {
                        type: "playerShootsConfetti",
                        playerId: playerId
                    };
                    Object.values((_m = _this.legacySubscriptions) !== null && _m !== void 0 ? _m : {}).forEach(function (f) {
                        var _a;
                        (_a = f.onMessage) === null || _a === void 0 ? void 0 : _a.call(f, shootConfettiInfo_1);
                    });
                    break;
                }
                case "cookieFound": {
                    var encId = event.cookieFound.encId;
                    var playerId = _this._encIdMapping[encId];
                    var cookieFoundInfo_1 = {
                        type: "cookieFound",
                        playerId: playerId
                    };
                    Object.values((_o = _this.legacySubscriptions) !== null && _o !== void 0 ? _o : {}).forEach(function (f) {
                        var _a;
                        (_a = f.onMessage) === null || _a === void 0 ? void 0 : _a.call(f, cookieFoundInfo_1);
                    });
                    break;
                }
                default: {
                    // This processes any event that begins with player, pulls out the encId (and optionally, additionally, encIdTarget if you need to target a second user as well)
                    // and applies all remaining fields to the player's state. If your event has special processing that needs to happen elsewhere, you can still put it in
                    // the switch statement. Otherwise, it will be handled automatically here.
                    var eventAny = event; // temporarily cast so we can get at the event
                    var eventVal = eventAny[eventAny.$case];
                    var encId = eventVal === null || eventVal === void 0 ? void 0 : eventVal.encId;
                    if (event.$case.startsWith("player") && encId != null) {
                        // TODO: scrub out fields set to undefined, or they'll overwrite that field on the player object. JS sucks :(
                        var uids = [];
                        var fetchedUid = _this._encIdMapping[encId];
                        if (fetchedUid != null) {
                            uids.push(fetchedUid);
                            fullPlayerBeforeUpdate[fetchedUid] = _this._playerIsFullyDefined(fetchedUid); // this fullPlayerBeforeUpdate nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
                        }
                        else {
                            console.error("got unknown encId");
                        }
                        if (eventVal === null || eventVal === void 0 ? void 0 : eventVal.encIdTarget) {
                            var uidTarget = _this._encIdMapping[eventVal === null || eventVal === void 0 ? void 0 : eventVal.encIdTarget];
                            if (uidTarget != null) {
                                fullPlayerBeforeUpdate[uidTarget] = _this._playerIsFullyDefined(uidTarget); // this fullPlayerBeforeUpdate nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
                                uids.push(uidTarget);
                            }
                            else {
                                console.error("got unknown encTargetId");
                            }
                        }
                        for (var entry in eventVal) {
                            for (var _i = 0, uids_1 = uids; _i < uids_1.length; _i++) {
                                var uid = uids_1[_i];
                                if (entry === "encId" || entry === "encIdTarget" || eventVal[entry] === undefined) {
                                    continue;
                                }
                                if (!_this.players[uid]) {
                                    _this.players[uid] = {};
                                }
                                // we will get rid of the playerDeltas as well, but keeping it temporarily for onPlayersConverter
                                if (!playerDeltas[uid]) {
                                    playerDeltas[uid] = {};
                                }
                                // we cast to any here because technically string isn't an index type of Player; that would make player a Record under
                                // typescript's parlance; but we want to use a regular JS style accessor here, without permanently changing the
                                // underlying type, so we temporarily weaken the type assertion to allow us to modify the struct.
                                _this.players[uid][entry] = eventVal[entry];
                                if (_this._completePlayers[uid]) {
                                    // this completePlayers nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
                                    _this._completePlayers[uid][entry] = eventVal[entry];
                                }
                                playerDeltas[uid][entry] = eventVal[entry];
                                if (entry === "mapId") {
                                    // TODO: Player struct has an inconsistency, it expects map to be named mapId
                                    // rename Player struct from map to mapId, or rename proto contents from mapId to map
                                    playerDeltas[uid]["map"] = eventVal[entry];
                                    if (_this._completePlayers[uid]) {
                                        // this completePlayers nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
                                        _this._completePlayers[uid]["map"] = eventVal[entry];
                                    }
                                    _this.players[uid]["map"] = eventVal[entry];
                                }
                            }
                        }
                    }
                    else {
                        console.error("received unrecognized event:", event.$case);
                    }
                }
            }
            // SUBSCRIPTION FORWARDING
            var eventSubs = _this.subscriptions[event.$case];
            if (eventSubs) {
                for (var id in eventSubs) {
                    var handler = eventSubs[id];
                    var eventAny = event[event.$case];
                    var context = {
                        spaceId: space
                    };
                    if (eventAny["encId"]) {
                        var encId = eventAny.encId;
                        var uid = _this._encIdMapping[encId];
                        context.player = _this.players[uid];
                        context.playerId = uid;
                    }
                    if (eventAny["encIdTarget"]) {
                        var encIdTarget = eventAny.encIdTarget;
                        var uidTarget = _this._encIdMapping[encIdTarget];
                        context.target = _this.players[uidTarget];
                        context.targetId = uidTarget;
                    }
                    // TODO: map events should populate their context as well.
                    // It's not ideal that we need to cast this to any, but it's necessary to satisfy TS.
                    // Be careful modifying this code - TS isn't protecting us here, so we need to manually
                    // ensure we're invoking event sub handlers properly!
                    handler(event, context);
                }
            }
            // emit onPlayers for legacy code
            // please can we remove this asap :P
            // really need to stop using onPlayers
            var deltaExists = false;
            for (var uid in playerDeltas) {
                var fullPlayerAfterUpdate = _this._playerIsFullyDefined(uid); // this fullPlayerBeforeUpdate nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
                if (!fullPlayerAfterUpdate) {
                    // the first time we call onPlayers with this player, the delta is expected to be the full state, so don't send it yet
                    // this sucks.
                    // we should just make the browser code robust to partial Player data
                    delete playerDeltas[uid];
                }
                else {
                    deltaExists = true;
                    // we're keeping around this completePlayers thing so we don't have to rebuild it from players every time.
                    // this sucks too.
                    _this._completePlayers[uid] = _this.players[uid];
                    // ^also, normally casting like this is not ok but we literally just checked so it's chill. kinda.
                    // the check is not really trustworthy so this is still bad, but a necessary evil until we get our typing straight
                    if (!fullPlayerBeforeUpdate[uid]) {
                        // the browser expects the first delta about a player to be its complete state.
                        // ...
                        playerDeltas[uid] = _this._completePlayers[uid];
                    }
                }
            }
            if (deltaExists) {
                for (var key in _this.legacySubscriptions) {
                    // send only complete players
                    (_q = (_p = _this.legacySubscriptions[key]).onPlayers) === null || _q === void 0 ? void 0 : _q.call(_p, _this._completePlayers, playerDeltas);
                }
            }
        };
        this.engine.onconnect = function () {
            _this._connectedAtMs = Date.now();
            _this.engine.sendAction({
                $case: "enter",
                enter: {}
            });
            _this.subscribeToAll();
            Object.values(_this.legacySubscriptionsConnection).forEach(function (f) {
                f(true);
            });
        };
        this.engine.ondisconnect = function () {
            Object.values(_this.legacySubscriptionsConnection).forEach(function (f) {
                f(false);
            });
        };
        this.engine.onreconnected = function (timeSpentDisconnectedMs) {
            Object.values(_this.legacySubscriptionsReconnected).forEach(function (f) {
                f(timeSpentDisconnectedMs);
            });
        };
        this.engine.onlatency = function (latency) {
            Object.values(_this.legacySubscriptionsLatency).forEach(function (f) {
                f(latency);
            });
        };
        (function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.engine && this.engine === newEngine)) return [3 /*break*/, 2];
                        // if it hasn't been destroyed yet
                        return [4 /*yield*/, newEngine.start()];
                    case 1:
                        // if it hasn't been destroyed yet
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        }); })();
    };
    Game.prototype.disconnect = function (space) {
        // TODO: JANK PASTA: there is no need to pass in space, minimizing interface breakage
        console.log("Disconnecting space: ", space);
        if (this.engine) {
            this.engine.destroy();
            this.connected = false;
        }
        else {
            console.log("Destroying an engine that wasn't created in the first place. Was this space real?");
        }
    };
    /* SUBSCRIPTION MANAGEMENT */
    Game.prototype.subscribeToEvent = function (
    // `eventId` should ALWAYS be a hardcoded string like "eventName"! See more context below.
    eventId, handler) {
        var _this = this;
        console.debug("Subscribing to new event", eventId);
        var subscriptionId = uuid_1.v4();
        // Having to hard cast these types isn't great and is related to the limitation described below.
        var existingSubs = this.subscriptions[eventId];
        var eventSubs = existingSubs !== null && existingSubs !== void 0 ? existingSubs : {};
        // @ts-ignore TS doesn't like this because we have the limitation of not being able to specify that
        // eventId will always be a *single* type from the ServerClientEventCase union. Given that we know this
        // API won't ever be used in situations where <T> has more than one possible value, we can just weaken
        // typing a bit here to get around this limitation.
        eventSubs[subscriptionId] = handler;
        this.subscriptions[eventId] = eventSubs;
        return function () {
            var _a;
            (_a = _this.subscriptions[eventId]) === null || _a === void 0 ? true : delete _a[subscriptionId];
        };
    };
    // old version, DO NOT USE
    Game.prototype.subscribeToSpace = function (space, listeners) {
        var _this = this;
        // send subscribe message, store the subscription
        var handle = uuid_1.v4();
        if (!this.legacySubscriptions) {
            this.maps = {};
            this.legacySubscriptions = {};
            this.subscribeToAll();
        }
        this.legacySubscriptions[handle] = listeners;
        // return unsubscribe
        return function () {
            delete _this.legacySubscriptions[handle];
            if (Object.keys(_this.legacySubscriptions).length === 0) {
                _this.maps = {};
                _this.legacySubscriptions = {};
                // we no longer want to unsubscribe here, because if we did, we might disconnect the parallel subscribeToEvent handlers
                // eventually, this entire function will go away, so it's okay if some random events are just fired into the aether for now
            }
        };
    };
    Game.prototype.subscribeToConnection = function (callback) {
        var _this = this;
        var handle = uuid_1.v4();
        this.legacySubscriptionsConnection[handle] = callback;
        return function () {
            delete _this.legacySubscriptionsConnection[handle];
        };
    };
    Game.prototype.subscribeToReconnected = function (callback) {
        var _this = this;
        var handle = uuid_1.v4();
        this.legacySubscriptionsReconnected[handle] = callback;
        return function () {
            delete _this.legacySubscriptionsReconnected[handle];
        };
    };
    Game.prototype.subscribeToLatency = function (callback) {
        var _this = this;
        var handle = uuid_1.v4();
        this.legacySubscriptionsLatency[handle] = callback;
        return function () {
            delete _this.legacySubscriptionsLatency[handle];
        };
    };
    /* TAKE ACTIONS */
    Game.prototype.enter = function (space, info, spawnToken) {
        if (!this.entrances) {
            this.engine.sendAction({
                $case: "enter",
                enter: {
                    spawnToken: spawnToken,
                    info: info
                }
            });
            this.entrances = 0;
        }
        this.entrances += 1;
    };
    Game.prototype.exit = function () {
        this.entrances -= 1;
        if (this.entrances === 0) {
            this.engine.sendAction({
                $case: "exit",
                exit: {}
            });
            this.entrances = 0;
        }
    };
    Game.prototype.respawn = function () {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "respawn",
            respawn: {}
        });
    };
    Game.prototype.spawn = function (spawnToken) {
        this.engine.sendAction({
            $case: "spawn",
            spawn: {
                spawnToken: spawnToken
            }
        });
    };
    Game.prototype.move = function (dir, stopped, targetId) {
        var _a;
        if (stopped === void 0) { stopped = false; }
        var inputId = this.inputId++;
        (_a = this.onInput) === null || _a === void 0 ? void 0 : _a.call(this, dir, stopped, inputId);
        this.engine.sendAction({
            $case: "move",
            move: {
                dir: dir,
                stopped: stopped,
                inputId: inputId,
                targetId: targetId
            }
        });
    };
    /**
      Puts the currently connected client in ghost mode
      @param space you must be connected already to invoke this function
      @param ghost ghost value, either 1 or 0; whether you are ghosting or not.
      @param targetId id of player whose ghost value you want to set (must be space owner to set)
    */
    Game.prototype.ghost = function (ghost, targetId) {
        this.engine.sendAction({
            $case: "ghost",
            ghost: {
                ghost: ghost,
                targetId: targetId
            }
        });
    };
    /**
     *
     * @param space string - space - you must be connected already to invoke this function
     * @param recipientId player ID of the other
     * @param dir MoveDirection enum
     */
    Game.prototype.enterWhisper = function (recipientId, dir) {
        this.engine.sendAction({
            $case: "enterWhisper",
            enterWhisper: {
                recipientId: recipientId,
                dir: dir
            }
        });
    };
    Game.prototype.leaveWhisper = function () {
        this.engine.sendAction({
            $case: "leaveWhisper",
            leaveWhisper: {}
        });
    };
    Game.prototype.teleport = function (mapId, x, y, targetId) {
        this.engine.sendAction({
            $case: "teleport",
            teleport: {
                mapId: mapId,
                x: x,
                y: y,
                targetId: targetId
            }
        });
    };
    Game.prototype.ring = function (user) {
        this.engine.sendAction({
            $case: "ring",
            ring: {
                user: user
            }
        });
    };
    Game.prototype.pointer = function (objectId, x, y) {
        this.engine.sendAction({
            $case: "setImagePointer",
            setImagePointer: {
                objectId: objectId,
                x: x,
                y: y
            }
        });
    };
    Game.prototype.setActivelySpeaking = function (activelySpeaking) {
        this.engine.sendAction({
            $case: "activelySpeaking",
            activelySpeaking: {
                activelySpeaking: activelySpeaking
            }
        });
    };
    Game.prototype.setEmote = function (emote, targetId) {
        this.engine.sendAction({
            $case: "setEmote",
            setEmote: {
                emote: emote,
                targetId: targetId
            }
        });
    };
    Game.prototype.setWorkCondition = function (workCondition) {
        this.engine.sendAction({
            $case: "setWorkCondition",
            setWorkCondition: {
                workCondition: workCondition
            }
        });
    };
    Game.prototype.setName = function (name, targetId) {
        this.engine.sendAction({
            $case: "setName",
            setName: {
                name: name,
                targetId: targetId
            }
        });
    };
    Game.prototype.setTextStatus = function (textStatus, targetId) {
        this.engine.sendAction({
            $case: "setTextStatus",
            setTextStatus: {
                textStatus: textStatus,
                targetId: targetId
            }
        });
    };
    Game.prototype.setEmojiStatus = function (emojiStatus, targetId) {
        this.engine.sendAction({
            $case: "setEmojiStatus",
            setEmojiStatus: {
                emojiStatus: emojiStatus,
                targetId: targetId
            }
        });
    };
    Game.prototype.setAffiliation = function (affiliation) {
        this.engine.sendAction({
            $case: "setAffiliation",
            setAffiliation: {
                affiliation: affiliation
            }
        });
    };
    Game.prototype.setStatus = function (status, targetId) {
        this.engine.sendAction({
            $case: "setStatus",
            setStatus: {
                status: status,
                targetId: targetId
            }
        });
    };
    Game.prototype.setEventStatus = function (eventStatus) {
        this.engine.sendAction({
            $case: "setEventStatus",
            setEventStatus: {
                eventStatus: eventStatus
            }
        });
    };
    Game.prototype.setInConversation = function (inConversation) {
        this.engine.sendAction({
            $case: "setInConversation",
            setInConversation: {
                inConversation: inConversation
            }
        });
    };
    Game.prototype.setCurrentDesk = function (currentDesk) {
        this.engine.sendAction({
            $case: "setCurrentDesk",
            setCurrentDesk: {
                currentDesk: currentDesk
            }
        });
    };
    Game.prototype.setCurrentArea = function (currentArea) {
        this.engine.sendAction({
            $case: "setCurrentArea",
            setCurrentArea: {
                currentArea: currentArea
            }
        });
    };
    Game.prototype.setSprite = function (sprite, targetId) {
        this.engine.sendAction({
            $case: "setSprite",
            setSprite: {
                sprite: sprite,
                targetId: targetId
            }
        });
    };
    Game.prototype.setOutfitString = function (outfitString, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setOutfitString",
            setOutfitString: {
                outfitString: outfitString,
                targetId: targetId
            }
        });
    };
    Game.prototype.setSpotlight = function (user, spotlighted) {
        this.engine.sendAction({
            $case: "spotlight",
            spotlight: {
                spotlightedUser: user,
                isSpotlighted: spotlighted
            }
        });
    };
    Game.prototype.banPlayer = function (user) {
        this.engine.sendAction({
            $case: "ban",
            ban: {
                user: user
            }
        });
    };
    Game.prototype.kickPlayer = function (user) {
        this.engine.sendAction({
            $case: "kick",
            kick: {
                user: user
            }
        });
    };
    Game.prototype.interact = function (objId, data) {
        this.engine.sendAction({
            $case: "interact",
            interact: {
                objId: objId,
                dataJson: JSON.stringify(data)
            }
        });
    };
    Game.prototype.chat = function (chatRecipient, localPlayers, mapId, contents) {
        this.engine.sendAction({
            $case: "chat",
            chat: {
                chatRecipient: chatRecipient,
                localPlayerIds: localPlayers,
                mapId: mapId,
                contents: contents
            }
        });
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Game.prototype.shootConfetti = function () {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "shootConfetti",
            shootConfetti: {}
        });
    };
    Game.prototype.setGoKartId = function (goKartId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({ $case: "setGoKartId", setGoKartId: { goKartId: goKartId } });
    };
    /* EDITOR ONLY ACTIONS */
    Game.prototype.setImpassable = function (mapId, x, y, impassable) {
        if (impassable === void 0) { impassable = true; }
        this.engine.sendAction({
            $case: "setImpassable",
            setImpassable: {
                mapId: mapId,
                x: x,
                y: y,
                impassable: impassable
            }
        });
    };
    Game.prototype.getObject = function (objId) {
        var _a;
        for (var _i = 0, _b = Object.keys(this.maps); _i < _b.length; _i++) {
            var mapId = _b[_i];
            var currMap = (_a = this.maps) === null || _a === void 0 ? void 0 : _a[mapId];
            var i = currMap.objects.findIndex(function (o) { return o.id === objId; });
            if (i >= 0) {
                return { mapId: mapId, obj: lodash_1.cloneDeep(currMap.objects[i]) };
            }
        }
    };
    Game.prototype.setObject = function (mapId, objId, obj) {
        var _a;
        var currMap = (_a = this.maps) === null || _a === void 0 ? void 0 : _a[mapId];
        if (!currMap) {
            return;
        }
        currMap = lodash_1.cloneDeep(currMap);
        var i = currMap.objects.findIndex(function (o) { return o.id === objId; });
        if (i >= 0) {
            currMap.objects[i] = __assign(__assign({}, currMap.objects[i]), obj);
        }
        else {
            currMap.objects.push(__assign({ id: objId }, obj));
        }
        this._updateMap(recursive_diff_1.getDiff(this.maps[mapId], currMap), mapId);
    };
    Game.prototype.deleteObject = function (mapId, objId) {
        var _a;
        var currMap = (_a = this.maps) === null || _a === void 0 ? void 0 : _a[mapId];
        if (!currMap) {
            return;
        }
        currMap = lodash_1.cloneDeep(currMap);
        var i = currMap.objects.findIndex(function (o) { return o.id === objId; });
        if (i >= 0) {
            currMap.objects.splice(i, 1);
            this._updateMap(recursive_diff_1.getDiff(this.maps[mapId], currMap), mapId);
        }
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Game.prototype.flushObjectsToFirebase = function (space, mapId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // covered by game server now!
                // leaving it here so we have time to make extensions not call this function
                console.warn("DeprecationWarning: This function has been deprecated and is now a no-op. It doesn't do anything. Happy hacking <3");
                return [2 /*return*/];
            });
        });
    };
    Game.prototype._updateMap = function (diff, mapId) {
        this.engine.sendAction({
            $case: "mapUpdate",
            mapUpdate: {
                mapId: mapId,
                diffJson: JSON.stringify(diff)
            }
        });
    };
    Game.prototype.getStats = function () {
        return {
            serverURL: this.engine.serverURL,
            engine: this.engine.getMetrics(),
            timeToFirstMapDataMs: this._timeToFirstMapDataMs
        };
    };
    // TODO: ABSTRACTION PASTA; this effectively subscribes you to every event so the onPlayers, on... handlers work properly. This can go away after.
    Game.prototype.subscribeToAll = function () {
        this.engine.sendAction({
            $case: "updateSubscriptions",
            updateSubscriptions: {
                subscriptions: {
                    playerSetsSprite: true,
                    playerSetsAffiliation: true,
                    playerSetsStatus: true,
                    playerSpotlights: true,
                    playerRings: true,
                    playerInteracts: true,
                    playerSetsImagePointer: true,
                    playerChats: true,
                    playerSetsOutfitString: true,
                    playerMoves: true,
                    playerSetsName: true,
                    playerGhosts: true,
                    playerSetsEmote: true,
                    playerSetsWorkCondition: true,
                    playerActivelySpeaks: true,
                    playerSetsTextStatus: true,
                    playerSetsEmojiStatus: true,
                    playerEntersWhisperV2: true,
                    playerLeavesWhisper: true,
                    playerSetsIsSignedIn: true,
                    mapUpdates: true,
                    mapOverwrites: true,
                    spaceOverwrites: true,
                    spaceIsClosed: true,
                    spaceSetsIdMapping: true,
                    playerEntersPortal: true,
                    respawnComplete: true,
                    playerExits: true,
                    info: true,
                    warn: true,
                    error: true,
                    serverHeartbeat: true,
                    disableVideo: true,
                    playerSetsLastActive: true,
                    playerShootsConfetti: true,
                    playerSetsEventStatus: true,
                    playerSetsInConversation: true,
                    playerSetsCurrentDesk: true,
                    playerSetsCurrentArea: true,
                    cookieFound: true,
                    playerSetsGoKartId: true
                }
            }
        });
    };
    Game.prototype._playerIsFullyDefined = function (uid) {
        if (this._fullyDefinedPlayersSet.has(uid)) {
            return true;
        }
        // TODO: Think of more robust way to do this iff the immediate followup game-client refactor doesn't remove the need for it
        if (this.players[uid] && Object.keys(this.players[uid]).length === 24) {
            this._fullyDefinedPlayersSet.add(uid);
            return true;
        }
        return false;
    };
    return Game;
}());
exports.Game = Game;
//# sourceMappingURL=Game.js.map