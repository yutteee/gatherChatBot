import { Emote, GameMap, GameState, MoveDirection, PartialGameState, Player, ServerClientEventCase, ServerClientEventByCase } from "@gathertown/gather-game-common";
import { Engine, EngineAuth, GameEngineMetrics } from "./Engine";
import { ServerClientEventContext, SlidingWindowMetrics } from "./Utils";
import rdiff from "recursive-diff";
export { MoveDirection };
export interface GameClientStats {
    serverURL: string;
    engine: GameEngineMetrics;
    timeToFirstMapDataMs: number;
}
declare type GameSpaceSubscription = Readonly<{
    onPlayers?: (players: GameState<Player>, delta: PartialGameState<Player>) => void;
    onMap?: (id: string, map: GameMap) => void;
    onMessage?: (m: any) => void;
    onChat?: (m: any) => void;
}>;
declare type GameEventSubscriptions<T extends ServerClientEventCase> = {
    [uuid: string]: (data: ServerClientEventByCase<T>, context: ServerClientEventContext) => void;
};
declare type GameEventSubscriptionMap = {
    [eventId in ServerClientEventCase]?: GameEventSubscriptions<eventId>;
};
export declare class Game {
    engine: Engine;
    connected: boolean;
    getAuth: () => Promise<EngineAuth>;
    _connectedAtMs: number;
    _didReportFirstMapLoadTime: boolean;
    _timeToFirstMapDataMs: number;
    debugOverrideServer?: string;
    subscriptions: GameEventSubscriptionMap;
    legacySubscriptions: {
        [uuid: string]: GameSpaceSubscription;
    };
    legacySubscriptionsConnection: {
        [uuid: string]: (connected: boolean) => void;
    };
    legacySubscriptionsReconnected: {
        [uuid: string]: (timeSpentDisconnectedMs: number) => void;
    };
    legacySubscriptionsLatency: {
        [uuid: string]: (latency: SlidingWindowMetrics) => void;
    };
    _encIdMapping: {
        [encId: number]: string;
    };
    players: {
        [uid: string]: Partial<Player>;
    };
    _fullyDefinedPlayersSet: Set<string>;
    _completePlayers: GameState<Player>;
    maps: {
        [id: string]: any;
    };
    entrances: number;
    onInput: ((dir: MoveDirection, stopped: boolean, inputId: number) => void) | undefined;
    inputId: number;
    constructor(getAuth: () => Promise<EngineAuth>, onInput?: (dir: MoveDirection, stopped: boolean, inputId: number) => void);
    getGameServerUrl: (space: string) => Promise<any>;
    overrideServer(server: string): void;
    getPlayer(uid: string): Partial<Player>;
    connect(space: string): void;
    disconnect(space: string): void;
    subscribeToEvent<T extends ServerClientEventCase>(eventId: T, handler: (data: ServerClientEventByCase<T>, context: ServerClientEventContext) => void): () => void;
    subscribeToSpace(space: string, listeners: GameSpaceSubscription): () => void;
    subscribeToConnection(callback: (connected: boolean) => void): () => void;
    subscribeToReconnected(callback: (timeSpentDisconnectedMs: number) => void): () => void;
    subscribeToLatency(callback: (latency: SlidingWindowMetrics) => void): () => void;
    enter(space: string, info: any, spawnToken?: string): void;
    exit(): void;
    respawn(): void;
    spawn(spawnToken: string): void;
    move(dir: MoveDirection, stopped?: boolean, targetId?: string): void;
    /**
      Puts the currently connected client in ghost mode
      @param space you must be connected already to invoke this function
      @param ghost ghost value, either 1 or 0; whether you are ghosting or not.
      @param targetId id of player whose ghost value you want to set (must be space owner to set)
    */
    ghost(ghost: number, targetId?: string): void;
    /**
     *
     * @param space string - space - you must be connected already to invoke this function
     * @param recipientId player ID of the other
     * @param dir MoveDirection enum
     */
    enterWhisper(recipientId: string, dir: MoveDirection): void;
    leaveWhisper(): void;
    teleport(mapId: string, x: number, y: number, targetId?: string): void;
    ring(user: string): void;
    pointer(objectId: string, x: number, y: number): void;
    setActivelySpeaking(activelySpeaking: boolean): void;
    setEmote(emote: Emote, targetId?: string): void;
    setWorkCondition(workCondition: boolean): void;
    setName(name: string, targetId?: string): void;
    setTextStatus(textStatus: string, targetId?: string): void;
    setEmojiStatus(emojiStatus: string, targetId?: string): void;
    setAffiliation(affiliation: string): void;
    setStatus(status: boolean, targetId?: string): void;
    setEventStatus(eventStatus: string): void;
    setInConversation(inConversation: boolean): void;
    setCurrentDesk(currentDesk: string): void;
    setCurrentArea(currentArea: string): void;
    setSprite(sprite: number, targetId?: string): void;
    setOutfitString(outfitString: string, targetId?: string): void;
    setSpotlight(user: string, spotlighted: boolean): void;
    banPlayer(user: string): void;
    kickPlayer(user: string): void;
    interact(objId: string, data?: any): void;
    chat(chatRecipient: any, localPlayers: any, mapId: string, contents: any): void;
    shootConfetti(): void;
    setGoKartId(goKartId: string): void;
    setImpassable(mapId: string, x: number, y: number, impassable?: boolean): void;
    getObject(objId: string): any;
    setObject(mapId: string, objId: string, obj: Record<string, unknown>): void;
    deleteObject(mapId: string, objId: string): void;
    flushObjectsToFirebase(space: string, mapId: string): Promise<void>;
    _updateMap(diff: rdiff.rdiffResult[], mapId: string): void;
    getStats(): GameClientStats | undefined;
    subscribeToAll(): void;
    _playerIsFullyDefined(uid: string): boolean;
}
