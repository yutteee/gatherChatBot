/*

The main interface to the Game Server.

*/

import {
  Emote,
  GAME_STATE_PLAYER_DISCONNECT_SYMBOL,
  GameMap,
  GameState,
  MoveDirection,
  PartialGameState,
  Player,
  ServerClientEvent,
  ServerClientEventCase,
  ServerClientEventByCase,
} from "@gathertown/gather-game-common";
import { Engine, EngineAuth, GameEngineMetrics } from "./Engine";
import { ServerClientEventContext, isBrowser, SlidingWindowMetrics } from "./Utils";

import { v4 as uuid } from "uuid";
import { cloneDeep } from "lodash";
import rdiff, { applyDiff, getDiff } from "recursive-diff";
import axios from "axios";

export { MoveDirection };

// todo: move this and associated functions into Engine.ts
const fetchGameServerAssignment = async (spaceId: string) => {
  let res;
  // on browser, use the same deployment that we're currently using
  if (isBrowser) {
    try {
      res = await axios.post("/api/getGameServer", {
        room: spaceId,
      });
    } catch (error) {
      console.log(
        "Error fetching getGameServer in browser: spaceId is ",
        spaceId,
        " error is ",
        error.response.data,
      );
      throw error;
    }
  } else {
    // from the api, always use prod
    try {
      res = await axios.post("https://gather.town/api/getGameServer", {
        room: spaceId,
      });
    } catch (error) {
      console.log(
        "Error fetching getGameServer: spaceId is ",
        spaceId,
        " error is ",
        error.response.data,
      );
      throw error;
    }
  }

  return res.data;
};

export interface GameClientStats {
  serverURL: string;
  engine: GameEngineMetrics;
  timeToFirstMapDataMs: number;
}
// TODO: STOP USING ALL OF THIS ASAP
type GameSpaceSubscription = Readonly<{
  onPlayers?: (players: GameState<Player>, delta: PartialGameState<Player>) => void;
  onMap?: (id: string, map: GameMap) => void;
  onMessage?: (m: any) => void;
  onChat?: (m: any) => void;
}>;

type GameEventSubscriptions<T extends ServerClientEventCase> = {
  [uuid: string]: (data: ServerClientEventByCase<T>, context: ServerClientEventContext) => void;
};

type GameEventSubscriptionMap = {
  [eventId in ServerClientEventCase]?: GameEventSubscriptions<eventId>;
};

export class Game {
  // connection
  engine: Engine;
  connected = false;
  getAuth: () => Promise<EngineAuth>;

  _connectedAtMs = 0;
  _didReportFirstMapLoadTime = false;
  _timeToFirstMapDataMs = -1;

  debugOverrideServer?: string;

  subscriptions: GameEventSubscriptionMap = {};

  legacySubscriptions: {
    [uuid: string]: GameSpaceSubscription;
  } = {};
  legacySubscriptionsConnection: {
    [uuid: string]: (connected: boolean) => void;
  } = {};
  legacySubscriptionsReconnected: {
    [uuid: string]: (timeSpentDisconnectedMs: number) => void;
  } = {};
  legacySubscriptionsLatency: {
    [uuid: string]: (latency: SlidingWindowMetrics) => void;
  } = {};

  _encIdMapping: { [encId: number]: string } = {};
  players: {
    [uid: string]: Partial<Player>;
  } = {};
  _fullyDefinedPlayersSet: Set<string> = new Set();
  _completePlayers: GameState<Player> = {}; // this completePlayers nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it

  // map state for bandwidth saving reasons
  maps: { [id: string]: any } = {};
  // state to restore on reconnect
  entrances = 0;

  onInput: ((dir: MoveDirection, stopped: boolean, inputId: number) => void) | undefined;
  inputId = 1; // server needs this to be uint so its lastInputId inits to 0

  /* SETUP */

  // Params
  // ------
  // getAuth
  //   A function that returns an auth token/key that the game client
  //   should use to authenticate itself with the game server.
  // onInput
  //   Callback to be fired whenever moving in the game. Used for Client
  //   Prediction - see ClientPrediction.ts
  constructor(
    getAuth: () => Promise<EngineAuth>,
    onInput?: (dir: MoveDirection, stopped: boolean, inputId: number) => void,
  ) {
    this.getAuth = getAuth;
    this.onInput = onInput;

    // for local development, force us to use localhost as our server
    if (isBrowser && window.location.hostname === "localhost") {
      this.overrideServer("ws://" + window.location.host + "/__dev-websocket");
    }
    // this is really just here to avoid a bunch of null checks
    // not a great pattern but hopefully soon we can just connect on initialization of the Game.
    //   not really a good reason not to imo.
    // also, avoiding all those null checks is ok-ish since the engine won't do anything until we call connect, where it's actually initialized
    this.engine = new Engine(this.getAuth, this.getGameServerUrl, "");
  }
  getGameServerUrl = async (space: string) => {
    if (this.debugOverrideServer) {
      return this.debugOverrideServer;
    }
    return await fetchGameServerAssignment(space);
  };
  overrideServer(server: string) {
    this.debugOverrideServer = server;
  }

  getPlayer(uid: string) {
    return this.players[uid];
  }

  connect(space: string) {
    console.log("connecting", space);
    if (this.connected) {
      return;
    }

    const newEngine = new Engine(this.getAuth, this.getGameServerUrl, space);
    this.engine = newEngine;
    this.connected = true;
    this.engine.onevent = (serverClientEvent: ServerClientEvent) => {
      const { event } = serverClientEvent;
      if (!event) {
        console.error("Nullish client server action; this shouldn't happen! ", serverClientEvent);
        return;
      }

      const playerDeltas: PartialGameState<Player> = {};
      // we need to track this because some other code depends on the first delta being emitted actually having the full player data. fml
      const fullPlayerBeforeUpdate: { [uid: string]: boolean } = {}; // this fullPlayerBeforeUpdate nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
      switch (event.$case) {
        // These events mutate the player state in a way that does not send a declarative change in state (e.g deleting something).
        // You can *usually* write your code in a way that it does not demand one of these, but if you need it, you can implement it here.
        case "playerExits": {
          const { encId } = event.playerExits;
          const uid = this._encIdMapping[encId];
          fullPlayerBeforeUpdate[uid] = this._playerIsFullyDefined(uid); // this fullPlayerBeforeUpdate nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
          playerDeltas[uid] = GAME_STATE_PLAYER_DISCONNECT_SYMBOL;
          this._fullyDefinedPlayersSet.delete(uid);
          delete this.players[uid];
          delete this._completePlayers[uid]; // this completePlayers nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
          for (const key in this.legacySubscriptions) {
            // send only complete players
            this.legacySubscriptions[key].onPlayers?.(this._completePlayers, playerDeltas);
          }
          break;
        }
        case "playerLeavesWhisper": {
          const { encId } = event.playerLeavesWhisper;
          const uid = this._encIdMapping[encId];
          fullPlayerBeforeUpdate[uid] = this._playerIsFullyDefined(uid); // this fullPlayerBeforeUpdate nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
          playerDeltas[uid] = { whisperId: "" };
          if (!this.players[uid]) {
            this.players[uid] = {};
          }
          this.players[uid].whisperId = "";
          if (this._completePlayers[uid]) {
            // this completePlayers nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
            this._completePlayers[uid].whisperId = "";
          }
          break;
        }
        case "playerRings": {
          const ringInfo = {
            type: "ring",
          };
          Object.values(this.legacySubscriptions ?? {}).forEach((f) => {
            f.onMessage?.(ringInfo);
          });
          break;
        }
        case "playerInteracts": {
          const { objId, encId, dataJson } = event.playerInteracts;
          const uid = this._encIdMapping[encId];
          const data = dataJson ? JSON.parse(dataJson) : undefined;
          const interactInfo = {
            user: uid,
            type: "interact",
            objId,
            data,
          };
          Object.values(this.legacySubscriptions ?? {}).forEach((f) => {
            f.onMessage?.(interactInfo);
          });
          break;
        }
        case "playerSetsImagePointer": {
          const { objectId, x, y } = event.playerSetsImagePointer;
          const pointerInfo = {
            type: "pointer",
            objectId: parseInt(objectId),
            x,
            y,
          };
          Object.values(this.legacySubscriptions ?? {}).forEach((f) => {
            f.onMessage?.(pointerInfo);
          });
          break;
        }
        case "playerChats": {
          const { senderId, recipient, contents, senderName, unixTime, messageType } =
            event.playerChats;
          if (unixTime == null) {
            return;
          }
          Object.values(this.legacySubscriptions ?? {}).forEach((f) => {
            f.onChat?.({
              senderId,
              recipient,
              msg: contents,
              senderName,
              messageType,
              timestamp: {
                _seconds: unixTime,
                _nanoseconds: 0,
              },
            });
          });
          break;
        }
        case "mapUpdates": {
          const { mapId, diffJson } = event.mapUpdates;
          const diff = JSON.parse(diffJson);
          this.maps[mapId] = applyDiff(this.maps[mapId], diff);
          Object.values(this.legacySubscriptions ?? {}).forEach((f) => {
            f.onMap?.(mapId, this.maps[mapId]);
          });
          break;
        }
        case "mapOverwrites": {
          const { mapId, mapJson } = event.mapOverwrites;
          const map = JSON.parse(mapJson);
          this.maps[mapId] = map;

          Object.values(this.legacySubscriptions ?? {}).forEach((f) => {
            f.onMap?.(mapId, this.maps[mapId]);
          });
          break;
        }
        case "spaceOverwrites":
          break;
        case "spaceIsClosed": {
          const closedInfo = {
            type: "closed",
          };
          Object.values(this.legacySubscriptions ?? {}).forEach((f) => {
            f.onMessage?.(closedInfo);
          });
          break;
        }
        case "spaceSetsIdMapping": {
          const { uid, encId } = event.spaceSetsIdMapping;
          this._encIdMapping[encId] = uid;
          break;
        }
        case "playerEntersPortal": {
          const { targetUrl } = event.playerEntersPortal;
          const portalInfo = {
            type: "portal-space",
            targetUrl,
          };
          Object.values(this.legacySubscriptions ?? {}).forEach((f) => {
            f.onMessage?.(portalInfo);
          });
          break;
        }
        case "respawnComplete": {
          const confirmRespawnInfo = {
            type: "respawnConfirmed",
          };
          Object.values(this.legacySubscriptions ?? {}).forEach((f) => {
            f.onMessage?.(confirmRespawnInfo);
          });
          break;
        }
        case "playerShootsConfetti": {
          const { encId } = event.playerShootsConfetti;
          const playerId = this._encIdMapping[encId];
          const shootConfettiInfo = {
            type: "playerShootsConfetti",
            playerId,
          };
          Object.values(this.legacySubscriptions ?? {}).forEach((f) => {
            f.onMessage?.(shootConfettiInfo);
          });
          break;
        }
        case "cookieFound": {
          const { encId } = event.cookieFound;
          const playerId = this._encIdMapping[encId];

          const cookieFoundInfo = {
            type: "cookieFound",
            playerId,
          };
          Object.values(this.legacySubscriptions ?? {}).forEach((f) => {
            f.onMessage?.(cookieFoundInfo);
          });
          break;
        }
        default: {
          // This processes any event that begins with player, pulls out the encId (and optionally, additionally, encIdTarget if you need to target a second user as well)
          // and applies all remaining fields to the player's state. If your event has special processing that needs to happen elsewhere, you can still put it in
          // the switch statement. Otherwise, it will be handled automatically here.
          const eventAny = event as any; // temporarily cast so we can get at the event
          const eventVal = eventAny[eventAny.$case];
          const encId = eventVal?.encId;
          if (event.$case.startsWith("player") && encId != null) {
            // TODO: scrub out fields set to undefined, or they'll overwrite that field on the player object. JS sucks :(
            const uids = [];
            const fetchedUid = this._encIdMapping[encId];
            if (fetchedUid != null) {
              uids.push(fetchedUid);
              fullPlayerBeforeUpdate[fetchedUid] = this._playerIsFullyDefined(fetchedUid); // this fullPlayerBeforeUpdate nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
            } else {
              console.error("got unknown encId");
            }
            if (eventVal?.encIdTarget) {
              const uidTarget = this._encIdMapping[eventVal?.encIdTarget];
              if (uidTarget != null) {
                fullPlayerBeforeUpdate[uidTarget] = this._playerIsFullyDefined(uidTarget); // this fullPlayerBeforeUpdate nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
                uids.push(uidTarget);
              } else {
                console.error("got unknown encTargetId");
              }
            }

            for (const entry in eventVal) {
              for (const uid of uids) {
                if (entry === "encId" || entry === "encIdTarget" || eventVal[entry] === undefined) {
                  continue;
                }
                if (!this.players[uid]) {
                  this.players[uid] = {};
                }
                // we will get rid of the playerDeltas as well, but keeping it temporarily for onPlayersConverter
                if (!playerDeltas[uid]) {
                  playerDeltas[uid] = {};
                }
                // we cast to any here because technically string isn't an index type of Player; that would make player a Record under
                // typescript's parlance; but we want to use a regular JS style accessor here, without permanently changing the
                // underlying type, so we temporarily weaken the type assertion to allow us to modify the struct.
                (this.players[uid] as any)[entry] = eventVal[entry];
                if (this._completePlayers[uid]) {
                  // this completePlayers nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
                  (this._completePlayers[uid] as any)[entry] = eventVal[entry];
                }
                (playerDeltas[uid] as any)[entry] = eventVal[entry];
                if (entry === "mapId") {
                  // TODO: Player struct has an inconsistency, it expects map to be named mapId
                  // rename Player struct from map to mapId, or rename proto contents from mapId to map
                  (playerDeltas[uid] as any)["map"] = eventVal[entry];
                  if (this._completePlayers[uid]) {
                    // this completePlayers nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
                    (this._completePlayers[uid] as any)["map"] = eventVal[entry];
                  }
                  (this.players[uid] as any)["map"] = eventVal[entry];
                }
              }
            }
          } else {
            console.error("received unrecognized event:", event.$case);
          }
        }
      }
      // SUBSCRIPTION FORWARDING
      const eventSubs = this.subscriptions[event.$case];
      if (eventSubs) {
        for (const id in eventSubs) {
          const handler = eventSubs[id];
          const eventAny = (event as any)[event.$case];
          const context: ServerClientEventContext = {
            spaceId: space,
          };
          if (eventAny["encId"]) {
            const { encId } = eventAny;
            const uid = this._encIdMapping[encId];
            context.player = this.players[uid];
            context.playerId = uid;
          }
          if (eventAny["encIdTarget"]) {
            const { encIdTarget } = eventAny;
            const uidTarget = this._encIdMapping[encIdTarget];
            context.target = this.players[uidTarget];
            context.targetId = uidTarget;
          }
          // TODO: map events should populate their context as well.

          // It's not ideal that we need to cast this to any, but it's necessary to satisfy TS.
          // Be careful modifying this code - TS isn't protecting us here, so we need to manually
          // ensure we're invoking event sub handlers properly!
          handler(event as any, context);
        }
      }
      // emit onPlayers for legacy code
      // please can we remove this asap :P
      // really need to stop using onPlayers
      let deltaExists = false;
      for (const uid in playerDeltas) {
        const fullPlayerAfterUpdate = this._playerIsFullyDefined(uid); // this fullPlayerBeforeUpdate nonsense is absolutely terrible and we need to stop using onPlayers so we can get rid of it
        if (!fullPlayerAfterUpdate) {
          // the first time we call onPlayers with this player, the delta is expected to be the full state, so don't send it yet
          // this sucks.
          // we should just make the browser code robust to partial Player data
          delete playerDeltas[uid];
        } else {
          deltaExists = true;
          // we're keeping around this completePlayers thing so we don't have to rebuild it from players every time.
          // this sucks too.
          this._completePlayers[uid] = this.players[uid] as Player;
          // ^also, normally casting like this is not ok but we literally just checked so it's chill. kinda.
          // the check is not really trustworthy so this is still bad, but a necessary evil until we get our typing straight
          if (!fullPlayerBeforeUpdate[uid]) {
            // the browser expects the first delta about a player to be its complete state.
            // ...
            playerDeltas[uid] = this._completePlayers[uid];
          }
        }
      }
      if (deltaExists) {
        for (const key in this.legacySubscriptions) {
          // send only complete players
          this.legacySubscriptions[key].onPlayers?.(this._completePlayers, playerDeltas);
        }
      }
    };

    this.engine.onconnect = () => {
      this._connectedAtMs = Date.now();
      this.engine.sendAction({
        $case: "enter",
        enter: {},
      });
      this.subscribeToAll();
      Object.values(this.legacySubscriptionsConnection).forEach((f) => {
        f(true);
      });
    };
    this.engine.ondisconnect = () => {
      Object.values(this.legacySubscriptionsConnection).forEach((f) => {
        f(false);
      });
    };
    this.engine.onreconnected = (timeSpentDisconnectedMs: number) => {
      Object.values(this.legacySubscriptionsReconnected).forEach((f) => {
        f(timeSpentDisconnectedMs);
      });
    };
    this.engine.onlatency = (latency: SlidingWindowMetrics) => {
      Object.values(this.legacySubscriptionsLatency).forEach((f) => {
        f(latency);
      });
    };
    (async () => {
      if (this.engine && this.engine === newEngine) {
        // if it hasn't been destroyed yet
        await newEngine.start();
      }
    })();
  }
  disconnect(space: string) {
    // TODO: JANK PASTA: there is no need to pass in space, minimizing interface breakage
    console.log("Disconnecting space: ", space);
    if (this.engine) {
      this.engine.destroy();
      this.connected = false;
    } else {
      console.log(
        "Destroying an engine that wasn't created in the first place. Was this space real?",
      );
    }
  }

  /* SUBSCRIPTION MANAGEMENT */

  subscribeToEvent<T extends ServerClientEventCase>(
    // `eventId` should ALWAYS be a hardcoded string like "eventName"! See more context below.
    eventId: T,
    handler: (data: ServerClientEventByCase<T>, context: ServerClientEventContext) => void,
  ) {
    console.debug("Subscribing to new event", eventId);

    const subscriptionId = uuid();

    // Having to hard cast these types isn't great and is related to the limitation described below.
    const existingSubs = this.subscriptions[eventId] as GameEventSubscriptionMap[T] | undefined;
    const eventSubs = existingSubs ?? ({} as GameEventSubscriptionMap[T]);
    // @ts-ignore TS doesn't like this because we have the limitation of not being able to specify that
    // eventId will always be a *single* type from the ServerClientEventCase union. Given that we know this
    // API won't ever be used in situations where <T> has more than one possible value, we can just weaken
    // typing a bit here to get around this limitation.
    eventSubs[subscriptionId] = handler;
    this.subscriptions[eventId] = eventSubs;
    return () => {
      delete this.subscriptions[eventId]?.[subscriptionId];
    };
  }

  // old version, DO NOT USE
  subscribeToSpace(space: string, listeners: GameSpaceSubscription) {
    // send subscribe message, store the subscription
    const handle = uuid();
    if (!this.legacySubscriptions) {
      this.maps = {};
      this.legacySubscriptions = {};
      this.subscribeToAll();
    }
    this.legacySubscriptions[handle] = listeners;
    // return unsubscribe
    return () => {
      delete this.legacySubscriptions[handle];
      if (Object.keys(this.legacySubscriptions).length === 0) {
        this.maps = {};
        this.legacySubscriptions = {};
        // we no longer want to unsubscribe here, because if we did, we might disconnect the parallel subscribeToEvent handlers
        // eventually, this entire function will go away, so it's okay if some random events are just fired into the aether for now
      }
    };
  }
  subscribeToConnection(callback: (connected: boolean) => void): () => void {
    const handle = uuid();
    this.legacySubscriptionsConnection[handle] = callback;
    return () => {
      delete this.legacySubscriptionsConnection[handle];
    };
  }
  subscribeToReconnected(callback: (timeSpentDisconnectedMs: number) => void): () => void {
    const handle = uuid();
    this.legacySubscriptionsReconnected[handle] = callback;
    return () => {
      delete this.legacySubscriptionsReconnected[handle];
    };
  }
  subscribeToLatency(callback: (latency: SlidingWindowMetrics) => void): () => void {
    const handle = uuid();
    this.legacySubscriptionsLatency[handle] = callback;
    return () => {
      delete this.legacySubscriptionsLatency[handle];
    };
  }

  /* TAKE ACTIONS */

  enter(space: string, info: any, spawnToken?: string) {
    if (!this.entrances) {
      this.engine.sendAction({
        $case: "enter",
        enter: {
          spawnToken,
          info,
        },
      });
      this.entrances = 0;
    }
    this.entrances += 1;
  }
  exit() {
    this.entrances -= 1;
    if (this.entrances === 0) {
      this.engine.sendAction({
        $case: "exit",
        exit: {},
      });
      this.entrances = 0;
    }
  }
  respawn() {
    this.engine?.sendAction({
      $case: "respawn",
      respawn: {},
    });
  }
  spawn(spawnToken: string) {
    this.engine.sendAction({
      $case: "spawn",
      spawn: {
        spawnToken,
      },
    });
  }
  move(dir: MoveDirection, stopped = false, targetId?: string) {
    const inputId = this.inputId++;
    this.onInput?.(dir, stopped, inputId);
    this.engine.sendAction({
      $case: "move",
      move: {
        dir,
        stopped,
        inputId,
        targetId,
      },
    });
  }
  /**
    Puts the currently connected client in ghost mode
    @param space you must be connected already to invoke this function
    @param ghost ghost value, either 1 or 0; whether you are ghosting or not.
    @param targetId id of player whose ghost value you want to set (must be space owner to set)
  */
  ghost(ghost: number, targetId?: string) {
    this.engine.sendAction({
      $case: "ghost",
      ghost: {
        ghost,
        targetId,
      },
    });
  }
  /**
   *
   * @param space string - space - you must be connected already to invoke this function
   * @param recipientId player ID of the other
   * @param dir MoveDirection enum
   */
  enterWhisper(recipientId: string, dir: MoveDirection) {
    this.engine.sendAction({
      $case: "enterWhisper",
      enterWhisper: {
        recipientId,
        dir,
      },
    });
  }
  leaveWhisper() {
    this.engine.sendAction({
      $case: "leaveWhisper",
      leaveWhisper: {},
    });
  }
  teleport(mapId: string, x: number, y: number, targetId?: string) {
    this.engine.sendAction({
      $case: "teleport",
      teleport: {
        mapId,
        x,
        y,
        targetId,
      },
    });
  }
  ring(user: string) {
    this.engine.sendAction({
      $case: "ring",
      ring: {
        user,
      },
    });
  }
  pointer(objectId: string, x: number, y: number) {
    this.engine.sendAction({
      $case: "setImagePointer",
      setImagePointer: {
        objectId,
        x,
        y,
      },
    });
  }
  setActivelySpeaking(activelySpeaking: boolean) {
    this.engine.sendAction({
      $case: "activelySpeaking",
      activelySpeaking: {
        activelySpeaking,
      },
    });
  }
  setEmote(emote: Emote, targetId?: string) {
    this.engine.sendAction({
      $case: "setEmote",
      setEmote: {
        emote,
        targetId,
      },
    });
  }
  setWorkCondition(workCondition: boolean) {
    this.engine.sendAction({
      $case: "setWorkCondition",
      setWorkCondition: {
        workCondition,
      },
    });
  }
  setName(name: string, targetId?: string) {
    this.engine.sendAction({
      $case: "setName",
      setName: {
        name,
        targetId,
      },
    });
  }
  setTextStatus(textStatus: string, targetId?: string) {
    this.engine.sendAction({
      $case: "setTextStatus",
      setTextStatus: {
        textStatus,
        targetId,
      },
    });
  }
  setEmojiStatus(emojiStatus: string, targetId?: string) {
    this.engine.sendAction({
      $case: "setEmojiStatus",
      setEmojiStatus: {
        emojiStatus,
        targetId,
      },
    });
  }
  setAffiliation(affiliation: string) {
    this.engine.sendAction({
      $case: "setAffiliation",
      setAffiliation: {
        affiliation,
      },
    });
  }
  setStatus(status: boolean, targetId?: string) {
    this.engine.sendAction({
      $case: "setStatus",
      setStatus: {
        status,
        targetId,
      },
    });
  }
  setEventStatus(eventStatus: string) {
    this.engine.sendAction({
      $case: "setEventStatus",
      setEventStatus: {
        eventStatus,
      },
    });
  }
  setInConversation(inConversation: boolean) {
    this.engine.sendAction({
      $case: "setInConversation",
      setInConversation: {
        inConversation,
      },
    });
  }
  setCurrentDesk(currentDesk: string) {
    this.engine.sendAction({
      $case: "setCurrentDesk",
      setCurrentDesk: {
        currentDesk,
      },
    });
  }
  setCurrentArea(currentArea: string) {
    this.engine.sendAction({
      $case: "setCurrentArea",
      setCurrentArea: {
        currentArea,
      },
    });
  }
  setSprite(sprite: number, targetId?: string) {
    this.engine.sendAction({
      $case: "setSprite",
      setSprite: {
        sprite,
        targetId,
      },
    });
  }
  setOutfitString(outfitString: string, targetId?: string) {
    this.engine?.sendAction({
      $case: "setOutfitString",
      setOutfitString: {
        outfitString,
        targetId,
      },
    });
  }
  setSpotlight(user: string, spotlighted: boolean) {
    this.engine.sendAction({
      $case: "spotlight",
      spotlight: {
        spotlightedUser: user,
        isSpotlighted: spotlighted,
      },
    });
  }
  banPlayer(user: string) {
    this.engine.sendAction({
      $case: "ban",
      ban: {
        user,
      },
    });
  }
  kickPlayer(user: string) {
    this.engine.sendAction({
      $case: "kick",
      kick: {
        user,
      },
    });
  }
  interact(objId: string, data?: any) {
    this.engine.sendAction({
      $case: "interact",
      interact: {
        objId,
        dataJson: JSON.stringify(data),
      },
    });
  }
  chat(chatRecipient: any, localPlayers: any, mapId: string, contents: any) {
    this.engine.sendAction({
      $case: "chat",
      chat: {
        chatRecipient,
        localPlayerIds: localPlayers,
        mapId,
        contents,
      },
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  shootConfetti() {
    this.engine?.sendAction({
      $case: "shootConfetti",
      shootConfetti: {},
    });
  }
  setGoKartId(goKartId: string) {
    this.engine?.sendAction({ $case: "setGoKartId", setGoKartId: { goKartId } });
  }

  /* EDITOR ONLY ACTIONS */

  setImpassable(mapId: string, x: number, y: number, impassable = true) {
    this.engine.sendAction({
      $case: "setImpassable",
      setImpassable: {
        mapId,
        x,
        y,
        impassable,
      },
    });
  }
  getObject(objId: string): any {
    for (const mapId of Object.keys(this.maps)) {
      const currMap = this.maps?.[mapId];
      const i = currMap.objects.findIndex((o: any) => o.id === objId);
      if (i >= 0) {
        return { mapId: mapId, obj: cloneDeep(currMap.objects[i]) };
      }
    }
  }
  setObject(mapId: string, objId: string, obj: Record<string, unknown>) {
    let currMap = this.maps?.[mapId];
    if (!currMap) {
      return;
    }
    currMap = cloneDeep(currMap);
    const i = currMap.objects.findIndex((o: any) => o.id === objId);
    if (i >= 0) {
      currMap.objects[i] = {
        ...currMap.objects[i],
        ...obj,
      };
    } else {
      currMap.objects.push({ id: objId, ...obj });
    }
    this._updateMap(getDiff(this.maps[mapId], currMap), mapId);
  }
  deleteObject(mapId: string, objId: string) {
    let currMap = this.maps?.[mapId];
    if (!currMap) {
      return;
    }
    currMap = cloneDeep(currMap);
    const i = currMap.objects.findIndex((o: any) => o.id === objId);
    if (i >= 0) {
      currMap.objects.splice(i, 1);
      this._updateMap(getDiff(this.maps[mapId], currMap), mapId);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async flushObjectsToFirebase(space: string, mapId: string) {
    // covered by game server now!
    // leaving it here so we have time to make extensions not call this function
    console.warn(
      "DeprecationWarning: This function has been deprecated and is now a no-op. It doesn't do anything. Happy hacking <3",
    );

    return;
  }
  _updateMap(diff: rdiff.rdiffResult[], mapId: string) {
    this.engine.sendAction({
      $case: "mapUpdate",
      mapUpdate: {
        mapId,
        diffJson: JSON.stringify(diff),
      },
    });
  }

  getStats(): GameClientStats | undefined {
    return {
      serverURL: this.engine.serverURL,
      engine: this.engine.getMetrics(),
      timeToFirstMapDataMs: this._timeToFirstMapDataMs,
    };
  }

  // TODO: ABSTRACTION PASTA; this effectively subscribes you to every event so the onPlayers, on... handlers work properly. This can go away after.
  subscribeToAll() {
    this.engine.sendAction({
      $case: "updateSubscriptions",
      updateSubscriptions: {
        subscriptions: {
          playerSetsSprite: true,
          playerSetsAffiliation: true,
          playerSetsStatus: true,
          playerSpotlights: true,
          playerRings: true,
          playerInteracts: true,
          playerSetsImagePointer: true,
          playerChats: true,
          playerSetsOutfitString: true,
          playerMoves: true,
          playerSetsName: true,
          playerGhosts: true,
          playerSetsEmote: true,
          playerSetsWorkCondition: true,
          playerActivelySpeaks: true,
          playerSetsTextStatus: true,
          playerSetsEmojiStatus: true,
          playerEntersWhisperV2: true,
          playerLeavesWhisper: true,
          playerSetsIsSignedIn: true,
          mapUpdates: true,
          mapOverwrites: true,
          spaceOverwrites: true,
          spaceIsClosed: true,
          spaceSetsIdMapping: true,
          playerEntersPortal: true,
          respawnComplete: true,
          playerExits: true,
          info: true,
          warn: true,
          error: true,
          serverHeartbeat: true,
          disableVideo: true,
          playerSetsLastActive: true,
          playerShootsConfetti: true,
          playerSetsEventStatus: true,
          playerSetsInConversation: true,
          playerSetsCurrentDesk: true,
          playerSetsCurrentArea: true,
          cookieFound: true,
          playerSetsGoKartId: true,
        },
      },
    });
  }

  _playerIsFullyDefined(uid: string) {
    if (this._fullyDefinedPlayersSet.has(uid)) {
      return true;
    }
    // TODO: Think of more robust way to do this iff the immediate followup game-client refactor doesn't remove the need for it
    if (this.players[uid] && Object.keys(this.players[uid]).length === 24) {
      this._fullyDefinedPlayersSet.add(uid);
      return true;
    }
    return false;
  }
}
