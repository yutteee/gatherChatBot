import { Player } from "@gathertown/gather-game-common";

export const isBrowser = typeof window !== "undefined";

export interface SlidingWindowMetrics {
  min: number;
  max: number;
  avg: number;
  last: number;
}

export interface ServerClientEventContext {
  /**
   * The space this client is operating on. Mostly for convenience
   */
  spaceId: string;
  /**
   * If encId is present on the incoming event, then _player_ will be populated here. You are not guaranteed completeness in the player object, some fields may be undefined.
   */
  player?: Partial<Player>;
  /**
   * If encIdTarget is present on the incoming event, then _target_ will be populated. You are not guaranteed completeness, just like player; it's whatever is in the state.
   */
  target?: Partial<Player>;
  /**
   * The uid of the player, if present.
   */
  playerId?: string;
  /**
   * The uid of the target, if present.
   */
  targetId?: string;
}

export class SlidingWindow {
  maxSize: number;
  values: number[] = [];
  _minValue?: number;
  _maxValue?: number;
  _lastValue?: number;

  constructor(maxSize: number) {
    this.maxSize = maxSize;
  }

  push(value: number) {
    this._lastValue = value;
    this.values.push(value);
    if (this.values.length > this.maxSize) {
      this.values.shift();
    }
    if (typeof this._minValue === "undefined" || value < this._minValue) {
      this._minValue = value;
    }
    if (typeof this._maxValue === "undefined" || value > this._maxValue) {
      this._maxValue = value;
    }
  }

  getLast() {
    return this._lastValue;
  }

  getAverage() {
    if (!this.values.length) {
      return undefined;
    }
    const avg = this.values.reduce((acc, v) => v + acc, 0) / this.values.length;
    return parseFloat(avg.toFixed(2));
  }

  getMin() {
    if (!this._minValue) {
      return undefined;
    }
    return parseFloat(this._minValue.toFixed(2));
  }

  getMax() {
    if (!this._maxValue) {
      return undefined;
    }
    return parseFloat(this._maxValue?.toFixed(2));
  }

  getMetrics(): SlidingWindowMetrics {
    return {
      max: this.getMax() || -1,
      avg: this.getAverage() || -1,
      min: this.getMin() || -1,
      last: this.getLast() || -1,
    };
  }
}
