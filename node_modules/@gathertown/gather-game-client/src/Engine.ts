/*

Be careful changing this file! Please talk to the Engine Team/get them to review

*/

import {
  ClientServerAction,
  ClientServerActionAction,
  GameWsCloseCode,
  ServerClientBatch,
  ServerClientEvent,
} from "@gathertown/gather-game-common";
import { SlidingWindow, SlidingWindowMetrics } from "./Utils";

// TODO: sync with server, maybe
const HEARTBEAT_INTERVAL = 10000;
const HEARTBEAT_TIMEOUT = 30000;
const INITIAL_RECONNECT_DELAY = 1000;
const MAX_RECONNECT_DELAY = 15000; // max time to wait before trying to connect again. actually can be at most double this
const RESET_RECONNECT_ATTEMPTS_DELAY = 60000; // have to be connected for 30 seconds to be considered a successfull reconnect

export type EngineAuth = { token: string } | { apiKey: string };

export interface GameEngineMetrics {
  latency: {
    min: number;
    avg: number;
    max: number;
    last: number;
  };
  reconnects: {
    timeSpentDisconnectedMs: {
      min: number;
      avg: number;
      max: number;
      last: number;
    };
    count: number;
  };
  errors: {
    count: number;
  };
}

export class Engine {
  ws?: WebSocket;
  serverURL = "";
  getAuth: () => Promise<EngineAuth>;
  getGameServerUrl: (space: string) => Promise<string>;
  spaceId: string;

  _connected = false;
  _sendQ: ClientServerActionAction[] = [];

  _textDecoder = new TextDecoder();
  _textDecoderUtf8 = new TextDecoder("utf-8");
  _textEncoder = new TextEncoder();

  _heartbeatInterval: any = 0; // number or Timeout, depending on browser vs. node
  _reconnectTimer: any = 0; // number or Timeout, depending on browser vs. node
  _reconnectionAttempts = 0;
  _resetReconnectionAttemptsTimer: any = 0; // number or Timeout, depending on browser vs. node
  _lastHeartbeat = Infinity;

  // Stats
  _latencies = new SlidingWindow(10);
  _errorsCount = 0;
  _successfulReconnectionsCount = 0;
  _reconnectStartTime = 0;
  _successfulReconnectsCount = 0;
  _timeSpentDisconnected = new SlidingWindow(10);

  /* to be overridden by user */
  onevent(_e: ServerClientEvent) {}
  onconnect() {}
  ondisconnect() {}
  onreconnected(_: number) {}
  onlatency(_: SlidingWindowMetrics) {}

  // Params
  // ------
  // getAuth: A function that returns an auth token/key that the Engine should
  //   use to authenticate itself with the game server.
  constructor(
    getAuth: () => Promise<EngineAuth>,
    getGameServerUrl: (space: string) => Promise<string>,
    spaceId: string,
  ) {
    this.getAuth = getAuth;
    this.getGameServerUrl = getGameServerUrl;
    this.spaceId = spaceId;
  }

  async start() {
    try {
      this.serverURL = await this.getGameServerUrl(this.spaceId);
      this._connect(this.serverURL);
    } catch (e) {
      console.debug(`Error starting game engine:`, e);
      this._reconnect();
    }
  }

  destroy() {
    this.ondisconnect();
    this.onconnect = () => {};
    this.ondisconnect = () => {};
    this.onreconnected = () => {};
    this.onlatency = () => {};
    this._destroyInternal();
  }

  async _connect(endpoint: string) {
    const auth = await this.getAuth();
    // connect to server
    try {
      this.ws = new WebSocket(endpoint, "gather-v2");
    } catch (e) {
      console.error(`Failed to create websocket connection to gameserver: ${endpoint}`, e);
      this._reconnect();
      return;
    }
    this.ws.binaryType = "arraybuffer";

    // check for disconnections
    this._lastHeartbeat = Date.now();
    this._heartbeatInterval = setInterval(() => {
      if (this._lastHeartbeat < Date.now() - HEARTBEAT_TIMEOUT) {
        this.ws?.close(
          GameWsCloseCode.CONN_TIMED_OUT,
          `Game Server timed out. No heartbeat since ${new Date(this._lastHeartbeat)}`,
        );
      }
    }, HEARTBEAT_INTERVAL);

    // when created, initialize with our auth token
    this.ws.onopen = () => {
      if (this.ws == null) {
        // never actually happens, just for TS to be happy
        console.error("something is very wrong, ws is null after open");
        return;
      }

      // kind of annoying, we have to send this before onconnect
      this.sendAction(
        {
          $case: "init",
          init: {
            spaceId: this.spaceId,
            auth:
              "token" in auth
                ? { $case: "token", token: auth.token }
                : { $case: "apiKey", apiKey: auth.apiKey },
          },
        },
        true,
      );
      this.onconnect();

      if (this._reconnectStartTime) {
        const timeSpentDisconnectedMs = Date.now() - this._reconnectStartTime;
        // Reset the reconnection attempt after a few seconds
        // to avoid when user connects and disconnects
        // this will get cancelled if it disconnects before thie timeout goes off
        this._resetReconnectionAttemptsTimer = setTimeout(() => {
          this._reconnectionAttempts = 0;

          // If the client has connected for a few seconds,
          // this counts as a reconnection so track it.
          this._successfulReconnectsCount += 1;
          this._timeSpentDisconnected.push(timeSpentDisconnectedMs);
          this._reconnectStartTime = 0;

          this.onreconnected(timeSpentDisconnectedMs);
        }, RESET_RECONNECT_ATTEMPTS_DELAY);
      }

      this._onmessageSetup();
    };

    this.ws.onclose = (event) => {
      this._connected = false;
      console.log(
        `Web socket on close, about to call disconnect: close code ${event.code} reason ${event.reason} value ${event.returnValue}`,
      );
      switch (event.code) {
        case GameWsCloseCode.SPACE_AT_CAPACITY:
          console.log("Space is currently at capacity, please try again later");
          break;
        case GameWsCloseCode.PROTOCOL_ERROR:
          console.error("ws closed: protocol error. " + event.reason);
          if (typeof window !== "undefined") {
            window.location.reload();
          }
          // TODO: else extension, restart or something intelligent, don't just ignore it
          break;
        case GameWsCloseCode.INTERNAL_ERROR:
          console.warn("connection closed due to internal server error:", event);
          if (typeof window !== "undefined") {
            window.location.reload();
          }
          break;
        case GameWsCloseCode.CLIENT_KICKED:
          console.warn("connection closed due to client being kicked");
          if (typeof window !== "undefined") {
            window.location.reload();
          }
          break;
        case GameWsCloseCode.UNAUTHORIZED:
          console.warn("connection closed because user does not have access");
          // reload because the FE will show them a nice landing screen instead
          if (typeof window !== "undefined") {
            window.location.reload();
          }
          break;
        case GameWsCloseCode.NO_STATUS_RECEIVED:
          console.warn("connection closed unexpectedly with no status:", event);
          this._reconnect();
          break;
        default:
          console.warn("connection closed with unrecognized non-default code:", event);
          this._reconnect();
      }
      this.ondisconnect();
    };

    this.ws.onerror = (e) => {
      console.log("game server error", e);
      this._errorsCount += 1;
    };
  }

  _onmessageSetup() {
    if (this.ws == null) {
      return;
    } // never actually happens, just for TS to be happy

    console.log("starting with new interface:", this.ws.protocol);

    // handle messages
    this.ws.onmessage = (msg) => {
      const data = new Uint8Array(msg.data);
      try {
        const { events } = ServerClientBatch.decode(data);
        this._lastHeartbeat = Date.now(); // if we get any message, it means the server is alive
        events.forEach((serverClientEvent) => {
          const event = serverClientEvent.event;
          if (!event) {
            console.error(
              "Nullish server client event; this shouldn't happen! ",
              serverClientEvent,
            );
            return;
          }
          switch (event.$case) {
            case "serverHeartbeat":
              this.sendAction({
                $case: "clientHeartbeat",
                clientHeartbeat: {},
              });
              if (event.serverHeartbeat.lastRTT) {
                this._latencies.push(event.serverHeartbeat.lastRTT / 2);
                this.onlatency(this._latencies.getMetrics());
              }
              break;
            case "ready":
              this._connected = true;
              this._sendQ.forEach((m) => {
                this.sendAction(m);
              });
              this._sendQ = [];
              break;
            case "info":
              console.log("[info from gs]", event.info.message);
              break;
            case "warn":
              console.warn("[warn from gs]", event.warn.message);
              break;
            case "error":
              console.error(`[error from gs] ${event.error.code}:`, event.error.message);
              // TODO later: do different things with different error codes, when they actually have meanings assigned
              break;
            default:
              this.onevent(serverClientEvent);
          }
        });
      } catch (e) {
        console.warn("Failed to process event with error:", e);
      }
    };
  }

  _destroyInternal() {
    clearInterval(this._heartbeatInterval);
    clearTimeout(this._reconnectTimer);
    this._reconnectTimer = null;
    clearTimeout(this._resetReconnectionAttemptsTimer);
    this._resetReconnectionAttemptsTimer = null;
    if (this.ws) {
      this.ws.onclose = () => {};
      this.ws.close();
      this.ws = undefined;
    }
  }

  sendAction(action: ClientServerActionAction, bypass = false) {
    if (!this._connected && !bypass) {
      this._sendQ.push(action);
      return;
    }
    try {
      const serializedAction = ClientServerAction.encode({
        action,
      }).finish();
      this.ws?.send(serializedAction);
    } catch (e) {
      console.warn("websocket send error", e);
    }
  }

  _reconnect() {
    if (this._reconnectTimer) {
      return;
    }

    if (this._reconnectionAttempts === 0) {
      this._reconnectStartTime = Date.now();
    }

    // Exponential backoff and Jitter per https://stripe.com/blog/idempotency

    // Clear reset timer since we are trying to reconnect
    clearInterval(this._resetReconnectionAttemptsTimer);
    this._resetReconnectionAttemptsTimer = null;

    // Apply exponential backoff with INITIAL_RECONNECT_DELAY on the
    // number of attempts so far as inputs. Do not allow the number to exceed
    // MAX_RECONNECT_DELAY
    let reconnectDelay = Math.min(
      INITIAL_RECONNECT_DELAY * 2 ** (this._reconnectionAttempts - 1),
      MAX_RECONNECT_DELAY,
    );

    // Apply some jitter by randomizing the value in the range of (reconnectDelay / 2 to (reconnectDelay).
    reconnectDelay = reconnectDelay * (0.5 * (1 + Math.random()));

    // But never delay less than INITIAL_RECONNECT_DELAY
    reconnectDelay = Math.max(INITIAL_RECONNECT_DELAY, reconnectDelay);

    this._reconnectionAttempts++;

    this._reconnectTimer = setTimeout(() => {
      this._destroyInternal();
      this.start();
    }, reconnectDelay);
  }

  getMetrics(): GameEngineMetrics {
    return {
      latency: this._latencies.getMetrics(),
      reconnects: {
        timeSpentDisconnectedMs: this._timeSpentDisconnected.getMetrics(),
        count: this._successfulReconnectsCount,
      },
      errors: {
        count: this._errorsCount,
      },
    };
  }
}
