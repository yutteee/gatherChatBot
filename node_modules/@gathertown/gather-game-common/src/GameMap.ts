// Note: When adding to or modifying these types, please also adjust the types in modules/gather-http-server/src/v2/db/spaceRoom.ts
import { cloneDeep } from "lodash";
import { Position } from "./Position";
import {
  Animation,
  Announcer,
  AreaPosition,
  Asset,
  AudioEmitter,
  InteractionEnum_ENUM as Interaction,
  WireObject,
  Point,
  Portal,
  Space,
  SpawnPoint,
} from "./generated_DO_NOT_TOUCH/events";
export { Interaction };

// Ideally we will consolidate this in a single place, but for now we have to manually sync them.
export class GameMap {
  id: string;
  dimensions: [number, number];
  collisions: string; // base64 encoded array of dimensions[1] x dimensions[0] bytes
  backgroundImagePath: string; // url
  foregroundImagePath?: string;
  sprites?: number[];
  spaces: Space[];
  spawn?: Point; // TODO remove
  spawns: SpawnPoint[];
  portals: Portal[];
  announcer: Announcer[];
  audio?: AudioEmitter[];
  animations?: Animation[];
  assets?: Asset[];
  objects?: MapObject[];
  name?: string; //What is the map actually called
  defaultChat?: string; // Which chat should we default to
  muteOnEntry?: boolean;
  useDrawnBG?: boolean;
  walls?: WallFloorBlock[];
  floors?: WallFloorBlock[];
  mostRecentUpdateId?: number;
  areas?: DBAreas;
}

export interface GameMapDB extends Omit<GameMap, "walls" | "floors"> {
  walls?: WallFloorDB;
  floors?: WallFloorDB;
}

export class WallBlock {
  x: number;
  y: number;
  wallType: number;
}

export class FloorBlock {
  x: number;
  y: number;
  floorType: number;
}

export type WallFloorBlock = WallBlock | FloorBlock;

/*
  In code logic, walls and floors are represented as WallBlock or Floorblock
  In Firestore, for the sake of memory, it is represented as a map:
  {
    floorWallType1 (string): bytearray (string),
    floorWallType2 (string): bytearray (string),
    ...
  }
  where the bytearray is 0x01 if a wall/floor exists there, and 0x00 otherwise
  (like collisions)
*/
export class WallFloorDB {
  [type: string]: string;
}

export class Tile {
  x: number;
  y: number;
  tileType: TileType;
  info?: Space | Portal;
}

type MakeFieldsRequired<T, K extends keyof T> = Required<Pick<T, K>> & T;
type WireMapObjectRequiredFields =
  | "x"
  | "y"
  | "normal"
  | "highlighted"
  | "type"
  | "width"
  | "height";
type WireObjectWithRequireds = MakeFieldsRequired<WireObject, WireMapObjectRequiredFields>;

// WireObject is defined in events.proto, but uses only optional types, a stringified json for
// an object properties, and a default of empty array for tags, so we replace those here
export interface MapObject extends Omit<WireObjectWithRequireds, "propertiesJson" | "_tags"> {
  _tags?: string[];
  properties?: Record<string, any>;
}

export function findMissingMapObjectFields(object: any) {
  const requiredFields = ["x", "y", "normal", "highlighted", "type", "width", "height"];
  const missingFields: string[] = [];
  for (const field of requiredFields) {
    if (object[field] === undefined) {
      missingFields.push(field);
    }
  }
  return missingFields;
}

// Note: this function is safe only because we use findMissingMapObjectFields
export function convertWireObjectToMapObject(wireObject: WireObject): MapObject {
  const mapObject: any = cloneDeep(wireObject);
  if (wireObject.propertiesJson) {
    mapObject.properties = JSON.parse(wireObject.propertiesJson);
    delete mapObject.propertiesJson;
  }
  if (wireObject._tags && wireObject._tags.length === 0) {
    delete mapObject._tags;
  }
  const missingFields = findMissingMapObjectFields(mapObject);
  if (missingFields.length > 0) {
    throw `Failed to convert to MapObject because the following required fields were missing: ${missingFields}`;
  }
  return mapObject as MapObject;
}

export function convertMapObjectToWireObject(mapObject: MapObject): WireObject {
  const wireObject: any = cloneDeep(mapObject);
  if (mapObject.properties) {
    wireObject.propertiesJson = JSON.stringify(mapObject.properties);
    delete wireObject.properties;
  }
  if (!mapObject._tags) {
    wireObject._tags = [];
  }
  return wireObject;
}

enum AreaCategory {
  RW_OFFICE_LOBBY = "RW_OFFICE_LOBBY",
  RW_OFFICE_MEETING = "RW_OFFICE_MEETING",
}
// Note, there is an analog in events.proto called Area that needs to be changed whenever this is changed
class DBAreas {
  [name: string]: {
    categories: AreaCategory;
    coords: AreaPosition[];
  };
}

export function convertStringToAreaCategory(s: string): AreaCategory {
  if (!(s in AreaCategory)) {
    throw "Invalid area category";
  }
  return s as AreaCategory;
}

export enum TileType {
  Impassable = 1,
  Spawn,
  Portal,
  Announcer,
  Space,
}

const MODAL_INTERACTIONS = [
  Interaction.EMBEDDED_WEBSITE,
  Interaction.POSTER,
  Interaction.VIDEO,
  Interaction.EXTERNAL_CALL,
  Interaction.NOTE,
  Interaction.MODAL_EXTENSION,
  Interaction.COMPONENT_MODAL,
] as const;

export type ModalInteraction = typeof MODAL_INTERACTIONS[number];

export function interactionOpensModal(i: Interaction) {
  return (MODAL_INTERACTIONS as readonly Interaction[]).includes(i);
}

export function areaToCoords(coordsMap: boolean[][]) {
  const coords: Position[] = [];
  for (let y = 0; y < coordsMap.length; y++) {
    for (let x = 0; x < coordsMap[0].length; x++) {
      if (coordsMap[y][x] === true) {
        coords.push({ x, y });
      }
    }
  }
  return coords;
}
