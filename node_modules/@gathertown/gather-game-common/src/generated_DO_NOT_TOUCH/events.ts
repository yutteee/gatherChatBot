/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "";

export interface SpriteDirectionEnum {}

export enum SpriteDirectionEnum_ENUM {
  Stand = 0,
  Down = 1,
  DownAlt = 2,
  Up = 3,
  UpAlt = 4,
  Left = 5,
  LeftAlt = 6,
  Right = 7,
  RightAlt = 8,
  Dance1 = 9,
  Dance2 = 10,
  Dance3 = 11,
  Dance4 = 12,
}

export function spriteDirectionEnum_ENUMFromJSON(object: any): SpriteDirectionEnum_ENUM {
  switch (object) {
    case 0:
    case "Stand":
      return SpriteDirectionEnum_ENUM.Stand;
    case 1:
    case "Down":
      return SpriteDirectionEnum_ENUM.Down;
    case 2:
    case "DownAlt":
      return SpriteDirectionEnum_ENUM.DownAlt;
    case 3:
    case "Up":
      return SpriteDirectionEnum_ENUM.Up;
    case 4:
    case "UpAlt":
      return SpriteDirectionEnum_ENUM.UpAlt;
    case 5:
    case "Left":
      return SpriteDirectionEnum_ENUM.Left;
    case 6:
    case "LeftAlt":
      return SpriteDirectionEnum_ENUM.LeftAlt;
    case 7:
    case "Right":
      return SpriteDirectionEnum_ENUM.Right;
    case 8:
    case "RightAlt":
      return SpriteDirectionEnum_ENUM.RightAlt;
    case 9:
    case "Dance1":
      return SpriteDirectionEnum_ENUM.Dance1;
    case 10:
    case "Dance2":
      return SpriteDirectionEnum_ENUM.Dance2;
    case 11:
    case "Dance3":
      return SpriteDirectionEnum_ENUM.Dance3;
    case 12:
    case "Dance4":
      return SpriteDirectionEnum_ENUM.Dance4;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum SpriteDirectionEnum_ENUM",
      );
  }
}

export function spriteDirectionEnum_ENUMToJSON(object: SpriteDirectionEnum_ENUM): string {
  switch (object) {
    case SpriteDirectionEnum_ENUM.Stand:
      return "Stand";
    case SpriteDirectionEnum_ENUM.Down:
      return "Down";
    case SpriteDirectionEnum_ENUM.DownAlt:
      return "DownAlt";
    case SpriteDirectionEnum_ENUM.Up:
      return "Up";
    case SpriteDirectionEnum_ENUM.UpAlt:
      return "UpAlt";
    case SpriteDirectionEnum_ENUM.Left:
      return "Left";
    case SpriteDirectionEnum_ENUM.LeftAlt:
      return "LeftAlt";
    case SpriteDirectionEnum_ENUM.Right:
      return "Right";
    case SpriteDirectionEnum_ENUM.RightAlt:
      return "RightAlt";
    case SpriteDirectionEnum_ENUM.Dance1:
      return "Dance1";
    case SpriteDirectionEnum_ENUM.Dance2:
      return "Dance2";
    case SpriteDirectionEnum_ENUM.Dance3:
      return "Dance3";
    case SpriteDirectionEnum_ENUM.Dance4:
      return "Dance4";
    default:
      return "UNKNOWN";
  }
}

export interface MoveDirectionEnum {}

export enum MoveDirectionEnum_ENUM {
  Left = 0,
  Right = 1,
  Up = 2,
  Down = 3,
  Dance = 4,
}

export function moveDirectionEnum_ENUMFromJSON(object: any): MoveDirectionEnum_ENUM {
  switch (object) {
    case 0:
    case "Left":
      return MoveDirectionEnum_ENUM.Left;
    case 1:
    case "Right":
      return MoveDirectionEnum_ENUM.Right;
    case 2:
    case "Up":
      return MoveDirectionEnum_ENUM.Up;
    case 3:
    case "Down":
      return MoveDirectionEnum_ENUM.Down;
    case 4:
    case "Dance":
      return MoveDirectionEnum_ENUM.Dance;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum MoveDirectionEnum_ENUM",
      );
  }
}

export function moveDirectionEnum_ENUMToJSON(object: MoveDirectionEnum_ENUM): string {
  switch (object) {
    case MoveDirectionEnum_ENUM.Left:
      return "Left";
    case MoveDirectionEnum_ENUM.Right:
      return "Right";
    case MoveDirectionEnum_ENUM.Up:
      return "Up";
    case MoveDirectionEnum_ENUM.Down:
      return "Down";
    case MoveDirectionEnum_ENUM.Dance:
      return "Dance";
    default:
      return "UNKNOWN";
  }
}

export interface EmoteEnum {}

export enum EmoteEnum_ENUM {
  None = 0,
  Wave = 1,
  Heart = 2,
  PartyPopper = 3,
  ThumbsUp = 4,
  QuestionMark = 5,
  RaisedHand = 6,
}

export function emoteEnum_ENUMFromJSON(object: any): EmoteEnum_ENUM {
  switch (object) {
    case 0:
    case "None":
      return EmoteEnum_ENUM.None;
    case 1:
    case "Wave":
      return EmoteEnum_ENUM.Wave;
    case 2:
    case "Heart":
      return EmoteEnum_ENUM.Heart;
    case 3:
    case "PartyPopper":
      return EmoteEnum_ENUM.PartyPopper;
    case 4:
    case "ThumbsUp":
      return EmoteEnum_ENUM.ThumbsUp;
    case 5:
    case "QuestionMark":
      return EmoteEnum_ENUM.QuestionMark;
    case 6:
    case "RaisedHand":
      return EmoteEnum_ENUM.RaisedHand;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EmoteEnum_ENUM");
  }
}

export function emoteEnum_ENUMToJSON(object: EmoteEnum_ENUM): string {
  switch (object) {
    case EmoteEnum_ENUM.None:
      return "None";
    case EmoteEnum_ENUM.Wave:
      return "Wave";
    case EmoteEnum_ENUM.Heart:
      return "Heart";
    case EmoteEnum_ENUM.PartyPopper:
      return "PartyPopper";
    case EmoteEnum_ENUM.ThumbsUp:
      return "ThumbsUp";
    case EmoteEnum_ENUM.QuestionMark:
      return "QuestionMark";
    case EmoteEnum_ENUM.RaisedHand:
      return "RaisedHand";
    default:
      return "UNKNOWN";
  }
}

export interface InteractionEnum {}

export enum InteractionEnum_ENUM {
  NONE = 0,
  EMBEDDED_WEBSITE = 1,
  POSTER = 2,
  VIDEO = 3,
  EXTERNAL_CALL = 4,
  EXTENSION = 5,
  NOTE = 6,
  MODAL_EXTENSION = 7,
  COMPONENT_MODAL = 8,
}

export function interactionEnum_ENUMFromJSON(object: any): InteractionEnum_ENUM {
  switch (object) {
    case 0:
    case "NONE":
      return InteractionEnum_ENUM.NONE;
    case 1:
    case "EMBEDDED_WEBSITE":
      return InteractionEnum_ENUM.EMBEDDED_WEBSITE;
    case 2:
    case "POSTER":
      return InteractionEnum_ENUM.POSTER;
    case 3:
    case "VIDEO":
      return InteractionEnum_ENUM.VIDEO;
    case 4:
    case "EXTERNAL_CALL":
      return InteractionEnum_ENUM.EXTERNAL_CALL;
    case 5:
    case "EXTENSION":
      return InteractionEnum_ENUM.EXTENSION;
    case 6:
    case "NOTE":
      return InteractionEnum_ENUM.NOTE;
    case 7:
    case "MODAL_EXTENSION":
      return InteractionEnum_ENUM.MODAL_EXTENSION;
    case 8:
    case "COMPONENT_MODAL":
      return InteractionEnum_ENUM.COMPONENT_MODAL;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum InteractionEnum_ENUM",
      );
  }
}

export function interactionEnum_ENUMToJSON(object: InteractionEnum_ENUM): string {
  switch (object) {
    case InteractionEnum_ENUM.NONE:
      return "NONE";
    case InteractionEnum_ENUM.EMBEDDED_WEBSITE:
      return "EMBEDDED_WEBSITE";
    case InteractionEnum_ENUM.POSTER:
      return "POSTER";
    case InteractionEnum_ENUM.VIDEO:
      return "VIDEO";
    case InteractionEnum_ENUM.EXTERNAL_CALL:
      return "EXTERNAL_CALL";
    case InteractionEnum_ENUM.EXTENSION:
      return "EXTENSION";
    case InteractionEnum_ENUM.NOTE:
      return "NOTE";
    case InteractionEnum_ENUM.MODAL_EXTENSION:
      return "MODAL_EXTENSION";
    case InteractionEnum_ENUM.COMPONENT_MODAL:
      return "COMPONENT_MODAL";
    default:
      return "UNKNOWN";
  }
}

export interface SpaceUserInfo {
  name?: string | undefined;
  avatar?: number | undefined;
  x?: number | undefined;
  y?: number | undefined;
  map?: string | undefined;
  affiliation?: string | undefined;
  busy?: boolean | undefined;
  textStatus?: string | undefined;
  emojiStatus?: string | undefined;
  currentlyEquippedWearables?: DBOutfit | undefined;
}

export interface DBOutfit {
  skin: string;
  hair: string;
  facial_hair: string;
  top: string;
  bottom: string;
  shoes: string;
  hat: string;
  glasses: string;
  other: string;
}

export interface WireObject {
  templateId?: string | undefined;
  _name?: string | undefined;
  /** repeated is inherently optional */
  _tags: string[];
  x?: number | undefined;
  y?: number | undefined;
  offsetX?: number | undefined;
  offsetY?: number | undefined;
  color?: string | undefined;
  orientation?: number | undefined;
  normal?: string | undefined;
  highlighted?: string | undefined;
  type?: InteractionEnum_ENUM | undefined;
  width?: number | undefined;
  height?: number | undefined;
  extensionClass?: string | undefined;
  previewMessage?: string | undefined;
  distThreshold?: number | undefined;
  propertiesJson?: string | undefined;
  sound?: Sound | undefined;
  objectStartTime?: ObjectTime | undefined;
  objectExpireTime?: ObjectTime | undefined;
  id?: string | undefined;
  customState?: string | undefined;
}

export interface Sound {
  src: string;
  volume: number;
  loop: boolean;
  maxDistance: number;
}

export interface ObjectTime {
  _seconds: number;
}

export interface Space {
  spaceId: string;
  x: number;
  y: number;
  colored?: boolean | undefined;
}

export interface Point {
  x: number;
  y: number;
}

export interface SpawnPoint {
  x: number;
  y: number;
  spawnId?: string | undefined;
}

export interface Portal {
  x: number;
  y: number;
  targetMap?: string | undefined;
  targetUrl?: string | undefined;
  targetX?: number | undefined;
  targetY?: number | undefined;
}

export interface Announcer {
  x: number;
  y: number;
}

/** deprecating */
export interface Asset {
  x: number;
  y: number;
  src: string;
  width: number;
  height: number;
  inFront?: boolean | undefined;
}

/** deprecating */
export interface AudioEmitter {
  x: number;
  y: number;
  path: string;
  volume: number[];
}

/** deprecating */
export interface Animation {
  x: number;
  y: number;
  framegap: number;
  frames: string[];
}

export interface AreaPosition {
  x1: number;
  y1: number;
  x2: number;
  y2: number;
}

export interface Area {
  categories: string;
  coords: AreaPosition[];
}

export interface MapSetDimensions {
  mapId: string;
  width: number;
  height: number;
}

export interface MapSetCollisions {
  mapId: string;
  x: number;
  y: number;
  w: number;
  h: number;
  /** base64 encoded string */
  mask: string;
}

export interface MapSetBackgroundImagePath {
  mapId: string;
  /** url */
  backgroundImagePath: string;
}

export interface MapSetForegroundImagePath {
  mapId: string;
  foregroundImagePath: string;
  delete?: boolean | undefined;
}

export interface MapSetSprites {
  mapId: string;
  sprites: number[];
  delete?: boolean | undefined;
}

export interface MapSetSpaces {
  mapId: string;
  spaces: Space[];
}

export interface MapSetSpawn {
  mapId: string;
  spawn: Point | undefined;
  delete?: boolean | undefined;
}

export interface MapSetSpawns {
  mapId: string;
  spawns: SpawnPoint[];
}

export interface MapSetPortals {
  mapId: string;
  portals: Portal[];
}

export interface MapSetAnnouncer {
  mapId: string;
  announcer: Announcer[];
}

/** deprecating */
export interface MapSetAudio {
  mapId: string;
  audio: AudioEmitter[];
  delete?: boolean | undefined;
}

/** deprecating */
export interface MapSetAnimations {
  mapId: string;
  animations: Animation[];
  delete?: boolean | undefined;
}

/** deprecating */
export interface MapSetAssets {
  mapId: string;
  assets: Asset[];
  delete?: boolean | undefined;
}

export interface MapSetObjects {
  mapId: string;
  objects: { [key: number]: WireObject };
}

export interface MapSetObjects_ObjectsEntry {
  key: number;
  value: WireObject | undefined;
}

export interface MapSetName {
  mapId: string;
  name: string;
  delete?: boolean | undefined;
}

export interface MapSetDefaultChat {
  mapId: string;
  defaultChat: string;
  delete?: boolean | undefined;
}

export interface MapSetMuteOnEntry {
  mapId: string;
  muteOnEntry: boolean;
  delete?: boolean | undefined;
}

export interface MapSetUseDrawnBG {
  mapId: string;
  useDrawnBG: boolean;
  delete?: boolean | undefined;
}

export interface MapSetWalls {
  mapId: string;
  walls: { [key: string]: string };
  delete?: boolean | undefined;
}

export interface MapSetWalls_WallsEntry {
  key: string;
  value: string;
}

export interface MapSetFloors {
  mapId: string;
  floors: { [key: string]: string };
  delete?: boolean | undefined;
}

export interface MapSetFloors_FloorsEntry {
  key: string;
  value: string;
}

export interface MapSetAreas {
  mapId: string;
  areas: { [key: string]: Area };
  delete?: boolean | undefined;
}

export interface MapSetAreas_AreasEntry {
  key: string;
  value: Area | undefined;
}

export interface MapDeleteObject {
  mapId: string;
  key: number;
}

export interface ServerClientBatch {
  /** don't add more stuff here */
  events: ServerClientEvent[];
}

export interface ServerClientEvent {
  event?:
    | { $case: "info"; info: Info }
    | { $case: "warn"; warn: Warn }
    | { $case: "error"; error: Error }
    | { $case: "ready"; ready: Ready }
    | { $case: "serverHeartbeat"; serverHeartbeat: ServerHeartbeat }
    | { $case: "disableVideo"; disableVideo: DisableVideo }
    | { $case: "playerMoves"; playerMoves: PlayerMoves }
    | { $case: "playerSetsStatus"; playerSetsStatus: PlayerSetsStatus }
    | { $case: "playerSpotlights"; playerSpotlights: PlayerSpotlights }
    | { $case: "playerRings"; playerRings: PlayerRings }
    | { $case: "playerSetsPointer"; playerSetsPointer: PlayerSetsPointer }
    | { $case: "playerChats"; playerChats: PlayerChats }
    | { $case: "playerInteracts"; playerInteracts: PlayerInteracts }
    | { $case: "playerGhosts"; playerGhosts: PlayerGhosts }
    | { $case: "playerEntersWhisper"; playerEntersWhisper: PlayerEntersWhisper }
    | { $case: "playerLeavesWhisper"; playerLeavesWhisper: PlayerLeavesWhisper }
    | { $case: "playerActivelySpeaks"; playerActivelySpeaks: PlayerActivelySpeaks }
    | { $case: "playerSetsEmote"; playerSetsEmote: PlayerSetsEmote }
    | { $case: "playerSetsWorkCondition"; playerSetsWorkCondition: PlayerSetsWorkCondition }
    | { $case: "playerSetsName"; playerSetsName: PlayerSetsName }
    | { $case: "playerSetsTextStatus"; playerSetsTextStatus: PlayerSetsTextStatus }
    | { $case: "playerSetsEmojiStatus"; playerSetsEmojiStatus: PlayerSetsEmojiStatus }
    | { $case: "playerSetsAffiliation"; playerSetsAffiliation: PlayerSetsAffiliation }
    | { $case: "playerExits"; playerExits: PlayerExits }
    | { $case: "playerSetsSprite"; playerSetsSprite: PlayerSetsSprite }
    | { $case: "respawnComplete"; respawnComplete: RespawnComplete }
    | { $case: "playerSetsOutfitString"; playerSetsOutfitString: PlayerSetsOutfitString }
    | { $case: "playerSetsIsSignedIn"; playerSetsIsSignedIn: PlayerSetsIsSignedIn }
    | { $case: "mapUpdates"; mapUpdates: MapUpdates }
    | { $case: "mapOverwrites"; mapOverwrites: MapOverwrites }
    | { $case: "spaceOverwrites"; spaceOverwrites: SpaceOverwrites }
    | { $case: "spaceIsClosed"; spaceIsClosed: SpaceIsClosed }
    | { $case: "playerEntersPortal"; playerEntersPortal: PlayerEntersPortal }
    | { $case: "spaceSetsIdMapping"; spaceSetsIdMapping: SpaceSetsIdMapping }
    | { $case: "playerSetsLastActive"; playerSetsLastActive: PlayerSetsLastActive }
    | { $case: "playerShootsConfetti"; playerShootsConfetti: PlayerShootsConfetti }
    | { $case: "playerSetsEventStatus"; playerSetsEventStatus: PlayerSetsEventStatus }
    | { $case: "playerSetsInConversation"; playerSetsInConversation: PlayerSetsInConversation }
    | { $case: "playerSetsCurrentDesk"; playerSetsCurrentDesk: PlayerSetsCurrentDesk }
    | { $case: "playerSetsCurrentArea"; playerSetsCurrentArea: PlayerSetsCurrentArea }
    | { $case: "playerSetsImagePointer"; playerSetsImagePointer: PlayerSetsImagePointer }
    | { $case: "cookieFound"; cookieFound: CookieFound }
    | { $case: "playerEntersWhisperV2"; playerEntersWhisperV2: PlayerEntersWhisperV2 }
    | { $case: "playerSetsGoKartId"; playerSetsGoKartId: PlayerSetsGoKartId }
    | { $case: "mapSetDimensions"; mapSetDimensions: MapSetDimensions }
    | { $case: "mapSetCollisions"; mapSetCollisions: MapSetCollisions }
    | { $case: "mapSetBackgroundImagePath"; mapSetBackgroundImagePath: MapSetBackgroundImagePath }
    | { $case: "mapSetForegroundImagePath"; mapSetForegroundImagePath: MapSetForegroundImagePath }
    | { $case: "mapSetSprites"; mapSetSprites: MapSetSprites }
    | { $case: "mapSetSpaces"; mapSetSpaces: MapSetSpaces }
    | { $case: "mapSetSpawns"; mapSetSpawns: MapSetSpawns }
    | { $case: "mapSetPortals"; mapSetPortals: MapSetPortals }
    | { $case: "mapSetAnnouncer"; mapSetAnnouncer: MapSetAnnouncer }
    | { $case: "mapSetAudio"; mapSetAudio: MapSetAudio }
    | { $case: "mapSetAnimations"; mapSetAnimations: MapSetAnimations }
    | { $case: "mapSetAssets"; mapSetAssets: MapSetAssets }
    | { $case: "mapSetObjects"; mapSetObjects: MapSetObjects }
    | { $case: "mapSetName"; mapSetName: MapSetName }
    | { $case: "mapSetDefaultChat"; mapSetDefaultChat: MapSetDefaultChat }
    | { $case: "mapSetMuteOnEntry"; mapSetMuteOnEntry: MapSetMuteOnEntry }
    | { $case: "mapSetUseDrawnBG"; mapSetUseDrawnBG: MapSetUseDrawnBG }
    | { $case: "mapSetWalls"; mapSetWalls: MapSetWalls }
    | { $case: "mapSetFloors"; mapSetFloors: MapSetFloors }
    | { $case: "mapSetAreas"; mapSetAreas: MapSetAreas }
    | { $case: "mapDeleteObject"; mapDeleteObject: MapDeleteObject }
    | { $case: "mapSetSpawn"; mapSetSpawn: MapSetSpawn };
}

export interface ServerHeartbeat {
  lastRTT: number;
}

export interface Info {
  message: string;
}

export interface Warn {
  message: string;
}

export interface Error {
  message: string;
  code: number;
}

export interface Ready {
  id: string;
}

export interface DisableVideo {}

/**
 * IMPORTANT:
 * If an event begins with player... and includes the field encId, then all subsequent fields will
 * be automatically applied to the local player state in gather-game-client, unless you add a special case; see the switch statement there.
 * If you need to affect a second player- e.g for whisper, use encIdTarget, and changes will also be applied to the second player.
 *
 * If you follow the patterns described below, this will mostly work seamlessly, but there is an implied assertion that you will
 * follow the pattern.
 */
export interface PlayerMoves {
  encId: number;
  /** all optional, only send what's changed */
  x?: number | undefined;
  y?: number | undefined;
  direction?: SpriteDirectionEnum_ENUM | undefined;
  mapId?: string | undefined;
  lastInputId: number;
}

export interface PlayerSetsStatus {
  encId: number;
  busy: boolean;
}

export interface PlayerSpotlights {
  /** the person who is being spotlit */
  encId: number;
  /** the person who is doing the spotlighting; legacy \holdover */
  spotlightedBy: number;
  spotlighted: number;
}

export interface PlayerRings {
  /** the ringer */
  encId: number;
}

/** DEPRECATED */
export interface PlayerSetsPointer {
  encId: number;
  objectId: string;
  x: number;
  y: number;
}

export interface PlayerSetsImagePointer {
  encId: number;
  objectId: string;
  x: number;
  y: number;
}

export interface PlayerChats {
  senderId: string;
  recipient: string;
  contents: string;
  senderName: string;
  /** deprecating */
  timestamp?: Timestamp | undefined;
  messageType: string;
  unixTime: number;
}

/** deprecating this */
export interface Timestamp {
  seconds: number;
  nanoseconds: number;
}

export interface PlayerInteracts {
  encId: number;
  objId: string;
  /** JSON string */
  dataJson?: string | undefined;
}

export interface PlayerGhosts {
  encId: number;
  ghost: number;
}

export interface PlayerEntersWhisper {
  encId: number;
  whisperRecipient: string;
  whisperId: string;
}

export interface PlayerEntersWhisperV2 {
  encId: number;
  /** the person you intend to be whispering; will apply whisperId property to them as well */
  encIdTarget: number;
  whisperId: string;
}

export interface PlayerLeavesWhisper {
  encId: number;
}

export interface PlayerActivelySpeaks {
  encId: number;
  activelySpeaking: number;
}

export interface PlayerSetsEmote {
  encId: number;
  emote: EmoteEnum_ENUM;
}

export interface PlayerSetsWorkCondition {
  encId: number;
  workCondition: number;
}

export interface PlayerSetsLastActive {
  encId: number;
  lastActive: string;
}

export interface PlayerSetsName {
  encId: number;
  name: string;
}

export interface PlayerSetsTextStatus {
  encId: number;
  textStatus: string;
}

export interface PlayerSetsEmojiStatus {
  encId: number;
  emojiStatus: string;
}

export interface PlayerSetsAffiliation {
  encId: number;
  affiliation: string;
}

export interface PlayerExits {
  encId: number;
}

export interface PlayerSetsSprite {
  encId: number;
  sprite: number;
}

export interface PlayerSetsOutfitString {
  encId: number;
  outfitString: string;
}

export interface PlayerSetsIsSignedIn {
  encId: number;
  isSignedIn: boolean;
}

export interface RespawnComplete {}

export interface MapUpdates {
  mapId: string;
  diffJson: string;
}

export interface MapOverwrites {
  mapId: string;
  mapJson: string;
}

/**
 * It's pretty wack that we're using JSON to serialize / deserialize space data here.
 * TODO: improve this by splitting this up into several events or using a better message interface
 * for this or something that doesn't require the client to JSON.parse().
 */
export interface SpaceOverwrites {
  spaceData: string;
}

export interface SpaceIsClosed {}

export interface PlayerEntersPortal {
  targetUrl: string;
}

export interface CookieFound {
  encId: number;
}

/**
 * Each client has a unique string id, but this is costly to send over the wire
 * so an integer value is used in its place and then converted back to the
 * corresponding string id on the client and server.
 * This event provides the mapping between a player's string id [uid]
 * and their corresponding integer id [encId].
 * (see "Player..." events above for use of encId)
 */
export interface SpaceSetsIdMapping {
  uid: string;
  encId: number;
}

export interface PlayerShootsConfetti {
  /** the confetti shooter */
  encId: number;
}

export interface PlayerSetsEventStatus {
  encId: number;
  eventStatus: string;
}

export interface PlayerSetsInConversation {
  encId: number;
  inConversation: boolean;
}

export interface PlayerSetsCurrentDesk {
  encId: number;
  currentDesk: string;
}

export interface PlayerSetsCurrentArea {
  encId: number;
  currentArea: string;
}

export interface PlayerSetsGoKartId {
  encId: number;
  goKartId: string;
}

export interface ClientServerBatch {
  /** don't add more stuff here */
  actions: ClientServerAction[];
}

export interface ClientServerAction {
  action?:
    | { $case: "clientHeartbeat"; clientHeartbeat: ClientHeartbeat }
    | { $case: "updateSubscriptions"; updateSubscriptions: UpdateSubscriptions }
    | { $case: "move"; move: Move }
    | { $case: "setSprite"; setSprite: SetSprite }
    | { $case: "setAffiliation"; setAffiliation: SetAffiliation }
    | { $case: "setStatus"; setStatus: SetStatus }
    | { $case: "spotlight"; spotlight: Spotlight }
    | { $case: "ring"; ring: Ring }
    | { $case: "setPointer"; setPointer: SetPointer }
    | { $case: "ban"; ban: Ban }
    | { $case: "kick"; kick: Kick }
    | { $case: "setImpassable"; setImpassable: SetImpassable }
    | { $case: "chat"; chat: Chat }
    | { $case: "setObject"; setObject: SetObject }
    | { $case: "deleteObject"; deleteObject: DeleteObject }
    | { $case: "interact"; interact: Interact }
    | { $case: "enterWhisper"; enterWhisper: EnterWhisper }
    | { $case: "leaveWhisper"; leaveWhisper: LeaveWhisper }
    | { $case: "setEmojiStatus"; setEmojiStatus: SetEmojiStatus }
    | { $case: "activelySpeaking"; activelySpeaking: ActivelySpeaking }
    | { $case: "setEmote"; setEmote: SetEmote }
    | { $case: "setName"; setName: SetName }
    | { $case: "setTextStatus"; setTextStatus: SetTextStatus }
    | { $case: "teleport"; teleport: Teleport }
    | { $case: "exit"; exit: Exit }
    | { $case: "enter"; enter: Enter }
    | { $case: "setWorkCondition"; setWorkCondition: SetWorkCondition }
    | { $case: "respawn"; respawn: Respawn }
    | { $case: "spawn"; spawn: Spawn }
    | { $case: "ghost"; ghost: Ghost }
    | { $case: "init"; init: Init }
    | { $case: "setOutfitString"; setOutfitString: SetOutfitString }
    | { $case: "mapUpdate"; mapUpdate: MapUpdate }
    | { $case: "shootConfetti"; shootConfetti: ShootConfetti }
    | { $case: "setEventStatus"; setEventStatus: SetEventStatus }
    | { $case: "setInConversation"; setInConversation: SetInConversation }
    | { $case: "setCurrentDesk"; setCurrentDesk: SetCurrentDesk }
    | { $case: "setCurrentArea"; setCurrentArea: SetCurrentArea }
    | { $case: "setImagePointer"; setImagePointer: SetImagePointer }
    | { $case: "setGoKartId"; setGoKartId: SetGoKartId }
    | { $case: "mapSetDimensions"; mapSetDimensions: MapSetDimensions }
    | { $case: "mapSetCollisions"; mapSetCollisions: MapSetCollisions }
    | { $case: "mapSetBackgroundImagePath"; mapSetBackgroundImagePath: MapSetBackgroundImagePath }
    | { $case: "mapSetForegroundImagePath"; mapSetForegroundImagePath: MapSetForegroundImagePath }
    | { $case: "mapSetSprites"; mapSetSprites: MapSetSprites }
    | { $case: "mapSetSpawns"; mapSetSpawns: MapSetSpawns }
    | { $case: "mapSetSpaces"; mapSetSpaces: MapSetSpaces }
    | { $case: "mapSetPortals"; mapSetPortals: MapSetPortals }
    | { $case: "mapSetAnnouncer"; mapSetAnnouncer: MapSetAnnouncer }
    | { $case: "mapSetAudio"; mapSetAudio: MapSetAudio }
    | { $case: "mapSetAnimations"; mapSetAnimations: MapSetAnimations }
    | { $case: "mapSetAssets"; mapSetAssets: MapSetAssets }
    | { $case: "mapSetObjects"; mapSetObjects: MapSetObjects }
    | { $case: "mapSetName"; mapSetName: MapSetName }
    | { $case: "mapSetDefaultChat"; mapSetDefaultChat: MapSetDefaultChat }
    | { $case: "mapSetMuteOnEntry"; mapSetMuteOnEntry: MapSetMuteOnEntry }
    | { $case: "mapSetUseDrawnBG"; mapSetUseDrawnBG: MapSetUseDrawnBG }
    | { $case: "mapSetWalls"; mapSetWalls: MapSetWalls }
    | { $case: "mapSetFloors"; mapSetFloors: MapSetFloors }
    | { $case: "mapSetAreas"; mapSetAreas: MapSetAreas }
    | { $case: "mapAddObject"; mapAddObject: MapAddObject }
    | { $case: "mapDeleteObject"; mapDeleteObject: MapDeleteObject }
    | { $case: "mapSetSpawn"; mapSetSpawn: MapSetSpawn };
}

export interface ClientHeartbeat {}

export interface UpdateSubscriptions {
  subscriptions: { [key: string]: boolean };
}

export interface UpdateSubscriptions_SubscriptionsEntry {
  key: string;
  value: boolean;
}

export interface Move {
  dir: MoveDirectionEnum_ENUM;
  stopped: boolean;
  inputId: number;
  targetId?: string | undefined;
}

export interface SetSprite {
  sprite: number;
  targetId?: string | undefined;
}

export interface SetAffiliation {
  affiliation: string;
}

export interface SetStatus {
  status: boolean;
  targetId?: string | undefined;
}

export interface SetOutfitString {
  outfitString: string;
  targetId?: string | undefined;
}

export interface Spotlight {
  spotlightedUser: string;
  isSpotlighted: boolean;
}

export interface Ring {
  user: string;
}

export interface SetPointer {
  objectId: string;
  x: number;
  y: number;
}

export interface SetImagePointer {
  objectId: string;
  x: number;
  y: number;
}

export interface Ban {
  user: string;
}

export interface Kick {
  user: string;
}

export interface SetImpassable {
  mapId: string;
  x: number;
  y: number;
  impassable: boolean;
}

export interface Chat {
  chatRecipient: string;
  contents: string;
  localPlayerIds: string[];
  mapId: string;
}

export interface SetObject {
  mapId: string;
  objectId: string;
}

export interface DeleteObject {
  mapId: string;
  objectId: string;
}

export interface Interact {
  objId: string;
  /** JSON string */
  dataJson?: string | undefined;
}

export interface ActivelySpeaking {
  activelySpeaking: boolean;
}

export interface EnterWhisper {
  recipientId: string;
  dir: MoveDirectionEnum_ENUM;
}

export interface LeaveWhisper {}

export interface Ghost {
  ghost: number;
  /** why is this a uint32? it is in the original impl so.. it stays */
  targetId?: string | undefined;
}

export interface SetEmote {
  emote: EmoteEnum_ENUM;
  targetId?: string | undefined;
}

export interface SetName {
  name: string;
  targetId?: string | undefined;
}

export interface SetTextStatus {
  textStatus: string;
  targetId?: string | undefined;
}

export interface Exit {}

export interface Enter {
  info?: SpaceUserInfo | undefined;
  spawnToken?: string | undefined;
}

export interface SetEmojiStatus {
  emojiStatus: string;
  targetId?: string | undefined;
}

export interface Teleport {
  mapId: string;
  x: number;
  y: number;
  targetId?: string | undefined;
}

export interface SetWorkCondition {
  workCondition: boolean;
}

export interface Spawn {
  spawnToken: string;
}

export interface Respawn {
  spaceUserInfo?: SpaceUserInfo | undefined;
  spawnToken?: string | undefined;
}

export interface Init {
  spaceId: string;
  auth?: { $case: "token"; token: string } | { $case: "apiKey"; apiKey: string };
}

export interface MapUpdate {
  mapId: string;
  diffJson: string;
}

export interface MapAddObject {
  mapId: string;
  object: WireObject | undefined;
}

export interface ShootConfetti {}

export interface SetEventStatus {
  eventStatus: string;
}

export interface SetInConversation {
  inConversation: boolean;
}

export interface SetCurrentDesk {
  currentDesk: string;
}

export interface SetCurrentArea {
  currentArea: string;
}

export interface SetGoKartId {
  goKartId: string;
}

const baseSpriteDirectionEnum: object = {};

export const SpriteDirectionEnum = {
  encode(_: SpriteDirectionEnum, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpriteDirectionEnum {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSpriteDirectionEnum } as SpriteDirectionEnum;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): SpriteDirectionEnum {
    const message = { ...baseSpriteDirectionEnum } as SpriteDirectionEnum;
    return message;
  },

  toJSON(_: SpriteDirectionEnum): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial(_: DeepPartial<SpriteDirectionEnum>): SpriteDirectionEnum {
    const message = { ...baseSpriteDirectionEnum } as SpriteDirectionEnum;
    return message;
  },
};

const baseMoveDirectionEnum: object = {};

export const MoveDirectionEnum = {
  encode(_: MoveDirectionEnum, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MoveDirectionEnum {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMoveDirectionEnum } as MoveDirectionEnum;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MoveDirectionEnum {
    const message = { ...baseMoveDirectionEnum } as MoveDirectionEnum;
    return message;
  },

  toJSON(_: MoveDirectionEnum): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial(_: DeepPartial<MoveDirectionEnum>): MoveDirectionEnum {
    const message = { ...baseMoveDirectionEnum } as MoveDirectionEnum;
    return message;
  },
};

const baseEmoteEnum: object = {};

export const EmoteEnum = {
  encode(_: EmoteEnum, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EmoteEnum {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseEmoteEnum } as EmoteEnum;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): EmoteEnum {
    const message = { ...baseEmoteEnum } as EmoteEnum;
    return message;
  },

  toJSON(_: EmoteEnum): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial(_: DeepPartial<EmoteEnum>): EmoteEnum {
    const message = { ...baseEmoteEnum } as EmoteEnum;
    return message;
  },
};

const baseInteractionEnum: object = {};

export const InteractionEnum = {
  encode(_: InteractionEnum, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InteractionEnum {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseInteractionEnum } as InteractionEnum;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): InteractionEnum {
    const message = { ...baseInteractionEnum } as InteractionEnum;
    return message;
  },

  toJSON(_: InteractionEnum): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial(_: DeepPartial<InteractionEnum>): InteractionEnum {
    const message = { ...baseInteractionEnum } as InteractionEnum;
    return message;
  },
};

const baseSpaceUserInfo: object = {};

export const SpaceUserInfo = {
  encode(message: SpaceUserInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.avatar !== undefined) {
      writer.uint32(16).uint32(message.avatar);
    }
    if (message.x !== undefined) {
      writer.uint32(24).uint32(message.x);
    }
    if (message.y !== undefined) {
      writer.uint32(32).uint32(message.y);
    }
    if (message.map !== undefined) {
      writer.uint32(42).string(message.map);
    }
    if (message.affiliation !== undefined) {
      writer.uint32(50).string(message.affiliation);
    }
    if (message.busy !== undefined) {
      writer.uint32(56).bool(message.busy);
    }
    if (message.textStatus !== undefined) {
      writer.uint32(66).string(message.textStatus);
    }
    if (message.emojiStatus !== undefined) {
      writer.uint32(74).string(message.emojiStatus);
    }
    if (message.currentlyEquippedWearables !== undefined) {
      DBOutfit.encode(message.currentlyEquippedWearables, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpaceUserInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSpaceUserInfo } as SpaceUserInfo;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.avatar = reader.uint32();
          break;
        case 3:
          message.x = reader.uint32();
          break;
        case 4:
          message.y = reader.uint32();
          break;
        case 5:
          message.map = reader.string();
          break;
        case 6:
          message.affiliation = reader.string();
          break;
        case 7:
          message.busy = reader.bool();
          break;
        case 8:
          message.textStatus = reader.string();
          break;
        case 9:
          message.emojiStatus = reader.string();
          break;
        case 10:
          message.currentlyEquippedWearables = DBOutfit.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpaceUserInfo {
    const message = { ...baseSpaceUserInfo } as SpaceUserInfo;
    if (object.name !== undefined && object.name !== null) {
      message.name = String(object.name);
    }
    if (object.avatar !== undefined && object.avatar !== null) {
      message.avatar = Number(object.avatar);
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    if (object.map !== undefined && object.map !== null) {
      message.map = String(object.map);
    }
    if (object.affiliation !== undefined && object.affiliation !== null) {
      message.affiliation = String(object.affiliation);
    }
    if (object.busy !== undefined && object.busy !== null) {
      message.busy = Boolean(object.busy);
    }
    if (object.textStatus !== undefined && object.textStatus !== null) {
      message.textStatus = String(object.textStatus);
    }
    if (object.emojiStatus !== undefined && object.emojiStatus !== null) {
      message.emojiStatus = String(object.emojiStatus);
    }
    if (
      object.currentlyEquippedWearables !== undefined &&
      object.currentlyEquippedWearables !== null
    ) {
      message.currentlyEquippedWearables = DBOutfit.fromJSON(object.currentlyEquippedWearables);
    }
    return message;
  },

  toJSON(message: SpaceUserInfo): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.avatar !== undefined && (obj.avatar = message.avatar);
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.map !== undefined && (obj.map = message.map);
    message.affiliation !== undefined && (obj.affiliation = message.affiliation);
    message.busy !== undefined && (obj.busy = message.busy);
    message.textStatus !== undefined && (obj.textStatus = message.textStatus);
    message.emojiStatus !== undefined && (obj.emojiStatus = message.emojiStatus);
    message.currentlyEquippedWearables !== undefined &&
      (obj.currentlyEquippedWearables = message.currentlyEquippedWearables
        ? DBOutfit.toJSON(message.currentlyEquippedWearables)
        : undefined);
    return obj;
  },

  fromPartial(object: DeepPartial<SpaceUserInfo>): SpaceUserInfo {
    const message = { ...baseSpaceUserInfo } as SpaceUserInfo;
    if (object.name !== undefined && object.name !== null) {
      message.name = object.name;
    }
    if (object.avatar !== undefined && object.avatar !== null) {
      message.avatar = object.avatar;
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    if (object.map !== undefined && object.map !== null) {
      message.map = object.map;
    }
    if (object.affiliation !== undefined && object.affiliation !== null) {
      message.affiliation = object.affiliation;
    }
    if (object.busy !== undefined && object.busy !== null) {
      message.busy = object.busy;
    }
    if (object.textStatus !== undefined && object.textStatus !== null) {
      message.textStatus = object.textStatus;
    }
    if (object.emojiStatus !== undefined && object.emojiStatus !== null) {
      message.emojiStatus = object.emojiStatus;
    }
    if (
      object.currentlyEquippedWearables !== undefined &&
      object.currentlyEquippedWearables !== null
    ) {
      message.currentlyEquippedWearables = DBOutfit.fromPartial(object.currentlyEquippedWearables);
    }
    return message;
  },
};

const baseDBOutfit: object = {
  skin: "",
  hair: "",
  facial_hair: "",
  top: "",
  bottom: "",
  shoes: "",
  hat: "",
  glasses: "",
  other: "",
};

export const DBOutfit = {
  encode(message: DBOutfit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skin !== "") {
      writer.uint32(10).string(message.skin);
    }
    if (message.hair !== "") {
      writer.uint32(18).string(message.hair);
    }
    if (message.facial_hair !== "") {
      writer.uint32(26).string(message.facial_hair);
    }
    if (message.top !== "") {
      writer.uint32(34).string(message.top);
    }
    if (message.bottom !== "") {
      writer.uint32(42).string(message.bottom);
    }
    if (message.shoes !== "") {
      writer.uint32(50).string(message.shoes);
    }
    if (message.hat !== "") {
      writer.uint32(58).string(message.hat);
    }
    if (message.glasses !== "") {
      writer.uint32(66).string(message.glasses);
    }
    if (message.other !== "") {
      writer.uint32(74).string(message.other);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DBOutfit {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseDBOutfit } as DBOutfit;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.skin = reader.string();
          break;
        case 2:
          message.hair = reader.string();
          break;
        case 3:
          message.facial_hair = reader.string();
          break;
        case 4:
          message.top = reader.string();
          break;
        case 5:
          message.bottom = reader.string();
          break;
        case 6:
          message.shoes = reader.string();
          break;
        case 7:
          message.hat = reader.string();
          break;
        case 8:
          message.glasses = reader.string();
          break;
        case 9:
          message.other = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DBOutfit {
    const message = { ...baseDBOutfit } as DBOutfit;
    if (object.skin !== undefined && object.skin !== null) {
      message.skin = String(object.skin);
    }
    if (object.hair !== undefined && object.hair !== null) {
      message.hair = String(object.hair);
    }
    if (object.facial_hair !== undefined && object.facial_hair !== null) {
      message.facial_hair = String(object.facial_hair);
    }
    if (object.top !== undefined && object.top !== null) {
      message.top = String(object.top);
    }
    if (object.bottom !== undefined && object.bottom !== null) {
      message.bottom = String(object.bottom);
    }
    if (object.shoes !== undefined && object.shoes !== null) {
      message.shoes = String(object.shoes);
    }
    if (object.hat !== undefined && object.hat !== null) {
      message.hat = String(object.hat);
    }
    if (object.glasses !== undefined && object.glasses !== null) {
      message.glasses = String(object.glasses);
    }
    if (object.other !== undefined && object.other !== null) {
      message.other = String(object.other);
    }
    return message;
  },

  toJSON(message: DBOutfit): unknown {
    const obj: any = {};
    message.skin !== undefined && (obj.skin = message.skin);
    message.hair !== undefined && (obj.hair = message.hair);
    message.facial_hair !== undefined && (obj.facial_hair = message.facial_hair);
    message.top !== undefined && (obj.top = message.top);
    message.bottom !== undefined && (obj.bottom = message.bottom);
    message.shoes !== undefined && (obj.shoes = message.shoes);
    message.hat !== undefined && (obj.hat = message.hat);
    message.glasses !== undefined && (obj.glasses = message.glasses);
    message.other !== undefined && (obj.other = message.other);
    return obj;
  },

  fromPartial(object: DeepPartial<DBOutfit>): DBOutfit {
    const message = { ...baseDBOutfit } as DBOutfit;
    if (object.skin !== undefined && object.skin !== null) {
      message.skin = object.skin;
    }
    if (object.hair !== undefined && object.hair !== null) {
      message.hair = object.hair;
    }
    if (object.facial_hair !== undefined && object.facial_hair !== null) {
      message.facial_hair = object.facial_hair;
    }
    if (object.top !== undefined && object.top !== null) {
      message.top = object.top;
    }
    if (object.bottom !== undefined && object.bottom !== null) {
      message.bottom = object.bottom;
    }
    if (object.shoes !== undefined && object.shoes !== null) {
      message.shoes = object.shoes;
    }
    if (object.hat !== undefined && object.hat !== null) {
      message.hat = object.hat;
    }
    if (object.glasses !== undefined && object.glasses !== null) {
      message.glasses = object.glasses;
    }
    if (object.other !== undefined && object.other !== null) {
      message.other = object.other;
    }
    return message;
  },
};

const baseWireObject: object = { _tags: "" };

export const WireObject = {
  encode(message: WireObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.templateId !== undefined) {
      writer.uint32(10).string(message.templateId);
    }
    if (message._name !== undefined) {
      writer.uint32(18).string(message._name);
    }
    for (const v of message._tags) {
      writer.uint32(26).string(v!);
    }
    if (message.x !== undefined) {
      writer.uint32(32).uint32(message.x);
    }
    if (message.y !== undefined) {
      writer.uint32(40).uint32(message.y);
    }
    if (message.offsetX !== undefined) {
      writer.uint32(48).uint32(message.offsetX);
    }
    if (message.offsetY !== undefined) {
      writer.uint32(56).uint32(message.offsetY);
    }
    if (message.color !== undefined) {
      writer.uint32(66).string(message.color);
    }
    if (message.orientation !== undefined) {
      writer.uint32(72).uint32(message.orientation);
    }
    if (message.normal !== undefined) {
      writer.uint32(82).string(message.normal);
    }
    if (message.highlighted !== undefined) {
      writer.uint32(90).string(message.highlighted);
    }
    if (message.type !== undefined) {
      writer.uint32(96).int32(message.type);
    }
    if (message.width !== undefined) {
      writer.uint32(104).uint32(message.width);
    }
    if (message.height !== undefined) {
      writer.uint32(112).uint32(message.height);
    }
    if (message.extensionClass !== undefined) {
      writer.uint32(122).string(message.extensionClass);
    }
    if (message.previewMessage !== undefined) {
      writer.uint32(130).string(message.previewMessage);
    }
    if (message.distThreshold !== undefined) {
      writer.uint32(136).uint32(message.distThreshold);
    }
    if (message.propertiesJson !== undefined) {
      writer.uint32(146).string(message.propertiesJson);
    }
    if (message.sound !== undefined) {
      Sound.encode(message.sound, writer.uint32(154).fork()).ldelim();
    }
    if (message.objectStartTime !== undefined) {
      ObjectTime.encode(message.objectStartTime, writer.uint32(162).fork()).ldelim();
    }
    if (message.objectExpireTime !== undefined) {
      ObjectTime.encode(message.objectExpireTime, writer.uint32(170).fork()).ldelim();
    }
    if (message.id !== undefined) {
      writer.uint32(178).string(message.id);
    }
    if (message.customState !== undefined) {
      writer.uint32(186).string(message.customState);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WireObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseWireObject } as WireObject;
    message._tags = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.templateId = reader.string();
          break;
        case 2:
          message._name = reader.string();
          break;
        case 3:
          message._tags.push(reader.string());
          break;
        case 4:
          message.x = reader.uint32();
          break;
        case 5:
          message.y = reader.uint32();
          break;
        case 6:
          message.offsetX = reader.uint32();
          break;
        case 7:
          message.offsetY = reader.uint32();
          break;
        case 8:
          message.color = reader.string();
          break;
        case 9:
          message.orientation = reader.uint32();
          break;
        case 10:
          message.normal = reader.string();
          break;
        case 11:
          message.highlighted = reader.string();
          break;
        case 12:
          message.type = reader.int32() as any;
          break;
        case 13:
          message.width = reader.uint32();
          break;
        case 14:
          message.height = reader.uint32();
          break;
        case 15:
          message.extensionClass = reader.string();
          break;
        case 16:
          message.previewMessage = reader.string();
          break;
        case 17:
          message.distThreshold = reader.uint32();
          break;
        case 18:
          message.propertiesJson = reader.string();
          break;
        case 19:
          message.sound = Sound.decode(reader, reader.uint32());
          break;
        case 20:
          message.objectStartTime = ObjectTime.decode(reader, reader.uint32());
          break;
        case 21:
          message.objectExpireTime = ObjectTime.decode(reader, reader.uint32());
          break;
        case 22:
          message.id = reader.string();
          break;
        case 23:
          message.customState = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): WireObject {
    const message = { ...baseWireObject } as WireObject;
    message._tags = [];
    if (object.templateId !== undefined && object.templateId !== null) {
      message.templateId = String(object.templateId);
    }
    if (object._name !== undefined && object._name !== null) {
      message._name = String(object._name);
    }
    if (object._tags !== undefined && object._tags !== null) {
      for (const e of object._tags) {
        message._tags.push(String(e));
      }
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    if (object.offsetX !== undefined && object.offsetX !== null) {
      message.offsetX = Number(object.offsetX);
    }
    if (object.offsetY !== undefined && object.offsetY !== null) {
      message.offsetY = Number(object.offsetY);
    }
    if (object.color !== undefined && object.color !== null) {
      message.color = String(object.color);
    }
    if (object.orientation !== undefined && object.orientation !== null) {
      message.orientation = Number(object.orientation);
    }
    if (object.normal !== undefined && object.normal !== null) {
      message.normal = String(object.normal);
    }
    if (object.highlighted !== undefined && object.highlighted !== null) {
      message.highlighted = String(object.highlighted);
    }
    if (object.type !== undefined && object.type !== null) {
      message.type = interactionEnum_ENUMFromJSON(object.type);
    }
    if (object.width !== undefined && object.width !== null) {
      message.width = Number(object.width);
    }
    if (object.height !== undefined && object.height !== null) {
      message.height = Number(object.height);
    }
    if (object.extensionClass !== undefined && object.extensionClass !== null) {
      message.extensionClass = String(object.extensionClass);
    }
    if (object.previewMessage !== undefined && object.previewMessage !== null) {
      message.previewMessage = String(object.previewMessage);
    }
    if (object.distThreshold !== undefined && object.distThreshold !== null) {
      message.distThreshold = Number(object.distThreshold);
    }
    if (object.propertiesJson !== undefined && object.propertiesJson !== null) {
      message.propertiesJson = String(object.propertiesJson);
    }
    if (object.sound !== undefined && object.sound !== null) {
      message.sound = Sound.fromJSON(object.sound);
    }
    if (object.objectStartTime !== undefined && object.objectStartTime !== null) {
      message.objectStartTime = ObjectTime.fromJSON(object.objectStartTime);
    }
    if (object.objectExpireTime !== undefined && object.objectExpireTime !== null) {
      message.objectExpireTime = ObjectTime.fromJSON(object.objectExpireTime);
    }
    if (object.id !== undefined && object.id !== null) {
      message.id = String(object.id);
    }
    if (object.customState !== undefined && object.customState !== null) {
      message.customState = String(object.customState);
    }
    return message;
  },

  toJSON(message: WireObject): unknown {
    const obj: any = {};
    message.templateId !== undefined && (obj.templateId = message.templateId);
    message._name !== undefined && (obj._name = message._name);
    if (message._tags) {
      obj._tags = message._tags.map((e) => e);
    } else {
      obj._tags = [];
    }
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.offsetX !== undefined && (obj.offsetX = message.offsetX);
    message.offsetY !== undefined && (obj.offsetY = message.offsetY);
    message.color !== undefined && (obj.color = message.color);
    message.orientation !== undefined && (obj.orientation = message.orientation);
    message.normal !== undefined && (obj.normal = message.normal);
    message.highlighted !== undefined && (obj.highlighted = message.highlighted);
    message.type !== undefined &&
      (obj.type =
        message.type !== undefined ? interactionEnum_ENUMToJSON(message.type) : undefined);
    message.width !== undefined && (obj.width = message.width);
    message.height !== undefined && (obj.height = message.height);
    message.extensionClass !== undefined && (obj.extensionClass = message.extensionClass);
    message.previewMessage !== undefined && (obj.previewMessage = message.previewMessage);
    message.distThreshold !== undefined && (obj.distThreshold = message.distThreshold);
    message.propertiesJson !== undefined && (obj.propertiesJson = message.propertiesJson);
    message.sound !== undefined &&
      (obj.sound = message.sound ? Sound.toJSON(message.sound) : undefined);
    message.objectStartTime !== undefined &&
      (obj.objectStartTime = message.objectStartTime
        ? ObjectTime.toJSON(message.objectStartTime)
        : undefined);
    message.objectExpireTime !== undefined &&
      (obj.objectExpireTime = message.objectExpireTime
        ? ObjectTime.toJSON(message.objectExpireTime)
        : undefined);
    message.id !== undefined && (obj.id = message.id);
    message.customState !== undefined && (obj.customState = message.customState);
    return obj;
  },

  fromPartial(object: DeepPartial<WireObject>): WireObject {
    const message = { ...baseWireObject } as WireObject;
    message._tags = [];
    if (object.templateId !== undefined && object.templateId !== null) {
      message.templateId = object.templateId;
    }
    if (object._name !== undefined && object._name !== null) {
      message._name = object._name;
    }
    if (object._tags !== undefined && object._tags !== null) {
      for (const e of object._tags) {
        message._tags.push(e);
      }
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    if (object.offsetX !== undefined && object.offsetX !== null) {
      message.offsetX = object.offsetX;
    }
    if (object.offsetY !== undefined && object.offsetY !== null) {
      message.offsetY = object.offsetY;
    }
    if (object.color !== undefined && object.color !== null) {
      message.color = object.color;
    }
    if (object.orientation !== undefined && object.orientation !== null) {
      message.orientation = object.orientation;
    }
    if (object.normal !== undefined && object.normal !== null) {
      message.normal = object.normal;
    }
    if (object.highlighted !== undefined && object.highlighted !== null) {
      message.highlighted = object.highlighted;
    }
    if (object.type !== undefined && object.type !== null) {
      message.type = object.type;
    }
    if (object.width !== undefined && object.width !== null) {
      message.width = object.width;
    }
    if (object.height !== undefined && object.height !== null) {
      message.height = object.height;
    }
    if (object.extensionClass !== undefined && object.extensionClass !== null) {
      message.extensionClass = object.extensionClass;
    }
    if (object.previewMessage !== undefined && object.previewMessage !== null) {
      message.previewMessage = object.previewMessage;
    }
    if (object.distThreshold !== undefined && object.distThreshold !== null) {
      message.distThreshold = object.distThreshold;
    }
    if (object.propertiesJson !== undefined && object.propertiesJson !== null) {
      message.propertiesJson = object.propertiesJson;
    }
    if (object.sound !== undefined && object.sound !== null) {
      message.sound = Sound.fromPartial(object.sound);
    }
    if (object.objectStartTime !== undefined && object.objectStartTime !== null) {
      message.objectStartTime = ObjectTime.fromPartial(object.objectStartTime);
    }
    if (object.objectExpireTime !== undefined && object.objectExpireTime !== null) {
      message.objectExpireTime = ObjectTime.fromPartial(object.objectExpireTime);
    }
    if (object.id !== undefined && object.id !== null) {
      message.id = object.id;
    }
    if (object.customState !== undefined && object.customState !== null) {
      message.customState = object.customState;
    }
    return message;
  },
};

const baseSound: object = { src: "", volume: 0, loop: false, maxDistance: 0 };

export const Sound = {
  encode(message: Sound, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.src !== "") {
      writer.uint32(10).string(message.src);
    }
    if (message.volume !== 0) {
      writer.uint32(21).float(message.volume);
    }
    if (message.loop === true) {
      writer.uint32(24).bool(message.loop);
    }
    if (message.maxDistance !== 0) {
      writer.uint32(32).uint32(message.maxDistance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Sound {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSound } as Sound;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.src = reader.string();
          break;
        case 2:
          message.volume = reader.float();
          break;
        case 3:
          message.loop = reader.bool();
          break;
        case 4:
          message.maxDistance = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Sound {
    const message = { ...baseSound } as Sound;
    if (object.src !== undefined && object.src !== null) {
      message.src = String(object.src);
    }
    if (object.volume !== undefined && object.volume !== null) {
      message.volume = Number(object.volume);
    }
    if (object.loop !== undefined && object.loop !== null) {
      message.loop = Boolean(object.loop);
    }
    if (object.maxDistance !== undefined && object.maxDistance !== null) {
      message.maxDistance = Number(object.maxDistance);
    }
    return message;
  },

  toJSON(message: Sound): unknown {
    const obj: any = {};
    message.src !== undefined && (obj.src = message.src);
    message.volume !== undefined && (obj.volume = message.volume);
    message.loop !== undefined && (obj.loop = message.loop);
    message.maxDistance !== undefined && (obj.maxDistance = message.maxDistance);
    return obj;
  },

  fromPartial(object: DeepPartial<Sound>): Sound {
    const message = { ...baseSound } as Sound;
    if (object.src !== undefined && object.src !== null) {
      message.src = object.src;
    }
    if (object.volume !== undefined && object.volume !== null) {
      message.volume = object.volume;
    }
    if (object.loop !== undefined && object.loop !== null) {
      message.loop = object.loop;
    }
    if (object.maxDistance !== undefined && object.maxDistance !== null) {
      message.maxDistance = object.maxDistance;
    }
    return message;
  },
};

const baseObjectTime: object = { _seconds: 0 };

export const ObjectTime = {
  encode(message: ObjectTime, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message._seconds !== 0) {
      writer.uint32(8).uint32(message._seconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ObjectTime {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseObjectTime } as ObjectTime;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message._seconds = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ObjectTime {
    const message = { ...baseObjectTime } as ObjectTime;
    if (object._seconds !== undefined && object._seconds !== null) {
      message._seconds = Number(object._seconds);
    }
    return message;
  },

  toJSON(message: ObjectTime): unknown {
    const obj: any = {};
    message._seconds !== undefined && (obj._seconds = message._seconds);
    return obj;
  },

  fromPartial(object: DeepPartial<ObjectTime>): ObjectTime {
    const message = { ...baseObjectTime } as ObjectTime;
    if (object._seconds !== undefined && object._seconds !== null) {
      message._seconds = object._seconds;
    }
    return message;
  },
};

const baseSpace: object = { spaceId: "", x: 0, y: 0 };

export const Space = {
  encode(message: Space, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spaceId !== "") {
      writer.uint32(10).string(message.spaceId);
    }
    if (message.x !== 0) {
      writer.uint32(16).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(24).uint32(message.y);
    }
    if (message.colored !== undefined) {
      writer.uint32(32).bool(message.colored);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Space {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSpace } as Space;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.spaceId = reader.string();
          break;
        case 2:
          message.x = reader.uint32();
          break;
        case 3:
          message.y = reader.uint32();
          break;
        case 4:
          message.colored = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Space {
    const message = { ...baseSpace } as Space;
    if (object.spaceId !== undefined && object.spaceId !== null) {
      message.spaceId = String(object.spaceId);
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    if (object.colored !== undefined && object.colored !== null) {
      message.colored = Boolean(object.colored);
    }
    return message;
  },

  toJSON(message: Space): unknown {
    const obj: any = {};
    message.spaceId !== undefined && (obj.spaceId = message.spaceId);
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.colored !== undefined && (obj.colored = message.colored);
    return obj;
  },

  fromPartial(object: DeepPartial<Space>): Space {
    const message = { ...baseSpace } as Space;
    if (object.spaceId !== undefined && object.spaceId !== null) {
      message.spaceId = object.spaceId;
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    if (object.colored !== undefined && object.colored !== null) {
      message.colored = object.colored;
    }
    return message;
  },
};

const basePoint: object = { x: 0, y: 0 };

export const Point = {
  encode(message: Point, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).uint32(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Point {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePoint } as Point;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.x = reader.uint32();
          break;
        case 2:
          message.y = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Point {
    const message = { ...basePoint } as Point;
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    return message;
  },

  toJSON(message: Point): unknown {
    const obj: any = {};
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    return obj;
  },

  fromPartial(object: DeepPartial<Point>): Point {
    const message = { ...basePoint } as Point;
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    return message;
  },
};

const baseSpawnPoint: object = { x: 0, y: 0 };

export const SpawnPoint = {
  encode(message: SpawnPoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).uint32(message.y);
    }
    if (message.spawnId !== undefined) {
      writer.uint32(26).string(message.spawnId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpawnPoint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSpawnPoint } as SpawnPoint;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.x = reader.uint32();
          break;
        case 2:
          message.y = reader.uint32();
          break;
        case 3:
          message.spawnId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpawnPoint {
    const message = { ...baseSpawnPoint } as SpawnPoint;
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    if (object.spawnId !== undefined && object.spawnId !== null) {
      message.spawnId = String(object.spawnId);
    }
    return message;
  },

  toJSON(message: SpawnPoint): unknown {
    const obj: any = {};
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.spawnId !== undefined && (obj.spawnId = message.spawnId);
    return obj;
  },

  fromPartial(object: DeepPartial<SpawnPoint>): SpawnPoint {
    const message = { ...baseSpawnPoint } as SpawnPoint;
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    if (object.spawnId !== undefined && object.spawnId !== null) {
      message.spawnId = object.spawnId;
    }
    return message;
  },
};

const basePortal: object = { x: 0, y: 0 };

export const Portal = {
  encode(message: Portal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).uint32(message.y);
    }
    if (message.targetMap !== undefined) {
      writer.uint32(26).string(message.targetMap);
    }
    if (message.targetUrl !== undefined) {
      writer.uint32(34).string(message.targetUrl);
    }
    if (message.targetX !== undefined) {
      writer.uint32(40).uint32(message.targetX);
    }
    if (message.targetY !== undefined) {
      writer.uint32(48).uint32(message.targetY);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Portal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePortal } as Portal;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.x = reader.uint32();
          break;
        case 2:
          message.y = reader.uint32();
          break;
        case 3:
          message.targetMap = reader.string();
          break;
        case 4:
          message.targetUrl = reader.string();
          break;
        case 5:
          message.targetX = reader.uint32();
          break;
        case 6:
          message.targetY = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Portal {
    const message = { ...basePortal } as Portal;
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    if (object.targetMap !== undefined && object.targetMap !== null) {
      message.targetMap = String(object.targetMap);
    }
    if (object.targetUrl !== undefined && object.targetUrl !== null) {
      message.targetUrl = String(object.targetUrl);
    }
    if (object.targetX !== undefined && object.targetX !== null) {
      message.targetX = Number(object.targetX);
    }
    if (object.targetY !== undefined && object.targetY !== null) {
      message.targetY = Number(object.targetY);
    }
    return message;
  },

  toJSON(message: Portal): unknown {
    const obj: any = {};
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.targetMap !== undefined && (obj.targetMap = message.targetMap);
    message.targetUrl !== undefined && (obj.targetUrl = message.targetUrl);
    message.targetX !== undefined && (obj.targetX = message.targetX);
    message.targetY !== undefined && (obj.targetY = message.targetY);
    return obj;
  },

  fromPartial(object: DeepPartial<Portal>): Portal {
    const message = { ...basePortal } as Portal;
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    if (object.targetMap !== undefined && object.targetMap !== null) {
      message.targetMap = object.targetMap;
    }
    if (object.targetUrl !== undefined && object.targetUrl !== null) {
      message.targetUrl = object.targetUrl;
    }
    if (object.targetX !== undefined && object.targetX !== null) {
      message.targetX = object.targetX;
    }
    if (object.targetY !== undefined && object.targetY !== null) {
      message.targetY = object.targetY;
    }
    return message;
  },
};

const baseAnnouncer: object = { x: 0, y: 0 };

export const Announcer = {
  encode(message: Announcer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).uint32(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Announcer {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAnnouncer } as Announcer;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.x = reader.uint32();
          break;
        case 2:
          message.y = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Announcer {
    const message = { ...baseAnnouncer } as Announcer;
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    return message;
  },

  toJSON(message: Announcer): unknown {
    const obj: any = {};
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    return obj;
  },

  fromPartial(object: DeepPartial<Announcer>): Announcer {
    const message = { ...baseAnnouncer } as Announcer;
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    return message;
  },
};

const baseAsset: object = { x: 0, y: 0, src: "", width: 0, height: 0 };

export const Asset = {
  encode(message: Asset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).uint32(message.y);
    }
    if (message.src !== "") {
      writer.uint32(26).string(message.src);
    }
    if (message.width !== 0) {
      writer.uint32(32).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(40).uint32(message.height);
    }
    if (message.inFront !== undefined) {
      writer.uint32(48).bool(message.inFront);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Asset {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAsset } as Asset;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.x = reader.uint32();
          break;
        case 2:
          message.y = reader.uint32();
          break;
        case 3:
          message.src = reader.string();
          break;
        case 4:
          message.width = reader.uint32();
          break;
        case 5:
          message.height = reader.uint32();
          break;
        case 6:
          message.inFront = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Asset {
    const message = { ...baseAsset } as Asset;
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    if (object.src !== undefined && object.src !== null) {
      message.src = String(object.src);
    }
    if (object.width !== undefined && object.width !== null) {
      message.width = Number(object.width);
    }
    if (object.height !== undefined && object.height !== null) {
      message.height = Number(object.height);
    }
    if (object.inFront !== undefined && object.inFront !== null) {
      message.inFront = Boolean(object.inFront);
    }
    return message;
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.src !== undefined && (obj.src = message.src);
    message.width !== undefined && (obj.width = message.width);
    message.height !== undefined && (obj.height = message.height);
    message.inFront !== undefined && (obj.inFront = message.inFront);
    return obj;
  },

  fromPartial(object: DeepPartial<Asset>): Asset {
    const message = { ...baseAsset } as Asset;
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    if (object.src !== undefined && object.src !== null) {
      message.src = object.src;
    }
    if (object.width !== undefined && object.width !== null) {
      message.width = object.width;
    }
    if (object.height !== undefined && object.height !== null) {
      message.height = object.height;
    }
    if (object.inFront !== undefined && object.inFront !== null) {
      message.inFront = object.inFront;
    }
    return message;
  },
};

const baseAudioEmitter: object = { x: 0, y: 0, path: "", volume: 0 };

export const AudioEmitter = {
  encode(message: AudioEmitter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).uint32(message.y);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    writer.uint32(34).fork();
    for (const v of message.volume) {
      writer.float(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AudioEmitter {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAudioEmitter } as AudioEmitter;
    message.volume = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.x = reader.uint32();
          break;
        case 2:
          message.y = reader.uint32();
          break;
        case 3:
          message.path = reader.string();
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.volume.push(reader.float());
            }
          } else {
            message.volume.push(reader.float());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AudioEmitter {
    const message = { ...baseAudioEmitter } as AudioEmitter;
    message.volume = [];
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    if (object.path !== undefined && object.path !== null) {
      message.path = String(object.path);
    }
    if (object.volume !== undefined && object.volume !== null) {
      for (const e of object.volume) {
        message.volume.push(Number(e));
      }
    }
    return message;
  },

  toJSON(message: AudioEmitter): unknown {
    const obj: any = {};
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.path !== undefined && (obj.path = message.path);
    if (message.volume) {
      obj.volume = message.volume.map((e) => e);
    } else {
      obj.volume = [];
    }
    return obj;
  },

  fromPartial(object: DeepPartial<AudioEmitter>): AudioEmitter {
    const message = { ...baseAudioEmitter } as AudioEmitter;
    message.volume = [];
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    if (object.path !== undefined && object.path !== null) {
      message.path = object.path;
    }
    if (object.volume !== undefined && object.volume !== null) {
      for (const e of object.volume) {
        message.volume.push(e);
      }
    }
    return message;
  },
};

const baseAnimation: object = { x: 0, y: 0, framegap: 0, frames: "" };

export const Animation = {
  encode(message: Animation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).uint32(message.y);
    }
    if (message.framegap !== 0) {
      writer.uint32(24).uint32(message.framegap);
    }
    for (const v of message.frames) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Animation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAnimation } as Animation;
    message.frames = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.x = reader.uint32();
          break;
        case 2:
          message.y = reader.uint32();
          break;
        case 3:
          message.framegap = reader.uint32();
          break;
        case 4:
          message.frames.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Animation {
    const message = { ...baseAnimation } as Animation;
    message.frames = [];
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    if (object.framegap !== undefined && object.framegap !== null) {
      message.framegap = Number(object.framegap);
    }
    if (object.frames !== undefined && object.frames !== null) {
      for (const e of object.frames) {
        message.frames.push(String(e));
      }
    }
    return message;
  },

  toJSON(message: Animation): unknown {
    const obj: any = {};
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.framegap !== undefined && (obj.framegap = message.framegap);
    if (message.frames) {
      obj.frames = message.frames.map((e) => e);
    } else {
      obj.frames = [];
    }
    return obj;
  },

  fromPartial(object: DeepPartial<Animation>): Animation {
    const message = { ...baseAnimation } as Animation;
    message.frames = [];
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    if (object.framegap !== undefined && object.framegap !== null) {
      message.framegap = object.framegap;
    }
    if (object.frames !== undefined && object.frames !== null) {
      for (const e of object.frames) {
        message.frames.push(e);
      }
    }
    return message;
  },
};

const baseAreaPosition: object = { x1: 0, y1: 0, x2: 0, y2: 0 };

export const AreaPosition = {
  encode(message: AreaPosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x1 !== 0) {
      writer.uint32(8).uint32(message.x1);
    }
    if (message.y1 !== 0) {
      writer.uint32(16).uint32(message.y1);
    }
    if (message.x2 !== 0) {
      writer.uint32(24).uint32(message.x2);
    }
    if (message.y2 !== 0) {
      writer.uint32(32).uint32(message.y2);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AreaPosition {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAreaPosition } as AreaPosition;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.x1 = reader.uint32();
          break;
        case 2:
          message.y1 = reader.uint32();
          break;
        case 3:
          message.x2 = reader.uint32();
          break;
        case 4:
          message.y2 = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AreaPosition {
    const message = { ...baseAreaPosition } as AreaPosition;
    if (object.x1 !== undefined && object.x1 !== null) {
      message.x1 = Number(object.x1);
    }
    if (object.y1 !== undefined && object.y1 !== null) {
      message.y1 = Number(object.y1);
    }
    if (object.x2 !== undefined && object.x2 !== null) {
      message.x2 = Number(object.x2);
    }
    if (object.y2 !== undefined && object.y2 !== null) {
      message.y2 = Number(object.y2);
    }
    return message;
  },

  toJSON(message: AreaPosition): unknown {
    const obj: any = {};
    message.x1 !== undefined && (obj.x1 = message.x1);
    message.y1 !== undefined && (obj.y1 = message.y1);
    message.x2 !== undefined && (obj.x2 = message.x2);
    message.y2 !== undefined && (obj.y2 = message.y2);
    return obj;
  },

  fromPartial(object: DeepPartial<AreaPosition>): AreaPosition {
    const message = { ...baseAreaPosition } as AreaPosition;
    if (object.x1 !== undefined && object.x1 !== null) {
      message.x1 = object.x1;
    }
    if (object.y1 !== undefined && object.y1 !== null) {
      message.y1 = object.y1;
    }
    if (object.x2 !== undefined && object.x2 !== null) {
      message.x2 = object.x2;
    }
    if (object.y2 !== undefined && object.y2 !== null) {
      message.y2 = object.y2;
    }
    return message;
  },
};

const baseArea: object = { categories: "" };

export const Area = {
  encode(message: Area, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.categories !== "") {
      writer.uint32(10).string(message.categories);
    }
    for (const v of message.coords) {
      AreaPosition.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Area {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseArea } as Area;
    message.coords = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.categories = reader.string();
          break;
        case 2:
          message.coords.push(AreaPosition.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Area {
    const message = { ...baseArea } as Area;
    message.coords = [];
    if (object.categories !== undefined && object.categories !== null) {
      message.categories = String(object.categories);
    }
    if (object.coords !== undefined && object.coords !== null) {
      for (const e of object.coords) {
        message.coords.push(AreaPosition.fromJSON(e));
      }
    }
    return message;
  },

  toJSON(message: Area): unknown {
    const obj: any = {};
    message.categories !== undefined && (obj.categories = message.categories);
    if (message.coords) {
      obj.coords = message.coords.map((e) => (e ? AreaPosition.toJSON(e) : undefined));
    } else {
      obj.coords = [];
    }
    return obj;
  },

  fromPartial(object: DeepPartial<Area>): Area {
    const message = { ...baseArea } as Area;
    message.coords = [];
    if (object.categories !== undefined && object.categories !== null) {
      message.categories = object.categories;
    }
    if (object.coords !== undefined && object.coords !== null) {
      for (const e of object.coords) {
        message.coords.push(AreaPosition.fromPartial(e));
      }
    }
    return message;
  },
};

const baseMapSetDimensions: object = { mapId: "", width: 0, height: 0 };

export const MapSetDimensions = {
  encode(message: MapSetDimensions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.width !== 0) {
      writer.uint32(16).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(24).uint32(message.height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetDimensions {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetDimensions } as MapSetDimensions;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.width = reader.uint32();
          break;
        case 3:
          message.height = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetDimensions {
    const message = { ...baseMapSetDimensions } as MapSetDimensions;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.width !== undefined && object.width !== null) {
      message.width = Number(object.width);
    }
    if (object.height !== undefined && object.height !== null) {
      message.height = Number(object.height);
    }
    return message;
  },

  toJSON(message: MapSetDimensions): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.width !== undefined && (obj.width = message.width);
    message.height !== undefined && (obj.height = message.height);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetDimensions>): MapSetDimensions {
    const message = { ...baseMapSetDimensions } as MapSetDimensions;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.width !== undefined && object.width !== null) {
      message.width = object.width;
    }
    if (object.height !== undefined && object.height !== null) {
      message.height = object.height;
    }
    return message;
  },
};

const baseMapSetCollisions: object = { mapId: "", x: 0, y: 0, w: 0, h: 0, mask: "" };

export const MapSetCollisions = {
  encode(message: MapSetCollisions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.x !== 0) {
      writer.uint32(16).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(24).uint32(message.y);
    }
    if (message.w !== 0) {
      writer.uint32(32).uint32(message.w);
    }
    if (message.h !== 0) {
      writer.uint32(40).uint32(message.h);
    }
    if (message.mask !== "") {
      writer.uint32(50).string(message.mask);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetCollisions {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetCollisions } as MapSetCollisions;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.x = reader.uint32();
          break;
        case 3:
          message.y = reader.uint32();
          break;
        case 4:
          message.w = reader.uint32();
          break;
        case 5:
          message.h = reader.uint32();
          break;
        case 6:
          message.mask = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetCollisions {
    const message = { ...baseMapSetCollisions } as MapSetCollisions;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    if (object.w !== undefined && object.w !== null) {
      message.w = Number(object.w);
    }
    if (object.h !== undefined && object.h !== null) {
      message.h = Number(object.h);
    }
    if (object.mask !== undefined && object.mask !== null) {
      message.mask = String(object.mask);
    }
    return message;
  },

  toJSON(message: MapSetCollisions): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.w !== undefined && (obj.w = message.w);
    message.h !== undefined && (obj.h = message.h);
    message.mask !== undefined && (obj.mask = message.mask);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetCollisions>): MapSetCollisions {
    const message = { ...baseMapSetCollisions } as MapSetCollisions;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    if (object.w !== undefined && object.w !== null) {
      message.w = object.w;
    }
    if (object.h !== undefined && object.h !== null) {
      message.h = object.h;
    }
    if (object.mask !== undefined && object.mask !== null) {
      message.mask = object.mask;
    }
    return message;
  },
};

const baseMapSetBackgroundImagePath: object = { mapId: "", backgroundImagePath: "" };

export const MapSetBackgroundImagePath = {
  encode(message: MapSetBackgroundImagePath, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.backgroundImagePath !== "") {
      writer.uint32(18).string(message.backgroundImagePath);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetBackgroundImagePath {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetBackgroundImagePath } as MapSetBackgroundImagePath;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.backgroundImagePath = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetBackgroundImagePath {
    const message = { ...baseMapSetBackgroundImagePath } as MapSetBackgroundImagePath;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.backgroundImagePath !== undefined && object.backgroundImagePath !== null) {
      message.backgroundImagePath = String(object.backgroundImagePath);
    }
    return message;
  },

  toJSON(message: MapSetBackgroundImagePath): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.backgroundImagePath !== undefined &&
      (obj.backgroundImagePath = message.backgroundImagePath);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetBackgroundImagePath>): MapSetBackgroundImagePath {
    const message = { ...baseMapSetBackgroundImagePath } as MapSetBackgroundImagePath;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.backgroundImagePath !== undefined && object.backgroundImagePath !== null) {
      message.backgroundImagePath = object.backgroundImagePath;
    }
    return message;
  },
};

const baseMapSetForegroundImagePath: object = { mapId: "", foregroundImagePath: "" };

export const MapSetForegroundImagePath = {
  encode(message: MapSetForegroundImagePath, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.foregroundImagePath !== "") {
      writer.uint32(18).string(message.foregroundImagePath);
    }
    if (message.delete !== undefined) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetForegroundImagePath {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetForegroundImagePath } as MapSetForegroundImagePath;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.foregroundImagePath = reader.string();
          break;
        case 3:
          message.delete = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetForegroundImagePath {
    const message = { ...baseMapSetForegroundImagePath } as MapSetForegroundImagePath;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.foregroundImagePath !== undefined && object.foregroundImagePath !== null) {
      message.foregroundImagePath = String(object.foregroundImagePath);
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = Boolean(object.delete);
    }
    return message;
  },

  toJSON(message: MapSetForegroundImagePath): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.foregroundImagePath !== undefined &&
      (obj.foregroundImagePath = message.foregroundImagePath);
    message.delete !== undefined && (obj.delete = message.delete);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetForegroundImagePath>): MapSetForegroundImagePath {
    const message = { ...baseMapSetForegroundImagePath } as MapSetForegroundImagePath;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.foregroundImagePath !== undefined && object.foregroundImagePath !== null) {
      message.foregroundImagePath = object.foregroundImagePath;
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = object.delete;
    }
    return message;
  },
};

const baseMapSetSprites: object = { mapId: "", sprites: 0 };

export const MapSetSprites = {
  encode(message: MapSetSprites, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    writer.uint32(18).fork();
    for (const v of message.sprites) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.delete !== undefined) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetSprites {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetSprites } as MapSetSprites;
    message.sprites = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.sprites.push(reader.uint32());
            }
          } else {
            message.sprites.push(reader.uint32());
          }
          break;
        case 3:
          message.delete = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetSprites {
    const message = { ...baseMapSetSprites } as MapSetSprites;
    message.sprites = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.sprites !== undefined && object.sprites !== null) {
      for (const e of object.sprites) {
        message.sprites.push(Number(e));
      }
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = Boolean(object.delete);
    }
    return message;
  },

  toJSON(message: MapSetSprites): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    if (message.sprites) {
      obj.sprites = message.sprites.map((e) => e);
    } else {
      obj.sprites = [];
    }
    message.delete !== undefined && (obj.delete = message.delete);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetSprites>): MapSetSprites {
    const message = { ...baseMapSetSprites } as MapSetSprites;
    message.sprites = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.sprites !== undefined && object.sprites !== null) {
      for (const e of object.sprites) {
        message.sprites.push(e);
      }
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = object.delete;
    }
    return message;
  },
};

const baseMapSetSpaces: object = { mapId: "" };

export const MapSetSpaces = {
  encode(message: MapSetSpaces, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    for (const v of message.spaces) {
      Space.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetSpaces {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetSpaces } as MapSetSpaces;
    message.spaces = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.spaces.push(Space.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetSpaces {
    const message = { ...baseMapSetSpaces } as MapSetSpaces;
    message.spaces = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.spaces !== undefined && object.spaces !== null) {
      for (const e of object.spaces) {
        message.spaces.push(Space.fromJSON(e));
      }
    }
    return message;
  },

  toJSON(message: MapSetSpaces): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    if (message.spaces) {
      obj.spaces = message.spaces.map((e) => (e ? Space.toJSON(e) : undefined));
    } else {
      obj.spaces = [];
    }
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetSpaces>): MapSetSpaces {
    const message = { ...baseMapSetSpaces } as MapSetSpaces;
    message.spaces = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.spaces !== undefined && object.spaces !== null) {
      for (const e of object.spaces) {
        message.spaces.push(Space.fromPartial(e));
      }
    }
    return message;
  },
};

const baseMapSetSpawn: object = { mapId: "" };

export const MapSetSpawn = {
  encode(message: MapSetSpawn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.spawn !== undefined) {
      Point.encode(message.spawn, writer.uint32(18).fork()).ldelim();
    }
    if (message.delete !== undefined) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetSpawn {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetSpawn } as MapSetSpawn;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.spawn = Point.decode(reader, reader.uint32());
          break;
        case 3:
          message.delete = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetSpawn {
    const message = { ...baseMapSetSpawn } as MapSetSpawn;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.spawn !== undefined && object.spawn !== null) {
      message.spawn = Point.fromJSON(object.spawn);
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = Boolean(object.delete);
    }
    return message;
  },

  toJSON(message: MapSetSpawn): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.spawn !== undefined &&
      (obj.spawn = message.spawn ? Point.toJSON(message.spawn) : undefined);
    message.delete !== undefined && (obj.delete = message.delete);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetSpawn>): MapSetSpawn {
    const message = { ...baseMapSetSpawn } as MapSetSpawn;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.spawn !== undefined && object.spawn !== null) {
      message.spawn = Point.fromPartial(object.spawn);
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = object.delete;
    }
    return message;
  },
};

const baseMapSetSpawns: object = { mapId: "" };

export const MapSetSpawns = {
  encode(message: MapSetSpawns, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    for (const v of message.spawns) {
      SpawnPoint.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetSpawns {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetSpawns } as MapSetSpawns;
    message.spawns = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.spawns.push(SpawnPoint.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetSpawns {
    const message = { ...baseMapSetSpawns } as MapSetSpawns;
    message.spawns = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.spawns !== undefined && object.spawns !== null) {
      for (const e of object.spawns) {
        message.spawns.push(SpawnPoint.fromJSON(e));
      }
    }
    return message;
  },

  toJSON(message: MapSetSpawns): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    if (message.spawns) {
      obj.spawns = message.spawns.map((e) => (e ? SpawnPoint.toJSON(e) : undefined));
    } else {
      obj.spawns = [];
    }
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetSpawns>): MapSetSpawns {
    const message = { ...baseMapSetSpawns } as MapSetSpawns;
    message.spawns = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.spawns !== undefined && object.spawns !== null) {
      for (const e of object.spawns) {
        message.spawns.push(SpawnPoint.fromPartial(e));
      }
    }
    return message;
  },
};

const baseMapSetPortals: object = { mapId: "" };

export const MapSetPortals = {
  encode(message: MapSetPortals, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    for (const v of message.portals) {
      Portal.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetPortals {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetPortals } as MapSetPortals;
    message.portals = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.portals.push(Portal.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetPortals {
    const message = { ...baseMapSetPortals } as MapSetPortals;
    message.portals = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.portals !== undefined && object.portals !== null) {
      for (const e of object.portals) {
        message.portals.push(Portal.fromJSON(e));
      }
    }
    return message;
  },

  toJSON(message: MapSetPortals): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    if (message.portals) {
      obj.portals = message.portals.map((e) => (e ? Portal.toJSON(e) : undefined));
    } else {
      obj.portals = [];
    }
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetPortals>): MapSetPortals {
    const message = { ...baseMapSetPortals } as MapSetPortals;
    message.portals = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.portals !== undefined && object.portals !== null) {
      for (const e of object.portals) {
        message.portals.push(Portal.fromPartial(e));
      }
    }
    return message;
  },
};

const baseMapSetAnnouncer: object = { mapId: "" };

export const MapSetAnnouncer = {
  encode(message: MapSetAnnouncer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    for (const v of message.announcer) {
      Announcer.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetAnnouncer {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetAnnouncer } as MapSetAnnouncer;
    message.announcer = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.announcer.push(Announcer.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetAnnouncer {
    const message = { ...baseMapSetAnnouncer } as MapSetAnnouncer;
    message.announcer = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.announcer !== undefined && object.announcer !== null) {
      for (const e of object.announcer) {
        message.announcer.push(Announcer.fromJSON(e));
      }
    }
    return message;
  },

  toJSON(message: MapSetAnnouncer): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    if (message.announcer) {
      obj.announcer = message.announcer.map((e) => (e ? Announcer.toJSON(e) : undefined));
    } else {
      obj.announcer = [];
    }
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetAnnouncer>): MapSetAnnouncer {
    const message = { ...baseMapSetAnnouncer } as MapSetAnnouncer;
    message.announcer = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.announcer !== undefined && object.announcer !== null) {
      for (const e of object.announcer) {
        message.announcer.push(Announcer.fromPartial(e));
      }
    }
    return message;
  },
};

const baseMapSetAudio: object = { mapId: "" };

export const MapSetAudio = {
  encode(message: MapSetAudio, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    for (const v of message.audio) {
      AudioEmitter.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.delete !== undefined) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetAudio {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetAudio } as MapSetAudio;
    message.audio = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.audio.push(AudioEmitter.decode(reader, reader.uint32()));
          break;
        case 3:
          message.delete = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetAudio {
    const message = { ...baseMapSetAudio } as MapSetAudio;
    message.audio = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.audio !== undefined && object.audio !== null) {
      for (const e of object.audio) {
        message.audio.push(AudioEmitter.fromJSON(e));
      }
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = Boolean(object.delete);
    }
    return message;
  },

  toJSON(message: MapSetAudio): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    if (message.audio) {
      obj.audio = message.audio.map((e) => (e ? AudioEmitter.toJSON(e) : undefined));
    } else {
      obj.audio = [];
    }
    message.delete !== undefined && (obj.delete = message.delete);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetAudio>): MapSetAudio {
    const message = { ...baseMapSetAudio } as MapSetAudio;
    message.audio = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.audio !== undefined && object.audio !== null) {
      for (const e of object.audio) {
        message.audio.push(AudioEmitter.fromPartial(e));
      }
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = object.delete;
    }
    return message;
  },
};

const baseMapSetAnimations: object = { mapId: "" };

export const MapSetAnimations = {
  encode(message: MapSetAnimations, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    for (const v of message.animations) {
      Animation.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.delete !== undefined) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetAnimations {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetAnimations } as MapSetAnimations;
    message.animations = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.animations.push(Animation.decode(reader, reader.uint32()));
          break;
        case 3:
          message.delete = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetAnimations {
    const message = { ...baseMapSetAnimations } as MapSetAnimations;
    message.animations = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.animations !== undefined && object.animations !== null) {
      for (const e of object.animations) {
        message.animations.push(Animation.fromJSON(e));
      }
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = Boolean(object.delete);
    }
    return message;
  },

  toJSON(message: MapSetAnimations): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    if (message.animations) {
      obj.animations = message.animations.map((e) => (e ? Animation.toJSON(e) : undefined));
    } else {
      obj.animations = [];
    }
    message.delete !== undefined && (obj.delete = message.delete);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetAnimations>): MapSetAnimations {
    const message = { ...baseMapSetAnimations } as MapSetAnimations;
    message.animations = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.animations !== undefined && object.animations !== null) {
      for (const e of object.animations) {
        message.animations.push(Animation.fromPartial(e));
      }
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = object.delete;
    }
    return message;
  },
};

const baseMapSetAssets: object = { mapId: "" };

export const MapSetAssets = {
  encode(message: MapSetAssets, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    for (const v of message.assets) {
      Asset.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.delete !== undefined) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetAssets {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetAssets } as MapSetAssets;
    message.assets = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.assets.push(Asset.decode(reader, reader.uint32()));
          break;
        case 3:
          message.delete = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetAssets {
    const message = { ...baseMapSetAssets } as MapSetAssets;
    message.assets = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.assets !== undefined && object.assets !== null) {
      for (const e of object.assets) {
        message.assets.push(Asset.fromJSON(e));
      }
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = Boolean(object.delete);
    }
    return message;
  },

  toJSON(message: MapSetAssets): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    if (message.assets) {
      obj.assets = message.assets.map((e) => (e ? Asset.toJSON(e) : undefined));
    } else {
      obj.assets = [];
    }
    message.delete !== undefined && (obj.delete = message.delete);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetAssets>): MapSetAssets {
    const message = { ...baseMapSetAssets } as MapSetAssets;
    message.assets = [];
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.assets !== undefined && object.assets !== null) {
      for (const e of object.assets) {
        message.assets.push(Asset.fromPartial(e));
      }
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = object.delete;
    }
    return message;
  },
};

const baseMapSetObjects: object = { mapId: "" };

export const MapSetObjects = {
  encode(message: MapSetObjects, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    Object.entries(message.objects).forEach(([key, value]) => {
      MapSetObjects_ObjectsEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetObjects {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetObjects } as MapSetObjects;
    message.objects = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          const entry2 = MapSetObjects_ObjectsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.objects[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetObjects {
    const message = { ...baseMapSetObjects } as MapSetObjects;
    message.objects = {};
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.objects !== undefined && object.objects !== null) {
      Object.entries(object.objects).forEach(([key, value]) => {
        message.objects[Number(key)] = WireObject.fromJSON(value);
      });
    }
    return message;
  },

  toJSON(message: MapSetObjects): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    obj.objects = {};
    if (message.objects) {
      Object.entries(message.objects).forEach(([k, v]) => {
        obj.objects[k] = WireObject.toJSON(v);
      });
    }
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetObjects>): MapSetObjects {
    const message = { ...baseMapSetObjects } as MapSetObjects;
    message.objects = {};
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.objects !== undefined && object.objects !== null) {
      Object.entries(object.objects).forEach(([key, value]) => {
        if (value !== undefined) {
          message.objects[Number(key)] = WireObject.fromPartial(value);
        }
      });
    }
    return message;
  },
};

const baseMapSetObjects_ObjectsEntry: object = { key: 0 };

export const MapSetObjects_ObjectsEntry = {
  encode(
    message: MapSetObjects_ObjectsEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      WireObject.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetObjects_ObjectsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetObjects_ObjectsEntry } as MapSetObjects_ObjectsEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.uint32();
          break;
        case 2:
          message.value = WireObject.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetObjects_ObjectsEntry {
    const message = { ...baseMapSetObjects_ObjectsEntry } as MapSetObjects_ObjectsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = Number(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = WireObject.fromJSON(object.value);
    }
    return message;
  },

  toJSON(message: MapSetObjects_ObjectsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined &&
      (obj.value = message.value ? WireObject.toJSON(message.value) : undefined);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetObjects_ObjectsEntry>): MapSetObjects_ObjectsEntry {
    const message = { ...baseMapSetObjects_ObjectsEntry } as MapSetObjects_ObjectsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = WireObject.fromPartial(object.value);
    }
    return message;
  },
};

const baseMapSetName: object = { mapId: "", name: "" };

export const MapSetName = {
  encode(message: MapSetName, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.delete !== undefined) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetName {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetName } as MapSetName;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.delete = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetName {
    const message = { ...baseMapSetName } as MapSetName;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.name !== undefined && object.name !== null) {
      message.name = String(object.name);
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = Boolean(object.delete);
    }
    return message;
  },

  toJSON(message: MapSetName): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.name !== undefined && (obj.name = message.name);
    message.delete !== undefined && (obj.delete = message.delete);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetName>): MapSetName {
    const message = { ...baseMapSetName } as MapSetName;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.name !== undefined && object.name !== null) {
      message.name = object.name;
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = object.delete;
    }
    return message;
  },
};

const baseMapSetDefaultChat: object = { mapId: "", defaultChat: "" };

export const MapSetDefaultChat = {
  encode(message: MapSetDefaultChat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.defaultChat !== "") {
      writer.uint32(18).string(message.defaultChat);
    }
    if (message.delete !== undefined) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetDefaultChat {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetDefaultChat } as MapSetDefaultChat;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.defaultChat = reader.string();
          break;
        case 3:
          message.delete = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetDefaultChat {
    const message = { ...baseMapSetDefaultChat } as MapSetDefaultChat;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.defaultChat !== undefined && object.defaultChat !== null) {
      message.defaultChat = String(object.defaultChat);
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = Boolean(object.delete);
    }
    return message;
  },

  toJSON(message: MapSetDefaultChat): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.defaultChat !== undefined && (obj.defaultChat = message.defaultChat);
    message.delete !== undefined && (obj.delete = message.delete);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetDefaultChat>): MapSetDefaultChat {
    const message = { ...baseMapSetDefaultChat } as MapSetDefaultChat;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.defaultChat !== undefined && object.defaultChat !== null) {
      message.defaultChat = object.defaultChat;
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = object.delete;
    }
    return message;
  },
};

const baseMapSetMuteOnEntry: object = { mapId: "", muteOnEntry: false };

export const MapSetMuteOnEntry = {
  encode(message: MapSetMuteOnEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.muteOnEntry === true) {
      writer.uint32(16).bool(message.muteOnEntry);
    }
    if (message.delete !== undefined) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetMuteOnEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetMuteOnEntry } as MapSetMuteOnEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.muteOnEntry = reader.bool();
          break;
        case 3:
          message.delete = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetMuteOnEntry {
    const message = { ...baseMapSetMuteOnEntry } as MapSetMuteOnEntry;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.muteOnEntry !== undefined && object.muteOnEntry !== null) {
      message.muteOnEntry = Boolean(object.muteOnEntry);
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = Boolean(object.delete);
    }
    return message;
  },

  toJSON(message: MapSetMuteOnEntry): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.muteOnEntry !== undefined && (obj.muteOnEntry = message.muteOnEntry);
    message.delete !== undefined && (obj.delete = message.delete);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetMuteOnEntry>): MapSetMuteOnEntry {
    const message = { ...baseMapSetMuteOnEntry } as MapSetMuteOnEntry;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.muteOnEntry !== undefined && object.muteOnEntry !== null) {
      message.muteOnEntry = object.muteOnEntry;
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = object.delete;
    }
    return message;
  },
};

const baseMapSetUseDrawnBG: object = { mapId: "", useDrawnBG: false };

export const MapSetUseDrawnBG = {
  encode(message: MapSetUseDrawnBG, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.useDrawnBG === true) {
      writer.uint32(16).bool(message.useDrawnBG);
    }
    if (message.delete !== undefined) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetUseDrawnBG {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetUseDrawnBG } as MapSetUseDrawnBG;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.useDrawnBG = reader.bool();
          break;
        case 3:
          message.delete = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetUseDrawnBG {
    const message = { ...baseMapSetUseDrawnBG } as MapSetUseDrawnBG;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.useDrawnBG !== undefined && object.useDrawnBG !== null) {
      message.useDrawnBG = Boolean(object.useDrawnBG);
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = Boolean(object.delete);
    }
    return message;
  },

  toJSON(message: MapSetUseDrawnBG): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.useDrawnBG !== undefined && (obj.useDrawnBG = message.useDrawnBG);
    message.delete !== undefined && (obj.delete = message.delete);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetUseDrawnBG>): MapSetUseDrawnBG {
    const message = { ...baseMapSetUseDrawnBG } as MapSetUseDrawnBG;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.useDrawnBG !== undefined && object.useDrawnBG !== null) {
      message.useDrawnBG = object.useDrawnBG;
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = object.delete;
    }
    return message;
  },
};

const baseMapSetWalls: object = { mapId: "" };

export const MapSetWalls = {
  encode(message: MapSetWalls, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    Object.entries(message.walls).forEach(([key, value]) => {
      MapSetWalls_WallsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.delete !== undefined) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetWalls {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetWalls } as MapSetWalls;
    message.walls = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          const entry2 = MapSetWalls_WallsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.walls[entry2.key] = entry2.value;
          }
          break;
        case 3:
          message.delete = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetWalls {
    const message = { ...baseMapSetWalls } as MapSetWalls;
    message.walls = {};
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.walls !== undefined && object.walls !== null) {
      Object.entries(object.walls).forEach(([key, value]) => {
        message.walls[key] = String(value);
      });
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = Boolean(object.delete);
    }
    return message;
  },

  toJSON(message: MapSetWalls): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    obj.walls = {};
    if (message.walls) {
      Object.entries(message.walls).forEach(([k, v]) => {
        obj.walls[k] = v;
      });
    }
    message.delete !== undefined && (obj.delete = message.delete);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetWalls>): MapSetWalls {
    const message = { ...baseMapSetWalls } as MapSetWalls;
    message.walls = {};
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.walls !== undefined && object.walls !== null) {
      Object.entries(object.walls).forEach(([key, value]) => {
        if (value !== undefined) {
          message.walls[key] = String(value);
        }
      });
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = object.delete;
    }
    return message;
  },
};

const baseMapSetWalls_WallsEntry: object = { key: "", value: "" };

export const MapSetWalls_WallsEntry = {
  encode(message: MapSetWalls_WallsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetWalls_WallsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetWalls_WallsEntry } as MapSetWalls_WallsEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetWalls_WallsEntry {
    const message = { ...baseMapSetWalls_WallsEntry } as MapSetWalls_WallsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = String(object.value);
    }
    return message;
  },

  toJSON(message: MapSetWalls_WallsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetWalls_WallsEntry>): MapSetWalls_WallsEntry {
    const message = { ...baseMapSetWalls_WallsEntry } as MapSetWalls_WallsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    return message;
  },
};

const baseMapSetFloors: object = { mapId: "" };

export const MapSetFloors = {
  encode(message: MapSetFloors, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    Object.entries(message.floors).forEach(([key, value]) => {
      MapSetFloors_FloorsEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).ldelim();
    });
    if (message.delete !== undefined) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetFloors {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetFloors } as MapSetFloors;
    message.floors = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          const entry2 = MapSetFloors_FloorsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.floors[entry2.key] = entry2.value;
          }
          break;
        case 3:
          message.delete = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetFloors {
    const message = { ...baseMapSetFloors } as MapSetFloors;
    message.floors = {};
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.floors !== undefined && object.floors !== null) {
      Object.entries(object.floors).forEach(([key, value]) => {
        message.floors[key] = String(value);
      });
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = Boolean(object.delete);
    }
    return message;
  },

  toJSON(message: MapSetFloors): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    obj.floors = {};
    if (message.floors) {
      Object.entries(message.floors).forEach(([k, v]) => {
        obj.floors[k] = v;
      });
    }
    message.delete !== undefined && (obj.delete = message.delete);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetFloors>): MapSetFloors {
    const message = { ...baseMapSetFloors } as MapSetFloors;
    message.floors = {};
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.floors !== undefined && object.floors !== null) {
      Object.entries(object.floors).forEach(([key, value]) => {
        if (value !== undefined) {
          message.floors[key] = String(value);
        }
      });
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = object.delete;
    }
    return message;
  },
};

const baseMapSetFloors_FloorsEntry: object = { key: "", value: "" };

export const MapSetFloors_FloorsEntry = {
  encode(message: MapSetFloors_FloorsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetFloors_FloorsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetFloors_FloorsEntry } as MapSetFloors_FloorsEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetFloors_FloorsEntry {
    const message = { ...baseMapSetFloors_FloorsEntry } as MapSetFloors_FloorsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = String(object.value);
    }
    return message;
  },

  toJSON(message: MapSetFloors_FloorsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetFloors_FloorsEntry>): MapSetFloors_FloorsEntry {
    const message = { ...baseMapSetFloors_FloorsEntry } as MapSetFloors_FloorsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    return message;
  },
};

const baseMapSetAreas: object = { mapId: "" };

export const MapSetAreas = {
  encode(message: MapSetAreas, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    Object.entries(message.areas).forEach(([key, value]) => {
      MapSetAreas_AreasEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.delete !== undefined) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetAreas {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetAreas } as MapSetAreas;
    message.areas = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          const entry2 = MapSetAreas_AreasEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.areas[entry2.key] = entry2.value;
          }
          break;
        case 3:
          message.delete = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetAreas {
    const message = { ...baseMapSetAreas } as MapSetAreas;
    message.areas = {};
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.areas !== undefined && object.areas !== null) {
      Object.entries(object.areas).forEach(([key, value]) => {
        message.areas[key] = Area.fromJSON(value);
      });
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = Boolean(object.delete);
    }
    return message;
  },

  toJSON(message: MapSetAreas): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    obj.areas = {};
    if (message.areas) {
      Object.entries(message.areas).forEach(([k, v]) => {
        obj.areas[k] = Area.toJSON(v);
      });
    }
    message.delete !== undefined && (obj.delete = message.delete);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetAreas>): MapSetAreas {
    const message = { ...baseMapSetAreas } as MapSetAreas;
    message.areas = {};
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.areas !== undefined && object.areas !== null) {
      Object.entries(object.areas).forEach(([key, value]) => {
        if (value !== undefined) {
          message.areas[key] = Area.fromPartial(value);
        }
      });
    }
    if (object.delete !== undefined && object.delete !== null) {
      message.delete = object.delete;
    }
    return message;
  },
};

const baseMapSetAreas_AreasEntry: object = { key: "" };

export const MapSetAreas_AreasEntry = {
  encode(message: MapSetAreas_AreasEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Area.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapSetAreas_AreasEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapSetAreas_AreasEntry } as MapSetAreas_AreasEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Area.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapSetAreas_AreasEntry {
    const message = { ...baseMapSetAreas_AreasEntry } as MapSetAreas_AreasEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = Area.fromJSON(object.value);
    }
    return message;
  },

  toJSON(message: MapSetAreas_AreasEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined &&
      (obj.value = message.value ? Area.toJSON(message.value) : undefined);
    return obj;
  },

  fromPartial(object: DeepPartial<MapSetAreas_AreasEntry>): MapSetAreas_AreasEntry {
    const message = { ...baseMapSetAreas_AreasEntry } as MapSetAreas_AreasEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = Area.fromPartial(object.value);
    }
    return message;
  },
};

const baseMapDeleteObject: object = { mapId: "", key: 0 };

export const MapDeleteObject = {
  encode(message: MapDeleteObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.key !== 0) {
      writer.uint32(16).uint32(message.key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapDeleteObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapDeleteObject } as MapDeleteObject;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.key = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapDeleteObject {
    const message = { ...baseMapDeleteObject } as MapDeleteObject;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.key !== undefined && object.key !== null) {
      message.key = Number(object.key);
    }
    return message;
  },

  toJSON(message: MapDeleteObject): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.key !== undefined && (obj.key = message.key);
    return obj;
  },

  fromPartial(object: DeepPartial<MapDeleteObject>): MapDeleteObject {
    const message = { ...baseMapDeleteObject } as MapDeleteObject;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    return message;
  },
};

const baseServerClientBatch: object = {};

export const ServerClientBatch = {
  encode(message: ServerClientBatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.events) {
      ServerClientEvent.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServerClientBatch {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseServerClientBatch } as ServerClientBatch;
    message.events = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.events.push(ServerClientEvent.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ServerClientBatch {
    const message = { ...baseServerClientBatch } as ServerClientBatch;
    message.events = [];
    if (object.events !== undefined && object.events !== null) {
      for (const e of object.events) {
        message.events.push(ServerClientEvent.fromJSON(e));
      }
    }
    return message;
  },

  toJSON(message: ServerClientBatch): unknown {
    const obj: any = {};
    if (message.events) {
      obj.events = message.events.map((e) => (e ? ServerClientEvent.toJSON(e) : undefined));
    } else {
      obj.events = [];
    }
    return obj;
  },

  fromPartial(object: DeepPartial<ServerClientBatch>): ServerClientBatch {
    const message = { ...baseServerClientBatch } as ServerClientBatch;
    message.events = [];
    if (object.events !== undefined && object.events !== null) {
      for (const e of object.events) {
        message.events.push(ServerClientEvent.fromPartial(e));
      }
    }
    return message;
  },
};

const baseServerClientEvent: object = {};

export const ServerClientEvent = {
  encode(message: ServerClientEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.event?.$case === "info") {
      Info.encode(message.event.info, writer.uint32(802).fork()).ldelim();
    }
    if (message.event?.$case === "warn") {
      Warn.encode(message.event.warn, writer.uint32(810).fork()).ldelim();
    }
    if (message.event?.$case === "error") {
      Error.encode(message.event.error, writer.uint32(818).fork()).ldelim();
    }
    if (message.event?.$case === "ready") {
      Ready.encode(message.event.ready, writer.uint32(826).fork()).ldelim();
    }
    if (message.event?.$case === "serverHeartbeat") {
      ServerHeartbeat.encode(message.event.serverHeartbeat, writer.uint32(842).fork()).ldelim();
    }
    if (message.event?.$case === "disableVideo") {
      DisableVideo.encode(message.event.disableVideo, writer.uint32(850).fork()).ldelim();
    }
    if (message.event?.$case === "playerMoves") {
      PlayerMoves.encode(message.event.playerMoves, writer.uint32(10).fork()).ldelim();
    }
    if (message.event?.$case === "playerSetsStatus") {
      PlayerSetsStatus.encode(message.event.playerSetsStatus, writer.uint32(42).fork()).ldelim();
    }
    if (message.event?.$case === "playerSpotlights") {
      PlayerSpotlights.encode(message.event.playerSpotlights, writer.uint32(50).fork()).ldelim();
    }
    if (message.event?.$case === "playerRings") {
      PlayerRings.encode(message.event.playerRings, writer.uint32(58).fork()).ldelim();
    }
    if (message.event?.$case === "playerSetsPointer") {
      PlayerSetsPointer.encode(message.event.playerSetsPointer, writer.uint32(66).fork()).ldelim();
    }
    if (message.event?.$case === "playerChats") {
      PlayerChats.encode(message.event.playerChats, writer.uint32(74).fork()).ldelim();
    }
    if (message.event?.$case === "playerInteracts") {
      PlayerInteracts.encode(message.event.playerInteracts, writer.uint32(82).fork()).ldelim();
    }
    if (message.event?.$case === "playerGhosts") {
      PlayerGhosts.encode(message.event.playerGhosts, writer.uint32(90).fork()).ldelim();
    }
    if (message.event?.$case === "playerEntersWhisper") {
      PlayerEntersWhisper.encode(
        message.event.playerEntersWhisper,
        writer.uint32(98).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerLeavesWhisper") {
      PlayerLeavesWhisper.encode(
        message.event.playerLeavesWhisper,
        writer.uint32(106).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerActivelySpeaks") {
      PlayerActivelySpeaks.encode(
        message.event.playerActivelySpeaks,
        writer.uint32(114).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerSetsEmote") {
      PlayerSetsEmote.encode(message.event.playerSetsEmote, writer.uint32(122).fork()).ldelim();
    }
    if (message.event?.$case === "playerSetsWorkCondition") {
      PlayerSetsWorkCondition.encode(
        message.event.playerSetsWorkCondition,
        writer.uint32(130).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerSetsName") {
      PlayerSetsName.encode(message.event.playerSetsName, writer.uint32(138).fork()).ldelim();
    }
    if (message.event?.$case === "playerSetsTextStatus") {
      PlayerSetsTextStatus.encode(
        message.event.playerSetsTextStatus,
        writer.uint32(146).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerSetsEmojiStatus") {
      PlayerSetsEmojiStatus.encode(
        message.event.playerSetsEmojiStatus,
        writer.uint32(154).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerSetsAffiliation") {
      PlayerSetsAffiliation.encode(
        message.event.playerSetsAffiliation,
        writer.uint32(162).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerExits") {
      PlayerExits.encode(message.event.playerExits, writer.uint32(170).fork()).ldelim();
    }
    if (message.event?.$case === "playerSetsSprite") {
      PlayerSetsSprite.encode(message.event.playerSetsSprite, writer.uint32(178).fork()).ldelim();
    }
    if (message.event?.$case === "respawnComplete") {
      RespawnComplete.encode(message.event.respawnComplete, writer.uint32(314).fork()).ldelim();
    }
    if (message.event?.$case === "playerSetsOutfitString") {
      PlayerSetsOutfitString.encode(
        message.event.playerSetsOutfitString,
        writer.uint32(322).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerSetsIsSignedIn") {
      PlayerSetsIsSignedIn.encode(
        message.event.playerSetsIsSignedIn,
        writer.uint32(330).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "mapUpdates") {
      MapUpdates.encode(message.event.mapUpdates, writer.uint32(338).fork()).ldelim();
    }
    if (message.event?.$case === "mapOverwrites") {
      MapOverwrites.encode(message.event.mapOverwrites, writer.uint32(346).fork()).ldelim();
    }
    if (message.event?.$case === "spaceOverwrites") {
      SpaceOverwrites.encode(message.event.spaceOverwrites, writer.uint32(354).fork()).ldelim();
    }
    if (message.event?.$case === "spaceIsClosed") {
      SpaceIsClosed.encode(message.event.spaceIsClosed, writer.uint32(362).fork()).ldelim();
    }
    if (message.event?.$case === "playerEntersPortal") {
      PlayerEntersPortal.encode(
        message.event.playerEntersPortal,
        writer.uint32(370).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "spaceSetsIdMapping") {
      SpaceSetsIdMapping.encode(
        message.event.spaceSetsIdMapping,
        writer.uint32(378).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerSetsLastActive") {
      PlayerSetsLastActive.encode(
        message.event.playerSetsLastActive,
        writer.uint32(386).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerShootsConfetti") {
      PlayerShootsConfetti.encode(
        message.event.playerShootsConfetti,
        writer.uint32(394).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerSetsEventStatus") {
      PlayerSetsEventStatus.encode(
        message.event.playerSetsEventStatus,
        writer.uint32(402).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerSetsInConversation") {
      PlayerSetsInConversation.encode(
        message.event.playerSetsInConversation,
        writer.uint32(410).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerSetsCurrentDesk") {
      PlayerSetsCurrentDesk.encode(
        message.event.playerSetsCurrentDesk,
        writer.uint32(418).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerSetsCurrentArea") {
      PlayerSetsCurrentArea.encode(
        message.event.playerSetsCurrentArea,
        writer.uint32(426).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerSetsImagePointer") {
      PlayerSetsImagePointer.encode(
        message.event.playerSetsImagePointer,
        writer.uint32(434).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "cookieFound") {
      CookieFound.encode(message.event.cookieFound, writer.uint32(442).fork()).ldelim();
    }
    if (message.event?.$case === "playerEntersWhisperV2") {
      PlayerEntersWhisperV2.encode(
        message.event.playerEntersWhisperV2,
        writer.uint32(450).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "playerSetsGoKartId") {
      PlayerSetsGoKartId.encode(
        message.event.playerSetsGoKartId,
        writer.uint32(458).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "mapSetDimensions") {
      MapSetDimensions.encode(message.event.mapSetDimensions, writer.uint32(466).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetCollisions") {
      MapSetCollisions.encode(message.event.mapSetCollisions, writer.uint32(474).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetBackgroundImagePath") {
      MapSetBackgroundImagePath.encode(
        message.event.mapSetBackgroundImagePath,
        writer.uint32(482).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "mapSetForegroundImagePath") {
      MapSetForegroundImagePath.encode(
        message.event.mapSetForegroundImagePath,
        writer.uint32(490).fork(),
      ).ldelim();
    }
    if (message.event?.$case === "mapSetSprites") {
      MapSetSprites.encode(message.event.mapSetSprites, writer.uint32(498).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetSpaces") {
      MapSetSpaces.encode(message.event.mapSetSpaces, writer.uint32(506).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetSpawns") {
      MapSetSpawns.encode(message.event.mapSetSpawns, writer.uint32(514).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetPortals") {
      MapSetPortals.encode(message.event.mapSetPortals, writer.uint32(522).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetAnnouncer") {
      MapSetAnnouncer.encode(message.event.mapSetAnnouncer, writer.uint32(530).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetAudio") {
      MapSetAudio.encode(message.event.mapSetAudio, writer.uint32(538).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetAnimations") {
      MapSetAnimations.encode(message.event.mapSetAnimations, writer.uint32(546).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetAssets") {
      MapSetAssets.encode(message.event.mapSetAssets, writer.uint32(554).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetObjects") {
      MapSetObjects.encode(message.event.mapSetObjects, writer.uint32(562).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetName") {
      MapSetName.encode(message.event.mapSetName, writer.uint32(570).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetDefaultChat") {
      MapSetDefaultChat.encode(message.event.mapSetDefaultChat, writer.uint32(578).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetMuteOnEntry") {
      MapSetMuteOnEntry.encode(message.event.mapSetMuteOnEntry, writer.uint32(586).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetUseDrawnBG") {
      MapSetUseDrawnBG.encode(message.event.mapSetUseDrawnBG, writer.uint32(594).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetWalls") {
      MapSetWalls.encode(message.event.mapSetWalls, writer.uint32(602).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetFloors") {
      MapSetFloors.encode(message.event.mapSetFloors, writer.uint32(610).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetAreas") {
      MapSetAreas.encode(message.event.mapSetAreas, writer.uint32(618).fork()).ldelim();
    }
    if (message.event?.$case === "mapDeleteObject") {
      MapDeleteObject.encode(message.event.mapDeleteObject, writer.uint32(626).fork()).ldelim();
    }
    if (message.event?.$case === "mapSetSpawn") {
      MapSetSpawn.encode(message.event.mapSetSpawn, writer.uint32(634).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServerClientEvent {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseServerClientEvent } as ServerClientEvent;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 100:
          message.event = { $case: "info", info: Info.decode(reader, reader.uint32()) };
          break;
        case 101:
          message.event = { $case: "warn", warn: Warn.decode(reader, reader.uint32()) };
          break;
        case 102:
          message.event = { $case: "error", error: Error.decode(reader, reader.uint32()) };
          break;
        case 103:
          message.event = { $case: "ready", ready: Ready.decode(reader, reader.uint32()) };
          break;
        case 105:
          message.event = {
            $case: "serverHeartbeat",
            serverHeartbeat: ServerHeartbeat.decode(reader, reader.uint32()),
          };
          break;
        case 106:
          message.event = {
            $case: "disableVideo",
            disableVideo: DisableVideo.decode(reader, reader.uint32()),
          };
          break;
        case 1:
          message.event = {
            $case: "playerMoves",
            playerMoves: PlayerMoves.decode(reader, reader.uint32()),
          };
          break;
        case 5:
          message.event = {
            $case: "playerSetsStatus",
            playerSetsStatus: PlayerSetsStatus.decode(reader, reader.uint32()),
          };
          break;
        case 6:
          message.event = {
            $case: "playerSpotlights",
            playerSpotlights: PlayerSpotlights.decode(reader, reader.uint32()),
          };
          break;
        case 7:
          message.event = {
            $case: "playerRings",
            playerRings: PlayerRings.decode(reader, reader.uint32()),
          };
          break;
        case 8:
          message.event = {
            $case: "playerSetsPointer",
            playerSetsPointer: PlayerSetsPointer.decode(reader, reader.uint32()),
          };
          break;
        case 9:
          message.event = {
            $case: "playerChats",
            playerChats: PlayerChats.decode(reader, reader.uint32()),
          };
          break;
        case 10:
          message.event = {
            $case: "playerInteracts",
            playerInteracts: PlayerInteracts.decode(reader, reader.uint32()),
          };
          break;
        case 11:
          message.event = {
            $case: "playerGhosts",
            playerGhosts: PlayerGhosts.decode(reader, reader.uint32()),
          };
          break;
        case 12:
          message.event = {
            $case: "playerEntersWhisper",
            playerEntersWhisper: PlayerEntersWhisper.decode(reader, reader.uint32()),
          };
          break;
        case 13:
          message.event = {
            $case: "playerLeavesWhisper",
            playerLeavesWhisper: PlayerLeavesWhisper.decode(reader, reader.uint32()),
          };
          break;
        case 14:
          message.event = {
            $case: "playerActivelySpeaks",
            playerActivelySpeaks: PlayerActivelySpeaks.decode(reader, reader.uint32()),
          };
          break;
        case 15:
          message.event = {
            $case: "playerSetsEmote",
            playerSetsEmote: PlayerSetsEmote.decode(reader, reader.uint32()),
          };
          break;
        case 16:
          message.event = {
            $case: "playerSetsWorkCondition",
            playerSetsWorkCondition: PlayerSetsWorkCondition.decode(reader, reader.uint32()),
          };
          break;
        case 17:
          message.event = {
            $case: "playerSetsName",
            playerSetsName: PlayerSetsName.decode(reader, reader.uint32()),
          };
          break;
        case 18:
          message.event = {
            $case: "playerSetsTextStatus",
            playerSetsTextStatus: PlayerSetsTextStatus.decode(reader, reader.uint32()),
          };
          break;
        case 19:
          message.event = {
            $case: "playerSetsEmojiStatus",
            playerSetsEmojiStatus: PlayerSetsEmojiStatus.decode(reader, reader.uint32()),
          };
          break;
        case 20:
          message.event = {
            $case: "playerSetsAffiliation",
            playerSetsAffiliation: PlayerSetsAffiliation.decode(reader, reader.uint32()),
          };
          break;
        case 21:
          message.event = {
            $case: "playerExits",
            playerExits: PlayerExits.decode(reader, reader.uint32()),
          };
          break;
        case 22:
          message.event = {
            $case: "playerSetsSprite",
            playerSetsSprite: PlayerSetsSprite.decode(reader, reader.uint32()),
          };
          break;
        case 39:
          message.event = {
            $case: "respawnComplete",
            respawnComplete: RespawnComplete.decode(reader, reader.uint32()),
          };
          break;
        case 40:
          message.event = {
            $case: "playerSetsOutfitString",
            playerSetsOutfitString: PlayerSetsOutfitString.decode(reader, reader.uint32()),
          };
          break;
        case 41:
          message.event = {
            $case: "playerSetsIsSignedIn",
            playerSetsIsSignedIn: PlayerSetsIsSignedIn.decode(reader, reader.uint32()),
          };
          break;
        case 42:
          message.event = {
            $case: "mapUpdates",
            mapUpdates: MapUpdates.decode(reader, reader.uint32()),
          };
          break;
        case 43:
          message.event = {
            $case: "mapOverwrites",
            mapOverwrites: MapOverwrites.decode(reader, reader.uint32()),
          };
          break;
        case 44:
          message.event = {
            $case: "spaceOverwrites",
            spaceOverwrites: SpaceOverwrites.decode(reader, reader.uint32()),
          };
          break;
        case 45:
          message.event = {
            $case: "spaceIsClosed",
            spaceIsClosed: SpaceIsClosed.decode(reader, reader.uint32()),
          };
          break;
        case 46:
          message.event = {
            $case: "playerEntersPortal",
            playerEntersPortal: PlayerEntersPortal.decode(reader, reader.uint32()),
          };
          break;
        case 47:
          message.event = {
            $case: "spaceSetsIdMapping",
            spaceSetsIdMapping: SpaceSetsIdMapping.decode(reader, reader.uint32()),
          };
          break;
        case 48:
          message.event = {
            $case: "playerSetsLastActive",
            playerSetsLastActive: PlayerSetsLastActive.decode(reader, reader.uint32()),
          };
          break;
        case 49:
          message.event = {
            $case: "playerShootsConfetti",
            playerShootsConfetti: PlayerShootsConfetti.decode(reader, reader.uint32()),
          };
          break;
        case 50:
          message.event = {
            $case: "playerSetsEventStatus",
            playerSetsEventStatus: PlayerSetsEventStatus.decode(reader, reader.uint32()),
          };
          break;
        case 51:
          message.event = {
            $case: "playerSetsInConversation",
            playerSetsInConversation: PlayerSetsInConversation.decode(reader, reader.uint32()),
          };
          break;
        case 52:
          message.event = {
            $case: "playerSetsCurrentDesk",
            playerSetsCurrentDesk: PlayerSetsCurrentDesk.decode(reader, reader.uint32()),
          };
          break;
        case 53:
          message.event = {
            $case: "playerSetsCurrentArea",
            playerSetsCurrentArea: PlayerSetsCurrentArea.decode(reader, reader.uint32()),
          };
          break;
        case 54:
          message.event = {
            $case: "playerSetsImagePointer",
            playerSetsImagePointer: PlayerSetsImagePointer.decode(reader, reader.uint32()),
          };
          break;
        case 55:
          message.event = {
            $case: "cookieFound",
            cookieFound: CookieFound.decode(reader, reader.uint32()),
          };
          break;
        case 56:
          message.event = {
            $case: "playerEntersWhisperV2",
            playerEntersWhisperV2: PlayerEntersWhisperV2.decode(reader, reader.uint32()),
          };
          break;
        case 57:
          message.event = {
            $case: "playerSetsGoKartId",
            playerSetsGoKartId: PlayerSetsGoKartId.decode(reader, reader.uint32()),
          };
          break;
        case 58:
          message.event = {
            $case: "mapSetDimensions",
            mapSetDimensions: MapSetDimensions.decode(reader, reader.uint32()),
          };
          break;
        case 59:
          message.event = {
            $case: "mapSetCollisions",
            mapSetCollisions: MapSetCollisions.decode(reader, reader.uint32()),
          };
          break;
        case 60:
          message.event = {
            $case: "mapSetBackgroundImagePath",
            mapSetBackgroundImagePath: MapSetBackgroundImagePath.decode(reader, reader.uint32()),
          };
          break;
        case 61:
          message.event = {
            $case: "mapSetForegroundImagePath",
            mapSetForegroundImagePath: MapSetForegroundImagePath.decode(reader, reader.uint32()),
          };
          break;
        case 62:
          message.event = {
            $case: "mapSetSprites",
            mapSetSprites: MapSetSprites.decode(reader, reader.uint32()),
          };
          break;
        case 63:
          message.event = {
            $case: "mapSetSpaces",
            mapSetSpaces: MapSetSpaces.decode(reader, reader.uint32()),
          };
          break;
        case 64:
          message.event = {
            $case: "mapSetSpawns",
            mapSetSpawns: MapSetSpawns.decode(reader, reader.uint32()),
          };
          break;
        case 65:
          message.event = {
            $case: "mapSetPortals",
            mapSetPortals: MapSetPortals.decode(reader, reader.uint32()),
          };
          break;
        case 66:
          message.event = {
            $case: "mapSetAnnouncer",
            mapSetAnnouncer: MapSetAnnouncer.decode(reader, reader.uint32()),
          };
          break;
        case 67:
          message.event = {
            $case: "mapSetAudio",
            mapSetAudio: MapSetAudio.decode(reader, reader.uint32()),
          };
          break;
        case 68:
          message.event = {
            $case: "mapSetAnimations",
            mapSetAnimations: MapSetAnimations.decode(reader, reader.uint32()),
          };
          break;
        case 69:
          message.event = {
            $case: "mapSetAssets",
            mapSetAssets: MapSetAssets.decode(reader, reader.uint32()),
          };
          break;
        case 70:
          message.event = {
            $case: "mapSetObjects",
            mapSetObjects: MapSetObjects.decode(reader, reader.uint32()),
          };
          break;
        case 71:
          message.event = {
            $case: "mapSetName",
            mapSetName: MapSetName.decode(reader, reader.uint32()),
          };
          break;
        case 72:
          message.event = {
            $case: "mapSetDefaultChat",
            mapSetDefaultChat: MapSetDefaultChat.decode(reader, reader.uint32()),
          };
          break;
        case 73:
          message.event = {
            $case: "mapSetMuteOnEntry",
            mapSetMuteOnEntry: MapSetMuteOnEntry.decode(reader, reader.uint32()),
          };
          break;
        case 74:
          message.event = {
            $case: "mapSetUseDrawnBG",
            mapSetUseDrawnBG: MapSetUseDrawnBG.decode(reader, reader.uint32()),
          };
          break;
        case 75:
          message.event = {
            $case: "mapSetWalls",
            mapSetWalls: MapSetWalls.decode(reader, reader.uint32()),
          };
          break;
        case 76:
          message.event = {
            $case: "mapSetFloors",
            mapSetFloors: MapSetFloors.decode(reader, reader.uint32()),
          };
          break;
        case 77:
          message.event = {
            $case: "mapSetAreas",
            mapSetAreas: MapSetAreas.decode(reader, reader.uint32()),
          };
          break;
        case 78:
          message.event = {
            $case: "mapDeleteObject",
            mapDeleteObject: MapDeleteObject.decode(reader, reader.uint32()),
          };
          break;
        case 79:
          message.event = {
            $case: "mapSetSpawn",
            mapSetSpawn: MapSetSpawn.decode(reader, reader.uint32()),
          };
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ServerClientEvent {
    const message = { ...baseServerClientEvent } as ServerClientEvent;
    if (object.info !== undefined && object.info !== null) {
      message.event = { $case: "info", info: Info.fromJSON(object.info) };
    }
    if (object.warn !== undefined && object.warn !== null) {
      message.event = { $case: "warn", warn: Warn.fromJSON(object.warn) };
    }
    if (object.error !== undefined && object.error !== null) {
      message.event = { $case: "error", error: Error.fromJSON(object.error) };
    }
    if (object.ready !== undefined && object.ready !== null) {
      message.event = { $case: "ready", ready: Ready.fromJSON(object.ready) };
    }
    if (object.serverHeartbeat !== undefined && object.serverHeartbeat !== null) {
      message.event = {
        $case: "serverHeartbeat",
        serverHeartbeat: ServerHeartbeat.fromJSON(object.serverHeartbeat),
      };
    }
    if (object.disableVideo !== undefined && object.disableVideo !== null) {
      message.event = {
        $case: "disableVideo",
        disableVideo: DisableVideo.fromJSON(object.disableVideo),
      };
    }
    if (object.playerMoves !== undefined && object.playerMoves !== null) {
      message.event = {
        $case: "playerMoves",
        playerMoves: PlayerMoves.fromJSON(object.playerMoves),
      };
    }
    if (object.playerSetsStatus !== undefined && object.playerSetsStatus !== null) {
      message.event = {
        $case: "playerSetsStatus",
        playerSetsStatus: PlayerSetsStatus.fromJSON(object.playerSetsStatus),
      };
    }
    if (object.playerSpotlights !== undefined && object.playerSpotlights !== null) {
      message.event = {
        $case: "playerSpotlights",
        playerSpotlights: PlayerSpotlights.fromJSON(object.playerSpotlights),
      };
    }
    if (object.playerRings !== undefined && object.playerRings !== null) {
      message.event = {
        $case: "playerRings",
        playerRings: PlayerRings.fromJSON(object.playerRings),
      };
    }
    if (object.playerSetsPointer !== undefined && object.playerSetsPointer !== null) {
      message.event = {
        $case: "playerSetsPointer",
        playerSetsPointer: PlayerSetsPointer.fromJSON(object.playerSetsPointer),
      };
    }
    if (object.playerChats !== undefined && object.playerChats !== null) {
      message.event = {
        $case: "playerChats",
        playerChats: PlayerChats.fromJSON(object.playerChats),
      };
    }
    if (object.playerInteracts !== undefined && object.playerInteracts !== null) {
      message.event = {
        $case: "playerInteracts",
        playerInteracts: PlayerInteracts.fromJSON(object.playerInteracts),
      };
    }
    if (object.playerGhosts !== undefined && object.playerGhosts !== null) {
      message.event = {
        $case: "playerGhosts",
        playerGhosts: PlayerGhosts.fromJSON(object.playerGhosts),
      };
    }
    if (object.playerEntersWhisper !== undefined && object.playerEntersWhisper !== null) {
      message.event = {
        $case: "playerEntersWhisper",
        playerEntersWhisper: PlayerEntersWhisper.fromJSON(object.playerEntersWhisper),
      };
    }
    if (object.playerLeavesWhisper !== undefined && object.playerLeavesWhisper !== null) {
      message.event = {
        $case: "playerLeavesWhisper",
        playerLeavesWhisper: PlayerLeavesWhisper.fromJSON(object.playerLeavesWhisper),
      };
    }
    if (object.playerActivelySpeaks !== undefined && object.playerActivelySpeaks !== null) {
      message.event = {
        $case: "playerActivelySpeaks",
        playerActivelySpeaks: PlayerActivelySpeaks.fromJSON(object.playerActivelySpeaks),
      };
    }
    if (object.playerSetsEmote !== undefined && object.playerSetsEmote !== null) {
      message.event = {
        $case: "playerSetsEmote",
        playerSetsEmote: PlayerSetsEmote.fromJSON(object.playerSetsEmote),
      };
    }
    if (object.playerSetsWorkCondition !== undefined && object.playerSetsWorkCondition !== null) {
      message.event = {
        $case: "playerSetsWorkCondition",
        playerSetsWorkCondition: PlayerSetsWorkCondition.fromJSON(object.playerSetsWorkCondition),
      };
    }
    if (object.playerSetsName !== undefined && object.playerSetsName !== null) {
      message.event = {
        $case: "playerSetsName",
        playerSetsName: PlayerSetsName.fromJSON(object.playerSetsName),
      };
    }
    if (object.playerSetsTextStatus !== undefined && object.playerSetsTextStatus !== null) {
      message.event = {
        $case: "playerSetsTextStatus",
        playerSetsTextStatus: PlayerSetsTextStatus.fromJSON(object.playerSetsTextStatus),
      };
    }
    if (object.playerSetsEmojiStatus !== undefined && object.playerSetsEmojiStatus !== null) {
      message.event = {
        $case: "playerSetsEmojiStatus",
        playerSetsEmojiStatus: PlayerSetsEmojiStatus.fromJSON(object.playerSetsEmojiStatus),
      };
    }
    if (object.playerSetsAffiliation !== undefined && object.playerSetsAffiliation !== null) {
      message.event = {
        $case: "playerSetsAffiliation",
        playerSetsAffiliation: PlayerSetsAffiliation.fromJSON(object.playerSetsAffiliation),
      };
    }
    if (object.playerExits !== undefined && object.playerExits !== null) {
      message.event = {
        $case: "playerExits",
        playerExits: PlayerExits.fromJSON(object.playerExits),
      };
    }
    if (object.playerSetsSprite !== undefined && object.playerSetsSprite !== null) {
      message.event = {
        $case: "playerSetsSprite",
        playerSetsSprite: PlayerSetsSprite.fromJSON(object.playerSetsSprite),
      };
    }
    if (object.respawnComplete !== undefined && object.respawnComplete !== null) {
      message.event = {
        $case: "respawnComplete",
        respawnComplete: RespawnComplete.fromJSON(object.respawnComplete),
      };
    }
    if (object.playerSetsOutfitString !== undefined && object.playerSetsOutfitString !== null) {
      message.event = {
        $case: "playerSetsOutfitString",
        playerSetsOutfitString: PlayerSetsOutfitString.fromJSON(object.playerSetsOutfitString),
      };
    }
    if (object.playerSetsIsSignedIn !== undefined && object.playerSetsIsSignedIn !== null) {
      message.event = {
        $case: "playerSetsIsSignedIn",
        playerSetsIsSignedIn: PlayerSetsIsSignedIn.fromJSON(object.playerSetsIsSignedIn),
      };
    }
    if (object.mapUpdates !== undefined && object.mapUpdates !== null) {
      message.event = { $case: "mapUpdates", mapUpdates: MapUpdates.fromJSON(object.mapUpdates) };
    }
    if (object.mapOverwrites !== undefined && object.mapOverwrites !== null) {
      message.event = {
        $case: "mapOverwrites",
        mapOverwrites: MapOverwrites.fromJSON(object.mapOverwrites),
      };
    }
    if (object.spaceOverwrites !== undefined && object.spaceOverwrites !== null) {
      message.event = {
        $case: "spaceOverwrites",
        spaceOverwrites: SpaceOverwrites.fromJSON(object.spaceOverwrites),
      };
    }
    if (object.spaceIsClosed !== undefined && object.spaceIsClosed !== null) {
      message.event = {
        $case: "spaceIsClosed",
        spaceIsClosed: SpaceIsClosed.fromJSON(object.spaceIsClosed),
      };
    }
    if (object.playerEntersPortal !== undefined && object.playerEntersPortal !== null) {
      message.event = {
        $case: "playerEntersPortal",
        playerEntersPortal: PlayerEntersPortal.fromJSON(object.playerEntersPortal),
      };
    }
    if (object.spaceSetsIdMapping !== undefined && object.spaceSetsIdMapping !== null) {
      message.event = {
        $case: "spaceSetsIdMapping",
        spaceSetsIdMapping: SpaceSetsIdMapping.fromJSON(object.spaceSetsIdMapping),
      };
    }
    if (object.playerSetsLastActive !== undefined && object.playerSetsLastActive !== null) {
      message.event = {
        $case: "playerSetsLastActive",
        playerSetsLastActive: PlayerSetsLastActive.fromJSON(object.playerSetsLastActive),
      };
    }
    if (object.playerShootsConfetti !== undefined && object.playerShootsConfetti !== null) {
      message.event = {
        $case: "playerShootsConfetti",
        playerShootsConfetti: PlayerShootsConfetti.fromJSON(object.playerShootsConfetti),
      };
    }
    if (object.playerSetsEventStatus !== undefined && object.playerSetsEventStatus !== null) {
      message.event = {
        $case: "playerSetsEventStatus",
        playerSetsEventStatus: PlayerSetsEventStatus.fromJSON(object.playerSetsEventStatus),
      };
    }
    if (object.playerSetsInConversation !== undefined && object.playerSetsInConversation !== null) {
      message.event = {
        $case: "playerSetsInConversation",
        playerSetsInConversation: PlayerSetsInConversation.fromJSON(
          object.playerSetsInConversation,
        ),
      };
    }
    if (object.playerSetsCurrentDesk !== undefined && object.playerSetsCurrentDesk !== null) {
      message.event = {
        $case: "playerSetsCurrentDesk",
        playerSetsCurrentDesk: PlayerSetsCurrentDesk.fromJSON(object.playerSetsCurrentDesk),
      };
    }
    if (object.playerSetsCurrentArea !== undefined && object.playerSetsCurrentArea !== null) {
      message.event = {
        $case: "playerSetsCurrentArea",
        playerSetsCurrentArea: PlayerSetsCurrentArea.fromJSON(object.playerSetsCurrentArea),
      };
    }
    if (object.playerSetsImagePointer !== undefined && object.playerSetsImagePointer !== null) {
      message.event = {
        $case: "playerSetsImagePointer",
        playerSetsImagePointer: PlayerSetsImagePointer.fromJSON(object.playerSetsImagePointer),
      };
    }
    if (object.cookieFound !== undefined && object.cookieFound !== null) {
      message.event = {
        $case: "cookieFound",
        cookieFound: CookieFound.fromJSON(object.cookieFound),
      };
    }
    if (object.playerEntersWhisperV2 !== undefined && object.playerEntersWhisperV2 !== null) {
      message.event = {
        $case: "playerEntersWhisperV2",
        playerEntersWhisperV2: PlayerEntersWhisperV2.fromJSON(object.playerEntersWhisperV2),
      };
    }
    if (object.playerSetsGoKartId !== undefined && object.playerSetsGoKartId !== null) {
      message.event = {
        $case: "playerSetsGoKartId",
        playerSetsGoKartId: PlayerSetsGoKartId.fromJSON(object.playerSetsGoKartId),
      };
    }
    if (object.mapSetDimensions !== undefined && object.mapSetDimensions !== null) {
      message.event = {
        $case: "mapSetDimensions",
        mapSetDimensions: MapSetDimensions.fromJSON(object.mapSetDimensions),
      };
    }
    if (object.mapSetCollisions !== undefined && object.mapSetCollisions !== null) {
      message.event = {
        $case: "mapSetCollisions",
        mapSetCollisions: MapSetCollisions.fromJSON(object.mapSetCollisions),
      };
    }
    if (
      object.mapSetBackgroundImagePath !== undefined &&
      object.mapSetBackgroundImagePath !== null
    ) {
      message.event = {
        $case: "mapSetBackgroundImagePath",
        mapSetBackgroundImagePath: MapSetBackgroundImagePath.fromJSON(
          object.mapSetBackgroundImagePath,
        ),
      };
    }
    if (
      object.mapSetForegroundImagePath !== undefined &&
      object.mapSetForegroundImagePath !== null
    ) {
      message.event = {
        $case: "mapSetForegroundImagePath",
        mapSetForegroundImagePath: MapSetForegroundImagePath.fromJSON(
          object.mapSetForegroundImagePath,
        ),
      };
    }
    if (object.mapSetSprites !== undefined && object.mapSetSprites !== null) {
      message.event = {
        $case: "mapSetSprites",
        mapSetSprites: MapSetSprites.fromJSON(object.mapSetSprites),
      };
    }
    if (object.mapSetSpaces !== undefined && object.mapSetSpaces !== null) {
      message.event = {
        $case: "mapSetSpaces",
        mapSetSpaces: MapSetSpaces.fromJSON(object.mapSetSpaces),
      };
    }
    if (object.mapSetSpawns !== undefined && object.mapSetSpawns !== null) {
      message.event = {
        $case: "mapSetSpawns",
        mapSetSpawns: MapSetSpawns.fromJSON(object.mapSetSpawns),
      };
    }
    if (object.mapSetPortals !== undefined && object.mapSetPortals !== null) {
      message.event = {
        $case: "mapSetPortals",
        mapSetPortals: MapSetPortals.fromJSON(object.mapSetPortals),
      };
    }
    if (object.mapSetAnnouncer !== undefined && object.mapSetAnnouncer !== null) {
      message.event = {
        $case: "mapSetAnnouncer",
        mapSetAnnouncer: MapSetAnnouncer.fromJSON(object.mapSetAnnouncer),
      };
    }
    if (object.mapSetAudio !== undefined && object.mapSetAudio !== null) {
      message.event = {
        $case: "mapSetAudio",
        mapSetAudio: MapSetAudio.fromJSON(object.mapSetAudio),
      };
    }
    if (object.mapSetAnimations !== undefined && object.mapSetAnimations !== null) {
      message.event = {
        $case: "mapSetAnimations",
        mapSetAnimations: MapSetAnimations.fromJSON(object.mapSetAnimations),
      };
    }
    if (object.mapSetAssets !== undefined && object.mapSetAssets !== null) {
      message.event = {
        $case: "mapSetAssets",
        mapSetAssets: MapSetAssets.fromJSON(object.mapSetAssets),
      };
    }
    if (object.mapSetObjects !== undefined && object.mapSetObjects !== null) {
      message.event = {
        $case: "mapSetObjects",
        mapSetObjects: MapSetObjects.fromJSON(object.mapSetObjects),
      };
    }
    if (object.mapSetName !== undefined && object.mapSetName !== null) {
      message.event = { $case: "mapSetName", mapSetName: MapSetName.fromJSON(object.mapSetName) };
    }
    if (object.mapSetDefaultChat !== undefined && object.mapSetDefaultChat !== null) {
      message.event = {
        $case: "mapSetDefaultChat",
        mapSetDefaultChat: MapSetDefaultChat.fromJSON(object.mapSetDefaultChat),
      };
    }
    if (object.mapSetMuteOnEntry !== undefined && object.mapSetMuteOnEntry !== null) {
      message.event = {
        $case: "mapSetMuteOnEntry",
        mapSetMuteOnEntry: MapSetMuteOnEntry.fromJSON(object.mapSetMuteOnEntry),
      };
    }
    if (object.mapSetUseDrawnBG !== undefined && object.mapSetUseDrawnBG !== null) {
      message.event = {
        $case: "mapSetUseDrawnBG",
        mapSetUseDrawnBG: MapSetUseDrawnBG.fromJSON(object.mapSetUseDrawnBG),
      };
    }
    if (object.mapSetWalls !== undefined && object.mapSetWalls !== null) {
      message.event = {
        $case: "mapSetWalls",
        mapSetWalls: MapSetWalls.fromJSON(object.mapSetWalls),
      };
    }
    if (object.mapSetFloors !== undefined && object.mapSetFloors !== null) {
      message.event = {
        $case: "mapSetFloors",
        mapSetFloors: MapSetFloors.fromJSON(object.mapSetFloors),
      };
    }
    if (object.mapSetAreas !== undefined && object.mapSetAreas !== null) {
      message.event = {
        $case: "mapSetAreas",
        mapSetAreas: MapSetAreas.fromJSON(object.mapSetAreas),
      };
    }
    if (object.mapDeleteObject !== undefined && object.mapDeleteObject !== null) {
      message.event = {
        $case: "mapDeleteObject",
        mapDeleteObject: MapDeleteObject.fromJSON(object.mapDeleteObject),
      };
    }
    if (object.mapSetSpawn !== undefined && object.mapSetSpawn !== null) {
      message.event = {
        $case: "mapSetSpawn",
        mapSetSpawn: MapSetSpawn.fromJSON(object.mapSetSpawn),
      };
    }
    return message;
  },

  toJSON(message: ServerClientEvent): unknown {
    const obj: any = {};
    message.event?.$case === "info" &&
      (obj.info = message.event?.info ? Info.toJSON(message.event?.info) : undefined);
    message.event?.$case === "warn" &&
      (obj.warn = message.event?.warn ? Warn.toJSON(message.event?.warn) : undefined);
    message.event?.$case === "error" &&
      (obj.error = message.event?.error ? Error.toJSON(message.event?.error) : undefined);
    message.event?.$case === "ready" &&
      (obj.ready = message.event?.ready ? Ready.toJSON(message.event?.ready) : undefined);
    message.event?.$case === "serverHeartbeat" &&
      (obj.serverHeartbeat = message.event?.serverHeartbeat
        ? ServerHeartbeat.toJSON(message.event?.serverHeartbeat)
        : undefined);
    message.event?.$case === "disableVideo" &&
      (obj.disableVideo = message.event?.disableVideo
        ? DisableVideo.toJSON(message.event?.disableVideo)
        : undefined);
    message.event?.$case === "playerMoves" &&
      (obj.playerMoves = message.event?.playerMoves
        ? PlayerMoves.toJSON(message.event?.playerMoves)
        : undefined);
    message.event?.$case === "playerSetsStatus" &&
      (obj.playerSetsStatus = message.event?.playerSetsStatus
        ? PlayerSetsStatus.toJSON(message.event?.playerSetsStatus)
        : undefined);
    message.event?.$case === "playerSpotlights" &&
      (obj.playerSpotlights = message.event?.playerSpotlights
        ? PlayerSpotlights.toJSON(message.event?.playerSpotlights)
        : undefined);
    message.event?.$case === "playerRings" &&
      (obj.playerRings = message.event?.playerRings
        ? PlayerRings.toJSON(message.event?.playerRings)
        : undefined);
    message.event?.$case === "playerSetsPointer" &&
      (obj.playerSetsPointer = message.event?.playerSetsPointer
        ? PlayerSetsPointer.toJSON(message.event?.playerSetsPointer)
        : undefined);
    message.event?.$case === "playerChats" &&
      (obj.playerChats = message.event?.playerChats
        ? PlayerChats.toJSON(message.event?.playerChats)
        : undefined);
    message.event?.$case === "playerInteracts" &&
      (obj.playerInteracts = message.event?.playerInteracts
        ? PlayerInteracts.toJSON(message.event?.playerInteracts)
        : undefined);
    message.event?.$case === "playerGhosts" &&
      (obj.playerGhosts = message.event?.playerGhosts
        ? PlayerGhosts.toJSON(message.event?.playerGhosts)
        : undefined);
    message.event?.$case === "playerEntersWhisper" &&
      (obj.playerEntersWhisper = message.event?.playerEntersWhisper
        ? PlayerEntersWhisper.toJSON(message.event?.playerEntersWhisper)
        : undefined);
    message.event?.$case === "playerLeavesWhisper" &&
      (obj.playerLeavesWhisper = message.event?.playerLeavesWhisper
        ? PlayerLeavesWhisper.toJSON(message.event?.playerLeavesWhisper)
        : undefined);
    message.event?.$case === "playerActivelySpeaks" &&
      (obj.playerActivelySpeaks = message.event?.playerActivelySpeaks
        ? PlayerActivelySpeaks.toJSON(message.event?.playerActivelySpeaks)
        : undefined);
    message.event?.$case === "playerSetsEmote" &&
      (obj.playerSetsEmote = message.event?.playerSetsEmote
        ? PlayerSetsEmote.toJSON(message.event?.playerSetsEmote)
        : undefined);
    message.event?.$case === "playerSetsWorkCondition" &&
      (obj.playerSetsWorkCondition = message.event?.playerSetsWorkCondition
        ? PlayerSetsWorkCondition.toJSON(message.event?.playerSetsWorkCondition)
        : undefined);
    message.event?.$case === "playerSetsName" &&
      (obj.playerSetsName = message.event?.playerSetsName
        ? PlayerSetsName.toJSON(message.event?.playerSetsName)
        : undefined);
    message.event?.$case === "playerSetsTextStatus" &&
      (obj.playerSetsTextStatus = message.event?.playerSetsTextStatus
        ? PlayerSetsTextStatus.toJSON(message.event?.playerSetsTextStatus)
        : undefined);
    message.event?.$case === "playerSetsEmojiStatus" &&
      (obj.playerSetsEmojiStatus = message.event?.playerSetsEmojiStatus
        ? PlayerSetsEmojiStatus.toJSON(message.event?.playerSetsEmojiStatus)
        : undefined);
    message.event?.$case === "playerSetsAffiliation" &&
      (obj.playerSetsAffiliation = message.event?.playerSetsAffiliation
        ? PlayerSetsAffiliation.toJSON(message.event?.playerSetsAffiliation)
        : undefined);
    message.event?.$case === "playerExits" &&
      (obj.playerExits = message.event?.playerExits
        ? PlayerExits.toJSON(message.event?.playerExits)
        : undefined);
    message.event?.$case === "playerSetsSprite" &&
      (obj.playerSetsSprite = message.event?.playerSetsSprite
        ? PlayerSetsSprite.toJSON(message.event?.playerSetsSprite)
        : undefined);
    message.event?.$case === "respawnComplete" &&
      (obj.respawnComplete = message.event?.respawnComplete
        ? RespawnComplete.toJSON(message.event?.respawnComplete)
        : undefined);
    message.event?.$case === "playerSetsOutfitString" &&
      (obj.playerSetsOutfitString = message.event?.playerSetsOutfitString
        ? PlayerSetsOutfitString.toJSON(message.event?.playerSetsOutfitString)
        : undefined);
    message.event?.$case === "playerSetsIsSignedIn" &&
      (obj.playerSetsIsSignedIn = message.event?.playerSetsIsSignedIn
        ? PlayerSetsIsSignedIn.toJSON(message.event?.playerSetsIsSignedIn)
        : undefined);
    message.event?.$case === "mapUpdates" &&
      (obj.mapUpdates = message.event?.mapUpdates
        ? MapUpdates.toJSON(message.event?.mapUpdates)
        : undefined);
    message.event?.$case === "mapOverwrites" &&
      (obj.mapOverwrites = message.event?.mapOverwrites
        ? MapOverwrites.toJSON(message.event?.mapOverwrites)
        : undefined);
    message.event?.$case === "spaceOverwrites" &&
      (obj.spaceOverwrites = message.event?.spaceOverwrites
        ? SpaceOverwrites.toJSON(message.event?.spaceOverwrites)
        : undefined);
    message.event?.$case === "spaceIsClosed" &&
      (obj.spaceIsClosed = message.event?.spaceIsClosed
        ? SpaceIsClosed.toJSON(message.event?.spaceIsClosed)
        : undefined);
    message.event?.$case === "playerEntersPortal" &&
      (obj.playerEntersPortal = message.event?.playerEntersPortal
        ? PlayerEntersPortal.toJSON(message.event?.playerEntersPortal)
        : undefined);
    message.event?.$case === "spaceSetsIdMapping" &&
      (obj.spaceSetsIdMapping = message.event?.spaceSetsIdMapping
        ? SpaceSetsIdMapping.toJSON(message.event?.spaceSetsIdMapping)
        : undefined);
    message.event?.$case === "playerSetsLastActive" &&
      (obj.playerSetsLastActive = message.event?.playerSetsLastActive
        ? PlayerSetsLastActive.toJSON(message.event?.playerSetsLastActive)
        : undefined);
    message.event?.$case === "playerShootsConfetti" &&
      (obj.playerShootsConfetti = message.event?.playerShootsConfetti
        ? PlayerShootsConfetti.toJSON(message.event?.playerShootsConfetti)
        : undefined);
    message.event?.$case === "playerSetsEventStatus" &&
      (obj.playerSetsEventStatus = message.event?.playerSetsEventStatus
        ? PlayerSetsEventStatus.toJSON(message.event?.playerSetsEventStatus)
        : undefined);
    message.event?.$case === "playerSetsInConversation" &&
      (obj.playerSetsInConversation = message.event?.playerSetsInConversation
        ? PlayerSetsInConversation.toJSON(message.event?.playerSetsInConversation)
        : undefined);
    message.event?.$case === "playerSetsCurrentDesk" &&
      (obj.playerSetsCurrentDesk = message.event?.playerSetsCurrentDesk
        ? PlayerSetsCurrentDesk.toJSON(message.event?.playerSetsCurrentDesk)
        : undefined);
    message.event?.$case === "playerSetsCurrentArea" &&
      (obj.playerSetsCurrentArea = message.event?.playerSetsCurrentArea
        ? PlayerSetsCurrentArea.toJSON(message.event?.playerSetsCurrentArea)
        : undefined);
    message.event?.$case === "playerSetsImagePointer" &&
      (obj.playerSetsImagePointer = message.event?.playerSetsImagePointer
        ? PlayerSetsImagePointer.toJSON(message.event?.playerSetsImagePointer)
        : undefined);
    message.event?.$case === "cookieFound" &&
      (obj.cookieFound = message.event?.cookieFound
        ? CookieFound.toJSON(message.event?.cookieFound)
        : undefined);
    message.event?.$case === "playerEntersWhisperV2" &&
      (obj.playerEntersWhisperV2 = message.event?.playerEntersWhisperV2
        ? PlayerEntersWhisperV2.toJSON(message.event?.playerEntersWhisperV2)
        : undefined);
    message.event?.$case === "playerSetsGoKartId" &&
      (obj.playerSetsGoKartId = message.event?.playerSetsGoKartId
        ? PlayerSetsGoKartId.toJSON(message.event?.playerSetsGoKartId)
        : undefined);
    message.event?.$case === "mapSetDimensions" &&
      (obj.mapSetDimensions = message.event?.mapSetDimensions
        ? MapSetDimensions.toJSON(message.event?.mapSetDimensions)
        : undefined);
    message.event?.$case === "mapSetCollisions" &&
      (obj.mapSetCollisions = message.event?.mapSetCollisions
        ? MapSetCollisions.toJSON(message.event?.mapSetCollisions)
        : undefined);
    message.event?.$case === "mapSetBackgroundImagePath" &&
      (obj.mapSetBackgroundImagePath = message.event?.mapSetBackgroundImagePath
        ? MapSetBackgroundImagePath.toJSON(message.event?.mapSetBackgroundImagePath)
        : undefined);
    message.event?.$case === "mapSetForegroundImagePath" &&
      (obj.mapSetForegroundImagePath = message.event?.mapSetForegroundImagePath
        ? MapSetForegroundImagePath.toJSON(message.event?.mapSetForegroundImagePath)
        : undefined);
    message.event?.$case === "mapSetSprites" &&
      (obj.mapSetSprites = message.event?.mapSetSprites
        ? MapSetSprites.toJSON(message.event?.mapSetSprites)
        : undefined);
    message.event?.$case === "mapSetSpaces" &&
      (obj.mapSetSpaces = message.event?.mapSetSpaces
        ? MapSetSpaces.toJSON(message.event?.mapSetSpaces)
        : undefined);
    message.event?.$case === "mapSetSpawns" &&
      (obj.mapSetSpawns = message.event?.mapSetSpawns
        ? MapSetSpawns.toJSON(message.event?.mapSetSpawns)
        : undefined);
    message.event?.$case === "mapSetPortals" &&
      (obj.mapSetPortals = message.event?.mapSetPortals
        ? MapSetPortals.toJSON(message.event?.mapSetPortals)
        : undefined);
    message.event?.$case === "mapSetAnnouncer" &&
      (obj.mapSetAnnouncer = message.event?.mapSetAnnouncer
        ? MapSetAnnouncer.toJSON(message.event?.mapSetAnnouncer)
        : undefined);
    message.event?.$case === "mapSetAudio" &&
      (obj.mapSetAudio = message.event?.mapSetAudio
        ? MapSetAudio.toJSON(message.event?.mapSetAudio)
        : undefined);
    message.event?.$case === "mapSetAnimations" &&
      (obj.mapSetAnimations = message.event?.mapSetAnimations
        ? MapSetAnimations.toJSON(message.event?.mapSetAnimations)
        : undefined);
    message.event?.$case === "mapSetAssets" &&
      (obj.mapSetAssets = message.event?.mapSetAssets
        ? MapSetAssets.toJSON(message.event?.mapSetAssets)
        : undefined);
    message.event?.$case === "mapSetObjects" &&
      (obj.mapSetObjects = message.event?.mapSetObjects
        ? MapSetObjects.toJSON(message.event?.mapSetObjects)
        : undefined);
    message.event?.$case === "mapSetName" &&
      (obj.mapSetName = message.event?.mapSetName
        ? MapSetName.toJSON(message.event?.mapSetName)
        : undefined);
    message.event?.$case === "mapSetDefaultChat" &&
      (obj.mapSetDefaultChat = message.event?.mapSetDefaultChat
        ? MapSetDefaultChat.toJSON(message.event?.mapSetDefaultChat)
        : undefined);
    message.event?.$case === "mapSetMuteOnEntry" &&
      (obj.mapSetMuteOnEntry = message.event?.mapSetMuteOnEntry
        ? MapSetMuteOnEntry.toJSON(message.event?.mapSetMuteOnEntry)
        : undefined);
    message.event?.$case === "mapSetUseDrawnBG" &&
      (obj.mapSetUseDrawnBG = message.event?.mapSetUseDrawnBG
        ? MapSetUseDrawnBG.toJSON(message.event?.mapSetUseDrawnBG)
        : undefined);
    message.event?.$case === "mapSetWalls" &&
      (obj.mapSetWalls = message.event?.mapSetWalls
        ? MapSetWalls.toJSON(message.event?.mapSetWalls)
        : undefined);
    message.event?.$case === "mapSetFloors" &&
      (obj.mapSetFloors = message.event?.mapSetFloors
        ? MapSetFloors.toJSON(message.event?.mapSetFloors)
        : undefined);
    message.event?.$case === "mapSetAreas" &&
      (obj.mapSetAreas = message.event?.mapSetAreas
        ? MapSetAreas.toJSON(message.event?.mapSetAreas)
        : undefined);
    message.event?.$case === "mapDeleteObject" &&
      (obj.mapDeleteObject = message.event?.mapDeleteObject
        ? MapDeleteObject.toJSON(message.event?.mapDeleteObject)
        : undefined);
    message.event?.$case === "mapSetSpawn" &&
      (obj.mapSetSpawn = message.event?.mapSetSpawn
        ? MapSetSpawn.toJSON(message.event?.mapSetSpawn)
        : undefined);
    return obj;
  },

  fromPartial(object: DeepPartial<ServerClientEvent>): ServerClientEvent {
    const message = { ...baseServerClientEvent } as ServerClientEvent;
    if (
      object.event?.$case === "info" &&
      object.event?.info !== undefined &&
      object.event?.info !== null
    ) {
      message.event = { $case: "info", info: Info.fromPartial(object.event.info) };
    }
    if (
      object.event?.$case === "warn" &&
      object.event?.warn !== undefined &&
      object.event?.warn !== null
    ) {
      message.event = { $case: "warn", warn: Warn.fromPartial(object.event.warn) };
    }
    if (
      object.event?.$case === "error" &&
      object.event?.error !== undefined &&
      object.event?.error !== null
    ) {
      message.event = { $case: "error", error: Error.fromPartial(object.event.error) };
    }
    if (
      object.event?.$case === "ready" &&
      object.event?.ready !== undefined &&
      object.event?.ready !== null
    ) {
      message.event = { $case: "ready", ready: Ready.fromPartial(object.event.ready) };
    }
    if (
      object.event?.$case === "serverHeartbeat" &&
      object.event?.serverHeartbeat !== undefined &&
      object.event?.serverHeartbeat !== null
    ) {
      message.event = {
        $case: "serverHeartbeat",
        serverHeartbeat: ServerHeartbeat.fromPartial(object.event.serverHeartbeat),
      };
    }
    if (
      object.event?.$case === "disableVideo" &&
      object.event?.disableVideo !== undefined &&
      object.event?.disableVideo !== null
    ) {
      message.event = {
        $case: "disableVideo",
        disableVideo: DisableVideo.fromPartial(object.event.disableVideo),
      };
    }
    if (
      object.event?.$case === "playerMoves" &&
      object.event?.playerMoves !== undefined &&
      object.event?.playerMoves !== null
    ) {
      message.event = {
        $case: "playerMoves",
        playerMoves: PlayerMoves.fromPartial(object.event.playerMoves),
      };
    }
    if (
      object.event?.$case === "playerSetsStatus" &&
      object.event?.playerSetsStatus !== undefined &&
      object.event?.playerSetsStatus !== null
    ) {
      message.event = {
        $case: "playerSetsStatus",
        playerSetsStatus: PlayerSetsStatus.fromPartial(object.event.playerSetsStatus),
      };
    }
    if (
      object.event?.$case === "playerSpotlights" &&
      object.event?.playerSpotlights !== undefined &&
      object.event?.playerSpotlights !== null
    ) {
      message.event = {
        $case: "playerSpotlights",
        playerSpotlights: PlayerSpotlights.fromPartial(object.event.playerSpotlights),
      };
    }
    if (
      object.event?.$case === "playerRings" &&
      object.event?.playerRings !== undefined &&
      object.event?.playerRings !== null
    ) {
      message.event = {
        $case: "playerRings",
        playerRings: PlayerRings.fromPartial(object.event.playerRings),
      };
    }
    if (
      object.event?.$case === "playerSetsPointer" &&
      object.event?.playerSetsPointer !== undefined &&
      object.event?.playerSetsPointer !== null
    ) {
      message.event = {
        $case: "playerSetsPointer",
        playerSetsPointer: PlayerSetsPointer.fromPartial(object.event.playerSetsPointer),
      };
    }
    if (
      object.event?.$case === "playerChats" &&
      object.event?.playerChats !== undefined &&
      object.event?.playerChats !== null
    ) {
      message.event = {
        $case: "playerChats",
        playerChats: PlayerChats.fromPartial(object.event.playerChats),
      };
    }
    if (
      object.event?.$case === "playerInteracts" &&
      object.event?.playerInteracts !== undefined &&
      object.event?.playerInteracts !== null
    ) {
      message.event = {
        $case: "playerInteracts",
        playerInteracts: PlayerInteracts.fromPartial(object.event.playerInteracts),
      };
    }
    if (
      object.event?.$case === "playerGhosts" &&
      object.event?.playerGhosts !== undefined &&
      object.event?.playerGhosts !== null
    ) {
      message.event = {
        $case: "playerGhosts",
        playerGhosts: PlayerGhosts.fromPartial(object.event.playerGhosts),
      };
    }
    if (
      object.event?.$case === "playerEntersWhisper" &&
      object.event?.playerEntersWhisper !== undefined &&
      object.event?.playerEntersWhisper !== null
    ) {
      message.event = {
        $case: "playerEntersWhisper",
        playerEntersWhisper: PlayerEntersWhisper.fromPartial(object.event.playerEntersWhisper),
      };
    }
    if (
      object.event?.$case === "playerLeavesWhisper" &&
      object.event?.playerLeavesWhisper !== undefined &&
      object.event?.playerLeavesWhisper !== null
    ) {
      message.event = {
        $case: "playerLeavesWhisper",
        playerLeavesWhisper: PlayerLeavesWhisper.fromPartial(object.event.playerLeavesWhisper),
      };
    }
    if (
      object.event?.$case === "playerActivelySpeaks" &&
      object.event?.playerActivelySpeaks !== undefined &&
      object.event?.playerActivelySpeaks !== null
    ) {
      message.event = {
        $case: "playerActivelySpeaks",
        playerActivelySpeaks: PlayerActivelySpeaks.fromPartial(object.event.playerActivelySpeaks),
      };
    }
    if (
      object.event?.$case === "playerSetsEmote" &&
      object.event?.playerSetsEmote !== undefined &&
      object.event?.playerSetsEmote !== null
    ) {
      message.event = {
        $case: "playerSetsEmote",
        playerSetsEmote: PlayerSetsEmote.fromPartial(object.event.playerSetsEmote),
      };
    }
    if (
      object.event?.$case === "playerSetsWorkCondition" &&
      object.event?.playerSetsWorkCondition !== undefined &&
      object.event?.playerSetsWorkCondition !== null
    ) {
      message.event = {
        $case: "playerSetsWorkCondition",
        playerSetsWorkCondition: PlayerSetsWorkCondition.fromPartial(
          object.event.playerSetsWorkCondition,
        ),
      };
    }
    if (
      object.event?.$case === "playerSetsName" &&
      object.event?.playerSetsName !== undefined &&
      object.event?.playerSetsName !== null
    ) {
      message.event = {
        $case: "playerSetsName",
        playerSetsName: PlayerSetsName.fromPartial(object.event.playerSetsName),
      };
    }
    if (
      object.event?.$case === "playerSetsTextStatus" &&
      object.event?.playerSetsTextStatus !== undefined &&
      object.event?.playerSetsTextStatus !== null
    ) {
      message.event = {
        $case: "playerSetsTextStatus",
        playerSetsTextStatus: PlayerSetsTextStatus.fromPartial(object.event.playerSetsTextStatus),
      };
    }
    if (
      object.event?.$case === "playerSetsEmojiStatus" &&
      object.event?.playerSetsEmojiStatus !== undefined &&
      object.event?.playerSetsEmojiStatus !== null
    ) {
      message.event = {
        $case: "playerSetsEmojiStatus",
        playerSetsEmojiStatus: PlayerSetsEmojiStatus.fromPartial(
          object.event.playerSetsEmojiStatus,
        ),
      };
    }
    if (
      object.event?.$case === "playerSetsAffiliation" &&
      object.event?.playerSetsAffiliation !== undefined &&
      object.event?.playerSetsAffiliation !== null
    ) {
      message.event = {
        $case: "playerSetsAffiliation",
        playerSetsAffiliation: PlayerSetsAffiliation.fromPartial(
          object.event.playerSetsAffiliation,
        ),
      };
    }
    if (
      object.event?.$case === "playerExits" &&
      object.event?.playerExits !== undefined &&
      object.event?.playerExits !== null
    ) {
      message.event = {
        $case: "playerExits",
        playerExits: PlayerExits.fromPartial(object.event.playerExits),
      };
    }
    if (
      object.event?.$case === "playerSetsSprite" &&
      object.event?.playerSetsSprite !== undefined &&
      object.event?.playerSetsSprite !== null
    ) {
      message.event = {
        $case: "playerSetsSprite",
        playerSetsSprite: PlayerSetsSprite.fromPartial(object.event.playerSetsSprite),
      };
    }
    if (
      object.event?.$case === "respawnComplete" &&
      object.event?.respawnComplete !== undefined &&
      object.event?.respawnComplete !== null
    ) {
      message.event = {
        $case: "respawnComplete",
        respawnComplete: RespawnComplete.fromPartial(object.event.respawnComplete),
      };
    }
    if (
      object.event?.$case === "playerSetsOutfitString" &&
      object.event?.playerSetsOutfitString !== undefined &&
      object.event?.playerSetsOutfitString !== null
    ) {
      message.event = {
        $case: "playerSetsOutfitString",
        playerSetsOutfitString: PlayerSetsOutfitString.fromPartial(
          object.event.playerSetsOutfitString,
        ),
      };
    }
    if (
      object.event?.$case === "playerSetsIsSignedIn" &&
      object.event?.playerSetsIsSignedIn !== undefined &&
      object.event?.playerSetsIsSignedIn !== null
    ) {
      message.event = {
        $case: "playerSetsIsSignedIn",
        playerSetsIsSignedIn: PlayerSetsIsSignedIn.fromPartial(object.event.playerSetsIsSignedIn),
      };
    }
    if (
      object.event?.$case === "mapUpdates" &&
      object.event?.mapUpdates !== undefined &&
      object.event?.mapUpdates !== null
    ) {
      message.event = {
        $case: "mapUpdates",
        mapUpdates: MapUpdates.fromPartial(object.event.mapUpdates),
      };
    }
    if (
      object.event?.$case === "mapOverwrites" &&
      object.event?.mapOverwrites !== undefined &&
      object.event?.mapOverwrites !== null
    ) {
      message.event = {
        $case: "mapOverwrites",
        mapOverwrites: MapOverwrites.fromPartial(object.event.mapOverwrites),
      };
    }
    if (
      object.event?.$case === "spaceOverwrites" &&
      object.event?.spaceOverwrites !== undefined &&
      object.event?.spaceOverwrites !== null
    ) {
      message.event = {
        $case: "spaceOverwrites",
        spaceOverwrites: SpaceOverwrites.fromPartial(object.event.spaceOverwrites),
      };
    }
    if (
      object.event?.$case === "spaceIsClosed" &&
      object.event?.spaceIsClosed !== undefined &&
      object.event?.spaceIsClosed !== null
    ) {
      message.event = {
        $case: "spaceIsClosed",
        spaceIsClosed: SpaceIsClosed.fromPartial(object.event.spaceIsClosed),
      };
    }
    if (
      object.event?.$case === "playerEntersPortal" &&
      object.event?.playerEntersPortal !== undefined &&
      object.event?.playerEntersPortal !== null
    ) {
      message.event = {
        $case: "playerEntersPortal",
        playerEntersPortal: PlayerEntersPortal.fromPartial(object.event.playerEntersPortal),
      };
    }
    if (
      object.event?.$case === "spaceSetsIdMapping" &&
      object.event?.spaceSetsIdMapping !== undefined &&
      object.event?.spaceSetsIdMapping !== null
    ) {
      message.event = {
        $case: "spaceSetsIdMapping",
        spaceSetsIdMapping: SpaceSetsIdMapping.fromPartial(object.event.spaceSetsIdMapping),
      };
    }
    if (
      object.event?.$case === "playerSetsLastActive" &&
      object.event?.playerSetsLastActive !== undefined &&
      object.event?.playerSetsLastActive !== null
    ) {
      message.event = {
        $case: "playerSetsLastActive",
        playerSetsLastActive: PlayerSetsLastActive.fromPartial(object.event.playerSetsLastActive),
      };
    }
    if (
      object.event?.$case === "playerShootsConfetti" &&
      object.event?.playerShootsConfetti !== undefined &&
      object.event?.playerShootsConfetti !== null
    ) {
      message.event = {
        $case: "playerShootsConfetti",
        playerShootsConfetti: PlayerShootsConfetti.fromPartial(object.event.playerShootsConfetti),
      };
    }
    if (
      object.event?.$case === "playerSetsEventStatus" &&
      object.event?.playerSetsEventStatus !== undefined &&
      object.event?.playerSetsEventStatus !== null
    ) {
      message.event = {
        $case: "playerSetsEventStatus",
        playerSetsEventStatus: PlayerSetsEventStatus.fromPartial(
          object.event.playerSetsEventStatus,
        ),
      };
    }
    if (
      object.event?.$case === "playerSetsInConversation" &&
      object.event?.playerSetsInConversation !== undefined &&
      object.event?.playerSetsInConversation !== null
    ) {
      message.event = {
        $case: "playerSetsInConversation",
        playerSetsInConversation: PlayerSetsInConversation.fromPartial(
          object.event.playerSetsInConversation,
        ),
      };
    }
    if (
      object.event?.$case === "playerSetsCurrentDesk" &&
      object.event?.playerSetsCurrentDesk !== undefined &&
      object.event?.playerSetsCurrentDesk !== null
    ) {
      message.event = {
        $case: "playerSetsCurrentDesk",
        playerSetsCurrentDesk: PlayerSetsCurrentDesk.fromPartial(
          object.event.playerSetsCurrentDesk,
        ),
      };
    }
    if (
      object.event?.$case === "playerSetsCurrentArea" &&
      object.event?.playerSetsCurrentArea !== undefined &&
      object.event?.playerSetsCurrentArea !== null
    ) {
      message.event = {
        $case: "playerSetsCurrentArea",
        playerSetsCurrentArea: PlayerSetsCurrentArea.fromPartial(
          object.event.playerSetsCurrentArea,
        ),
      };
    }
    if (
      object.event?.$case === "playerSetsImagePointer" &&
      object.event?.playerSetsImagePointer !== undefined &&
      object.event?.playerSetsImagePointer !== null
    ) {
      message.event = {
        $case: "playerSetsImagePointer",
        playerSetsImagePointer: PlayerSetsImagePointer.fromPartial(
          object.event.playerSetsImagePointer,
        ),
      };
    }
    if (
      object.event?.$case === "cookieFound" &&
      object.event?.cookieFound !== undefined &&
      object.event?.cookieFound !== null
    ) {
      message.event = {
        $case: "cookieFound",
        cookieFound: CookieFound.fromPartial(object.event.cookieFound),
      };
    }
    if (
      object.event?.$case === "playerEntersWhisperV2" &&
      object.event?.playerEntersWhisperV2 !== undefined &&
      object.event?.playerEntersWhisperV2 !== null
    ) {
      message.event = {
        $case: "playerEntersWhisperV2",
        playerEntersWhisperV2: PlayerEntersWhisperV2.fromPartial(
          object.event.playerEntersWhisperV2,
        ),
      };
    }
    if (
      object.event?.$case === "playerSetsGoKartId" &&
      object.event?.playerSetsGoKartId !== undefined &&
      object.event?.playerSetsGoKartId !== null
    ) {
      message.event = {
        $case: "playerSetsGoKartId",
        playerSetsGoKartId: PlayerSetsGoKartId.fromPartial(object.event.playerSetsGoKartId),
      };
    }
    if (
      object.event?.$case === "mapSetDimensions" &&
      object.event?.mapSetDimensions !== undefined &&
      object.event?.mapSetDimensions !== null
    ) {
      message.event = {
        $case: "mapSetDimensions",
        mapSetDimensions: MapSetDimensions.fromPartial(object.event.mapSetDimensions),
      };
    }
    if (
      object.event?.$case === "mapSetCollisions" &&
      object.event?.mapSetCollisions !== undefined &&
      object.event?.mapSetCollisions !== null
    ) {
      message.event = {
        $case: "mapSetCollisions",
        mapSetCollisions: MapSetCollisions.fromPartial(object.event.mapSetCollisions),
      };
    }
    if (
      object.event?.$case === "mapSetBackgroundImagePath" &&
      object.event?.mapSetBackgroundImagePath !== undefined &&
      object.event?.mapSetBackgroundImagePath !== null
    ) {
      message.event = {
        $case: "mapSetBackgroundImagePath",
        mapSetBackgroundImagePath: MapSetBackgroundImagePath.fromPartial(
          object.event.mapSetBackgroundImagePath,
        ),
      };
    }
    if (
      object.event?.$case === "mapSetForegroundImagePath" &&
      object.event?.mapSetForegroundImagePath !== undefined &&
      object.event?.mapSetForegroundImagePath !== null
    ) {
      message.event = {
        $case: "mapSetForegroundImagePath",
        mapSetForegroundImagePath: MapSetForegroundImagePath.fromPartial(
          object.event.mapSetForegroundImagePath,
        ),
      };
    }
    if (
      object.event?.$case === "mapSetSprites" &&
      object.event?.mapSetSprites !== undefined &&
      object.event?.mapSetSprites !== null
    ) {
      message.event = {
        $case: "mapSetSprites",
        mapSetSprites: MapSetSprites.fromPartial(object.event.mapSetSprites),
      };
    }
    if (
      object.event?.$case === "mapSetSpaces" &&
      object.event?.mapSetSpaces !== undefined &&
      object.event?.mapSetSpaces !== null
    ) {
      message.event = {
        $case: "mapSetSpaces",
        mapSetSpaces: MapSetSpaces.fromPartial(object.event.mapSetSpaces),
      };
    }
    if (
      object.event?.$case === "mapSetSpawns" &&
      object.event?.mapSetSpawns !== undefined &&
      object.event?.mapSetSpawns !== null
    ) {
      message.event = {
        $case: "mapSetSpawns",
        mapSetSpawns: MapSetSpawns.fromPartial(object.event.mapSetSpawns),
      };
    }
    if (
      object.event?.$case === "mapSetPortals" &&
      object.event?.mapSetPortals !== undefined &&
      object.event?.mapSetPortals !== null
    ) {
      message.event = {
        $case: "mapSetPortals",
        mapSetPortals: MapSetPortals.fromPartial(object.event.mapSetPortals),
      };
    }
    if (
      object.event?.$case === "mapSetAnnouncer" &&
      object.event?.mapSetAnnouncer !== undefined &&
      object.event?.mapSetAnnouncer !== null
    ) {
      message.event = {
        $case: "mapSetAnnouncer",
        mapSetAnnouncer: MapSetAnnouncer.fromPartial(object.event.mapSetAnnouncer),
      };
    }
    if (
      object.event?.$case === "mapSetAudio" &&
      object.event?.mapSetAudio !== undefined &&
      object.event?.mapSetAudio !== null
    ) {
      message.event = {
        $case: "mapSetAudio",
        mapSetAudio: MapSetAudio.fromPartial(object.event.mapSetAudio),
      };
    }
    if (
      object.event?.$case === "mapSetAnimations" &&
      object.event?.mapSetAnimations !== undefined &&
      object.event?.mapSetAnimations !== null
    ) {
      message.event = {
        $case: "mapSetAnimations",
        mapSetAnimations: MapSetAnimations.fromPartial(object.event.mapSetAnimations),
      };
    }
    if (
      object.event?.$case === "mapSetAssets" &&
      object.event?.mapSetAssets !== undefined &&
      object.event?.mapSetAssets !== null
    ) {
      message.event = {
        $case: "mapSetAssets",
        mapSetAssets: MapSetAssets.fromPartial(object.event.mapSetAssets),
      };
    }
    if (
      object.event?.$case === "mapSetObjects" &&
      object.event?.mapSetObjects !== undefined &&
      object.event?.mapSetObjects !== null
    ) {
      message.event = {
        $case: "mapSetObjects",
        mapSetObjects: MapSetObjects.fromPartial(object.event.mapSetObjects),
      };
    }
    if (
      object.event?.$case === "mapSetName" &&
      object.event?.mapSetName !== undefined &&
      object.event?.mapSetName !== null
    ) {
      message.event = {
        $case: "mapSetName",
        mapSetName: MapSetName.fromPartial(object.event.mapSetName),
      };
    }
    if (
      object.event?.$case === "mapSetDefaultChat" &&
      object.event?.mapSetDefaultChat !== undefined &&
      object.event?.mapSetDefaultChat !== null
    ) {
      message.event = {
        $case: "mapSetDefaultChat",
        mapSetDefaultChat: MapSetDefaultChat.fromPartial(object.event.mapSetDefaultChat),
      };
    }
    if (
      object.event?.$case === "mapSetMuteOnEntry" &&
      object.event?.mapSetMuteOnEntry !== undefined &&
      object.event?.mapSetMuteOnEntry !== null
    ) {
      message.event = {
        $case: "mapSetMuteOnEntry",
        mapSetMuteOnEntry: MapSetMuteOnEntry.fromPartial(object.event.mapSetMuteOnEntry),
      };
    }
    if (
      object.event?.$case === "mapSetUseDrawnBG" &&
      object.event?.mapSetUseDrawnBG !== undefined &&
      object.event?.mapSetUseDrawnBG !== null
    ) {
      message.event = {
        $case: "mapSetUseDrawnBG",
        mapSetUseDrawnBG: MapSetUseDrawnBG.fromPartial(object.event.mapSetUseDrawnBG),
      };
    }
    if (
      object.event?.$case === "mapSetWalls" &&
      object.event?.mapSetWalls !== undefined &&
      object.event?.mapSetWalls !== null
    ) {
      message.event = {
        $case: "mapSetWalls",
        mapSetWalls: MapSetWalls.fromPartial(object.event.mapSetWalls),
      };
    }
    if (
      object.event?.$case === "mapSetFloors" &&
      object.event?.mapSetFloors !== undefined &&
      object.event?.mapSetFloors !== null
    ) {
      message.event = {
        $case: "mapSetFloors",
        mapSetFloors: MapSetFloors.fromPartial(object.event.mapSetFloors),
      };
    }
    if (
      object.event?.$case === "mapSetAreas" &&
      object.event?.mapSetAreas !== undefined &&
      object.event?.mapSetAreas !== null
    ) {
      message.event = {
        $case: "mapSetAreas",
        mapSetAreas: MapSetAreas.fromPartial(object.event.mapSetAreas),
      };
    }
    if (
      object.event?.$case === "mapDeleteObject" &&
      object.event?.mapDeleteObject !== undefined &&
      object.event?.mapDeleteObject !== null
    ) {
      message.event = {
        $case: "mapDeleteObject",
        mapDeleteObject: MapDeleteObject.fromPartial(object.event.mapDeleteObject),
      };
    }
    if (
      object.event?.$case === "mapSetSpawn" &&
      object.event?.mapSetSpawn !== undefined &&
      object.event?.mapSetSpawn !== null
    ) {
      message.event = {
        $case: "mapSetSpawn",
        mapSetSpawn: MapSetSpawn.fromPartial(object.event.mapSetSpawn),
      };
    }
    return message;
  },
};

const baseServerHeartbeat: object = { lastRTT: 0 };

export const ServerHeartbeat = {
  encode(message: ServerHeartbeat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lastRTT !== 0) {
      writer.uint32(8).uint32(message.lastRTT);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServerHeartbeat {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseServerHeartbeat } as ServerHeartbeat;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lastRTT = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ServerHeartbeat {
    const message = { ...baseServerHeartbeat } as ServerHeartbeat;
    if (object.lastRTT !== undefined && object.lastRTT !== null) {
      message.lastRTT = Number(object.lastRTT);
    }
    return message;
  },

  toJSON(message: ServerHeartbeat): unknown {
    const obj: any = {};
    message.lastRTT !== undefined && (obj.lastRTT = message.lastRTT);
    return obj;
  },

  fromPartial(object: DeepPartial<ServerHeartbeat>): ServerHeartbeat {
    const message = { ...baseServerHeartbeat } as ServerHeartbeat;
    if (object.lastRTT !== undefined && object.lastRTT !== null) {
      message.lastRTT = object.lastRTT;
    }
    return message;
  },
};

const baseInfo: object = { message: "" };

export const Info = {
  encode(message: Info, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Info {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseInfo } as Info;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.message = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Info {
    const message = { ...baseInfo } as Info;
    if (object.message !== undefined && object.message !== null) {
      message.message = String(object.message);
    }
    return message;
  },

  toJSON(message: Info): unknown {
    const obj: any = {};
    message.message !== undefined && (obj.message = message.message);
    return obj;
  },

  fromPartial(object: DeepPartial<Info>): Info {
    const message = { ...baseInfo } as Info;
    if (object.message !== undefined && object.message !== null) {
      message.message = object.message;
    }
    return message;
  },
};

const baseWarn: object = { message: "" };

export const Warn = {
  encode(message: Warn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Warn {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseWarn } as Warn;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.message = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Warn {
    const message = { ...baseWarn } as Warn;
    if (object.message !== undefined && object.message !== null) {
      message.message = String(object.message);
    }
    return message;
  },

  toJSON(message: Warn): unknown {
    const obj: any = {};
    message.message !== undefined && (obj.message = message.message);
    return obj;
  },

  fromPartial(object: DeepPartial<Warn>): Warn {
    const message = { ...baseWarn } as Warn;
    if (object.message !== undefined && object.message !== null) {
      message.message = object.message;
    }
    return message;
  },
};

const baseError: object = { message: "", code: 0 };

export const Error = {
  encode(message: Error, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.code !== 0) {
      writer.uint32(16).uint32(message.code);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Error {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseError } as Error;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.message = reader.string();
          break;
        case 2:
          message.code = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Error {
    const message = { ...baseError } as Error;
    if (object.message !== undefined && object.message !== null) {
      message.message = String(object.message);
    }
    if (object.code !== undefined && object.code !== null) {
      message.code = Number(object.code);
    }
    return message;
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    message.message !== undefined && (obj.message = message.message);
    message.code !== undefined && (obj.code = message.code);
    return obj;
  },

  fromPartial(object: DeepPartial<Error>): Error {
    const message = { ...baseError } as Error;
    if (object.message !== undefined && object.message !== null) {
      message.message = object.message;
    }
    if (object.code !== undefined && object.code !== null) {
      message.code = object.code;
    }
    return message;
  },
};

const baseReady: object = { id: "" };

export const Ready = {
  encode(message: Ready, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Ready {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseReady } as Ready;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Ready {
    const message = { ...baseReady } as Ready;
    if (object.id !== undefined && object.id !== null) {
      message.id = String(object.id);
    }
    return message;
  },

  toJSON(message: Ready): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    return obj;
  },

  fromPartial(object: DeepPartial<Ready>): Ready {
    const message = { ...baseReady } as Ready;
    if (object.id !== undefined && object.id !== null) {
      message.id = object.id;
    }
    return message;
  },
};

const baseDisableVideo: object = {};

export const DisableVideo = {
  encode(_: DisableVideo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DisableVideo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseDisableVideo } as DisableVideo;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DisableVideo {
    const message = { ...baseDisableVideo } as DisableVideo;
    return message;
  },

  toJSON(_: DisableVideo): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial(_: DeepPartial<DisableVideo>): DisableVideo {
    const message = { ...baseDisableVideo } as DisableVideo;
    return message;
  },
};

const basePlayerMoves: object = { encId: 0, lastInputId: 0 };

export const PlayerMoves = {
  encode(message: PlayerMoves, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.x !== undefined) {
      writer.uint32(16).uint32(message.x);
    }
    if (message.y !== undefined) {
      writer.uint32(24).uint32(message.y);
    }
    if (message.direction !== undefined) {
      writer.uint32(32).int32(message.direction);
    }
    if (message.mapId !== undefined) {
      writer.uint32(42).string(message.mapId);
    }
    if (message.lastInputId !== 0) {
      writer.uint32(48).uint32(message.lastInputId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerMoves {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerMoves } as PlayerMoves;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.x = reader.uint32();
          break;
        case 3:
          message.y = reader.uint32();
          break;
        case 4:
          message.direction = reader.int32() as any;
          break;
        case 5:
          message.mapId = reader.string();
          break;
        case 6:
          message.lastInputId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerMoves {
    const message = { ...basePlayerMoves } as PlayerMoves;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    if (object.direction !== undefined && object.direction !== null) {
      message.direction = spriteDirectionEnum_ENUMFromJSON(object.direction);
    }
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.lastInputId !== undefined && object.lastInputId !== null) {
      message.lastInputId = Number(object.lastInputId);
    }
    return message;
  },

  toJSON(message: PlayerMoves): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.direction !== undefined &&
      (obj.direction =
        message.direction !== undefined
          ? spriteDirectionEnum_ENUMToJSON(message.direction)
          : undefined);
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.lastInputId !== undefined && (obj.lastInputId = message.lastInputId);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerMoves>): PlayerMoves {
    const message = { ...basePlayerMoves } as PlayerMoves;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    if (object.direction !== undefined && object.direction !== null) {
      message.direction = object.direction;
    }
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.lastInputId !== undefined && object.lastInputId !== null) {
      message.lastInputId = object.lastInputId;
    }
    return message;
  },
};

const basePlayerSetsStatus: object = { encId: 0, busy: false };

export const PlayerSetsStatus = {
  encode(message: PlayerSetsStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.busy === true) {
      writer.uint32(16).bool(message.busy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsStatus } as PlayerSetsStatus;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.busy = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsStatus {
    const message = { ...basePlayerSetsStatus } as PlayerSetsStatus;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.busy !== undefined && object.busy !== null) {
      message.busy = Boolean(object.busy);
    }
    return message;
  },

  toJSON(message: PlayerSetsStatus): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.busy !== undefined && (obj.busy = message.busy);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsStatus>): PlayerSetsStatus {
    const message = { ...basePlayerSetsStatus } as PlayerSetsStatus;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.busy !== undefined && object.busy !== null) {
      message.busy = object.busy;
    }
    return message;
  },
};

const basePlayerSpotlights: object = { encId: 0, spotlightedBy: 0, spotlighted: 0 };

export const PlayerSpotlights = {
  encode(message: PlayerSpotlights, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(16).uint32(message.encId);
    }
    if (message.spotlightedBy !== 0) {
      writer.uint32(8).uint32(message.spotlightedBy);
    }
    if (message.spotlighted !== 0) {
      writer.uint32(24).uint32(message.spotlighted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSpotlights {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSpotlights } as PlayerSpotlights;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.encId = reader.uint32();
          break;
        case 1:
          message.spotlightedBy = reader.uint32();
          break;
        case 3:
          message.spotlighted = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSpotlights {
    const message = { ...basePlayerSpotlights } as PlayerSpotlights;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.spotlightedBy !== undefined && object.spotlightedBy !== null) {
      message.spotlightedBy = Number(object.spotlightedBy);
    }
    if (object.spotlighted !== undefined && object.spotlighted !== null) {
      message.spotlighted = Number(object.spotlighted);
    }
    return message;
  },

  toJSON(message: PlayerSpotlights): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.spotlightedBy !== undefined && (obj.spotlightedBy = message.spotlightedBy);
    message.spotlighted !== undefined && (obj.spotlighted = message.spotlighted);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSpotlights>): PlayerSpotlights {
    const message = { ...basePlayerSpotlights } as PlayerSpotlights;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.spotlightedBy !== undefined && object.spotlightedBy !== null) {
      message.spotlightedBy = object.spotlightedBy;
    }
    if (object.spotlighted !== undefined && object.spotlighted !== null) {
      message.spotlighted = object.spotlighted;
    }
    return message;
  },
};

const basePlayerRings: object = { encId: 0 };

export const PlayerRings = {
  encode(message: PlayerRings, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerRings {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerRings } as PlayerRings;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerRings {
    const message = { ...basePlayerRings } as PlayerRings;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    return message;
  },

  toJSON(message: PlayerRings): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerRings>): PlayerRings {
    const message = { ...basePlayerRings } as PlayerRings;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    return message;
  },
};

const basePlayerSetsPointer: object = { encId: 0, objectId: "", x: 0, y: 0 };

export const PlayerSetsPointer = {
  encode(message: PlayerSetsPointer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.objectId !== "") {
      writer.uint32(18).string(message.objectId);
    }
    if (message.x !== 0) {
      writer.uint32(24).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(32).uint32(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsPointer {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsPointer } as PlayerSetsPointer;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.objectId = reader.string();
          break;
        case 3:
          message.x = reader.uint32();
          break;
        case 4:
          message.y = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsPointer {
    const message = { ...basePlayerSetsPointer } as PlayerSetsPointer;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.objectId !== undefined && object.objectId !== null) {
      message.objectId = String(object.objectId);
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    return message;
  },

  toJSON(message: PlayerSetsPointer): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.objectId !== undefined && (obj.objectId = message.objectId);
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsPointer>): PlayerSetsPointer {
    const message = { ...basePlayerSetsPointer } as PlayerSetsPointer;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.objectId !== undefined && object.objectId !== null) {
      message.objectId = object.objectId;
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    return message;
  },
};

const basePlayerSetsImagePointer: object = { encId: 0, objectId: "", x: 0, y: 0 };

export const PlayerSetsImagePointer = {
  encode(message: PlayerSetsImagePointer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.objectId !== "") {
      writer.uint32(18).string(message.objectId);
    }
    if (message.x !== 0) {
      writer.uint32(25).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(33).double(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsImagePointer {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsImagePointer } as PlayerSetsImagePointer;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.objectId = reader.string();
          break;
        case 3:
          message.x = reader.double();
          break;
        case 4:
          message.y = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsImagePointer {
    const message = { ...basePlayerSetsImagePointer } as PlayerSetsImagePointer;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.objectId !== undefined && object.objectId !== null) {
      message.objectId = String(object.objectId);
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    return message;
  },

  toJSON(message: PlayerSetsImagePointer): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.objectId !== undefined && (obj.objectId = message.objectId);
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsImagePointer>): PlayerSetsImagePointer {
    const message = { ...basePlayerSetsImagePointer } as PlayerSetsImagePointer;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.objectId !== undefined && object.objectId !== null) {
      message.objectId = object.objectId;
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    return message;
  },
};

const basePlayerChats: object = {
  senderId: "",
  recipient: "",
  contents: "",
  senderName: "",
  messageType: "",
  unixTime: 0,
};

export const PlayerChats = {
  encode(message: PlayerChats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderId !== "") {
      writer.uint32(10).string(message.senderId);
    }
    if (message.recipient !== "") {
      writer.uint32(18).string(message.recipient);
    }
    if (message.contents !== "") {
      writer.uint32(26).string(message.contents);
    }
    if (message.senderName !== "") {
      writer.uint32(34).string(message.senderName);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
    }
    if (message.messageType !== "") {
      writer.uint32(50).string(message.messageType);
    }
    if (message.unixTime !== 0) {
      writer.uint32(57).double(message.unixTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerChats {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerChats } as PlayerChats;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.senderId = reader.string();
          break;
        case 2:
          message.recipient = reader.string();
          break;
        case 3:
          message.contents = reader.string();
          break;
        case 4:
          message.senderName = reader.string();
          break;
        case 5:
          message.timestamp = Timestamp.decode(reader, reader.uint32());
          break;
        case 6:
          message.messageType = reader.string();
          break;
        case 7:
          message.unixTime = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerChats {
    const message = { ...basePlayerChats } as PlayerChats;
    if (object.senderId !== undefined && object.senderId !== null) {
      message.senderId = String(object.senderId);
    }
    if (object.recipient !== undefined && object.recipient !== null) {
      message.recipient = String(object.recipient);
    }
    if (object.contents !== undefined && object.contents !== null) {
      message.contents = String(object.contents);
    }
    if (object.senderName !== undefined && object.senderName !== null) {
      message.senderName = String(object.senderName);
    }
    if (object.timestamp !== undefined && object.timestamp !== null) {
      message.timestamp = Timestamp.fromJSON(object.timestamp);
    }
    if (object.messageType !== undefined && object.messageType !== null) {
      message.messageType = String(object.messageType);
    }
    if (object.unixTime !== undefined && object.unixTime !== null) {
      message.unixTime = Number(object.unixTime);
    }
    return message;
  },

  toJSON(message: PlayerChats): unknown {
    const obj: any = {};
    message.senderId !== undefined && (obj.senderId = message.senderId);
    message.recipient !== undefined && (obj.recipient = message.recipient);
    message.contents !== undefined && (obj.contents = message.contents);
    message.senderName !== undefined && (obj.senderName = message.senderName);
    message.timestamp !== undefined &&
      (obj.timestamp = message.timestamp ? Timestamp.toJSON(message.timestamp) : undefined);
    message.messageType !== undefined && (obj.messageType = message.messageType);
    message.unixTime !== undefined && (obj.unixTime = message.unixTime);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerChats>): PlayerChats {
    const message = { ...basePlayerChats } as PlayerChats;
    if (object.senderId !== undefined && object.senderId !== null) {
      message.senderId = object.senderId;
    }
    if (object.recipient !== undefined && object.recipient !== null) {
      message.recipient = object.recipient;
    }
    if (object.contents !== undefined && object.contents !== null) {
      message.contents = object.contents;
    }
    if (object.senderName !== undefined && object.senderName !== null) {
      message.senderName = object.senderName;
    }
    if (object.timestamp !== undefined && object.timestamp !== null) {
      message.timestamp = Timestamp.fromPartial(object.timestamp);
    }
    if (object.messageType !== undefined && object.messageType !== null) {
      message.messageType = object.messageType;
    }
    if (object.unixTime !== undefined && object.unixTime !== null) {
      message.unixTime = object.unixTime;
    }
    return message;
  },
};

const baseTimestamp: object = { seconds: 0, nanoseconds: 0 };

export const Timestamp = {
  encode(message: Timestamp, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.seconds !== 0) {
      writer.uint32(13).float(message.seconds);
    }
    if (message.nanoseconds !== 0) {
      writer.uint32(21).float(message.nanoseconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Timestamp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseTimestamp } as Timestamp;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.seconds = reader.float();
          break;
        case 2:
          message.nanoseconds = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Timestamp {
    const message = { ...baseTimestamp } as Timestamp;
    if (object.seconds !== undefined && object.seconds !== null) {
      message.seconds = Number(object.seconds);
    }
    if (object.nanoseconds !== undefined && object.nanoseconds !== null) {
      message.nanoseconds = Number(object.nanoseconds);
    }
    return message;
  },

  toJSON(message: Timestamp): unknown {
    const obj: any = {};
    message.seconds !== undefined && (obj.seconds = message.seconds);
    message.nanoseconds !== undefined && (obj.nanoseconds = message.nanoseconds);
    return obj;
  },

  fromPartial(object: DeepPartial<Timestamp>): Timestamp {
    const message = { ...baseTimestamp } as Timestamp;
    if (object.seconds !== undefined && object.seconds !== null) {
      message.seconds = object.seconds;
    }
    if (object.nanoseconds !== undefined && object.nanoseconds !== null) {
      message.nanoseconds = object.nanoseconds;
    }
    return message;
  },
};

const basePlayerInteracts: object = { encId: 0, objId: "" };

export const PlayerInteracts = {
  encode(message: PlayerInteracts, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.objId !== "") {
      writer.uint32(18).string(message.objId);
    }
    if (message.dataJson !== undefined) {
      writer.uint32(26).string(message.dataJson);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerInteracts {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerInteracts } as PlayerInteracts;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.objId = reader.string();
          break;
        case 3:
          message.dataJson = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerInteracts {
    const message = { ...basePlayerInteracts } as PlayerInteracts;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.objId !== undefined && object.objId !== null) {
      message.objId = String(object.objId);
    }
    if (object.dataJson !== undefined && object.dataJson !== null) {
      message.dataJson = String(object.dataJson);
    }
    return message;
  },

  toJSON(message: PlayerInteracts): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.objId !== undefined && (obj.objId = message.objId);
    message.dataJson !== undefined && (obj.dataJson = message.dataJson);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerInteracts>): PlayerInteracts {
    const message = { ...basePlayerInteracts } as PlayerInteracts;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.objId !== undefined && object.objId !== null) {
      message.objId = object.objId;
    }
    if (object.dataJson !== undefined && object.dataJson !== null) {
      message.dataJson = object.dataJson;
    }
    return message;
  },
};

const basePlayerGhosts: object = { encId: 0, ghost: 0 };

export const PlayerGhosts = {
  encode(message: PlayerGhosts, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.ghost !== 0) {
      writer.uint32(16).uint32(message.ghost);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerGhosts {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerGhosts } as PlayerGhosts;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.ghost = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerGhosts {
    const message = { ...basePlayerGhosts } as PlayerGhosts;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.ghost !== undefined && object.ghost !== null) {
      message.ghost = Number(object.ghost);
    }
    return message;
  },

  toJSON(message: PlayerGhosts): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.ghost !== undefined && (obj.ghost = message.ghost);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerGhosts>): PlayerGhosts {
    const message = { ...basePlayerGhosts } as PlayerGhosts;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.ghost !== undefined && object.ghost !== null) {
      message.ghost = object.ghost;
    }
    return message;
  },
};

const basePlayerEntersWhisper: object = { encId: 0, whisperRecipient: "", whisperId: "" };

export const PlayerEntersWhisper = {
  encode(message: PlayerEntersWhisper, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.whisperRecipient !== "") {
      writer.uint32(18).string(message.whisperRecipient);
    }
    if (message.whisperId !== "") {
      writer.uint32(26).string(message.whisperId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerEntersWhisper {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerEntersWhisper } as PlayerEntersWhisper;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.whisperRecipient = reader.string();
          break;
        case 3:
          message.whisperId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerEntersWhisper {
    const message = { ...basePlayerEntersWhisper } as PlayerEntersWhisper;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.whisperRecipient !== undefined && object.whisperRecipient !== null) {
      message.whisperRecipient = String(object.whisperRecipient);
    }
    if (object.whisperId !== undefined && object.whisperId !== null) {
      message.whisperId = String(object.whisperId);
    }
    return message;
  },

  toJSON(message: PlayerEntersWhisper): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.whisperRecipient !== undefined && (obj.whisperRecipient = message.whisperRecipient);
    message.whisperId !== undefined && (obj.whisperId = message.whisperId);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerEntersWhisper>): PlayerEntersWhisper {
    const message = { ...basePlayerEntersWhisper } as PlayerEntersWhisper;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.whisperRecipient !== undefined && object.whisperRecipient !== null) {
      message.whisperRecipient = object.whisperRecipient;
    }
    if (object.whisperId !== undefined && object.whisperId !== null) {
      message.whisperId = object.whisperId;
    }
    return message;
  },
};

const basePlayerEntersWhisperV2: object = { encId: 0, encIdTarget: 0, whisperId: "" };

export const PlayerEntersWhisperV2 = {
  encode(message: PlayerEntersWhisperV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.encIdTarget !== 0) {
      writer.uint32(16).uint32(message.encIdTarget);
    }
    if (message.whisperId !== "") {
      writer.uint32(26).string(message.whisperId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerEntersWhisperV2 {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerEntersWhisperV2 } as PlayerEntersWhisperV2;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.encIdTarget = reader.uint32();
          break;
        case 3:
          message.whisperId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerEntersWhisperV2 {
    const message = { ...basePlayerEntersWhisperV2 } as PlayerEntersWhisperV2;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.encIdTarget !== undefined && object.encIdTarget !== null) {
      message.encIdTarget = Number(object.encIdTarget);
    }
    if (object.whisperId !== undefined && object.whisperId !== null) {
      message.whisperId = String(object.whisperId);
    }
    return message;
  },

  toJSON(message: PlayerEntersWhisperV2): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.encIdTarget !== undefined && (obj.encIdTarget = message.encIdTarget);
    message.whisperId !== undefined && (obj.whisperId = message.whisperId);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerEntersWhisperV2>): PlayerEntersWhisperV2 {
    const message = { ...basePlayerEntersWhisperV2 } as PlayerEntersWhisperV2;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.encIdTarget !== undefined && object.encIdTarget !== null) {
      message.encIdTarget = object.encIdTarget;
    }
    if (object.whisperId !== undefined && object.whisperId !== null) {
      message.whisperId = object.whisperId;
    }
    return message;
  },
};

const basePlayerLeavesWhisper: object = { encId: 0 };

export const PlayerLeavesWhisper = {
  encode(message: PlayerLeavesWhisper, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerLeavesWhisper {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerLeavesWhisper } as PlayerLeavesWhisper;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerLeavesWhisper {
    const message = { ...basePlayerLeavesWhisper } as PlayerLeavesWhisper;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    return message;
  },

  toJSON(message: PlayerLeavesWhisper): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerLeavesWhisper>): PlayerLeavesWhisper {
    const message = { ...basePlayerLeavesWhisper } as PlayerLeavesWhisper;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    return message;
  },
};

const basePlayerActivelySpeaks: object = { encId: 0, activelySpeaking: 0 };

export const PlayerActivelySpeaks = {
  encode(message: PlayerActivelySpeaks, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.activelySpeaking !== 0) {
      writer.uint32(16).uint32(message.activelySpeaking);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerActivelySpeaks {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerActivelySpeaks } as PlayerActivelySpeaks;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.activelySpeaking = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerActivelySpeaks {
    const message = { ...basePlayerActivelySpeaks } as PlayerActivelySpeaks;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.activelySpeaking !== undefined && object.activelySpeaking !== null) {
      message.activelySpeaking = Number(object.activelySpeaking);
    }
    return message;
  },

  toJSON(message: PlayerActivelySpeaks): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.activelySpeaking !== undefined && (obj.activelySpeaking = message.activelySpeaking);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerActivelySpeaks>): PlayerActivelySpeaks {
    const message = { ...basePlayerActivelySpeaks } as PlayerActivelySpeaks;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.activelySpeaking !== undefined && object.activelySpeaking !== null) {
      message.activelySpeaking = object.activelySpeaking;
    }
    return message;
  },
};

const basePlayerSetsEmote: object = { encId: 0, emote: 0 };

export const PlayerSetsEmote = {
  encode(message: PlayerSetsEmote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.emote !== 0) {
      writer.uint32(16).int32(message.emote);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsEmote {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsEmote } as PlayerSetsEmote;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.emote = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsEmote {
    const message = { ...basePlayerSetsEmote } as PlayerSetsEmote;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.emote !== undefined && object.emote !== null) {
      message.emote = emoteEnum_ENUMFromJSON(object.emote);
    }
    return message;
  },

  toJSON(message: PlayerSetsEmote): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.emote !== undefined && (obj.emote = emoteEnum_ENUMToJSON(message.emote));
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsEmote>): PlayerSetsEmote {
    const message = { ...basePlayerSetsEmote } as PlayerSetsEmote;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.emote !== undefined && object.emote !== null) {
      message.emote = object.emote;
    }
    return message;
  },
};

const basePlayerSetsWorkCondition: object = { encId: 0, workCondition: 0 };

export const PlayerSetsWorkCondition = {
  encode(message: PlayerSetsWorkCondition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.workCondition !== 0) {
      writer.uint32(16).uint32(message.workCondition);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsWorkCondition {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsWorkCondition } as PlayerSetsWorkCondition;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.workCondition = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsWorkCondition {
    const message = { ...basePlayerSetsWorkCondition } as PlayerSetsWorkCondition;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.workCondition !== undefined && object.workCondition !== null) {
      message.workCondition = Number(object.workCondition);
    }
    return message;
  },

  toJSON(message: PlayerSetsWorkCondition): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.workCondition !== undefined && (obj.workCondition = message.workCondition);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsWorkCondition>): PlayerSetsWorkCondition {
    const message = { ...basePlayerSetsWorkCondition } as PlayerSetsWorkCondition;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.workCondition !== undefined && object.workCondition !== null) {
      message.workCondition = object.workCondition;
    }
    return message;
  },
};

const basePlayerSetsLastActive: object = { encId: 0, lastActive: "" };

export const PlayerSetsLastActive = {
  encode(message: PlayerSetsLastActive, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.lastActive !== "") {
      writer.uint32(18).string(message.lastActive);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsLastActive {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsLastActive } as PlayerSetsLastActive;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.lastActive = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsLastActive {
    const message = { ...basePlayerSetsLastActive } as PlayerSetsLastActive;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.lastActive !== undefined && object.lastActive !== null) {
      message.lastActive = String(object.lastActive);
    }
    return message;
  },

  toJSON(message: PlayerSetsLastActive): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.lastActive !== undefined && (obj.lastActive = message.lastActive);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsLastActive>): PlayerSetsLastActive {
    const message = { ...basePlayerSetsLastActive } as PlayerSetsLastActive;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.lastActive !== undefined && object.lastActive !== null) {
      message.lastActive = object.lastActive;
    }
    return message;
  },
};

const basePlayerSetsName: object = { encId: 0, name: "" };

export const PlayerSetsName = {
  encode(message: PlayerSetsName, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsName {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsName } as PlayerSetsName;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsName {
    const message = { ...basePlayerSetsName } as PlayerSetsName;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.name !== undefined && object.name !== null) {
      message.name = String(object.name);
    }
    return message;
  },

  toJSON(message: PlayerSetsName): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsName>): PlayerSetsName {
    const message = { ...basePlayerSetsName } as PlayerSetsName;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.name !== undefined && object.name !== null) {
      message.name = object.name;
    }
    return message;
  },
};

const basePlayerSetsTextStatus: object = { encId: 0, textStatus: "" };

export const PlayerSetsTextStatus = {
  encode(message: PlayerSetsTextStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.textStatus !== "") {
      writer.uint32(18).string(message.textStatus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsTextStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsTextStatus } as PlayerSetsTextStatus;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.textStatus = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsTextStatus {
    const message = { ...basePlayerSetsTextStatus } as PlayerSetsTextStatus;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.textStatus !== undefined && object.textStatus !== null) {
      message.textStatus = String(object.textStatus);
    }
    return message;
  },

  toJSON(message: PlayerSetsTextStatus): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.textStatus !== undefined && (obj.textStatus = message.textStatus);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsTextStatus>): PlayerSetsTextStatus {
    const message = { ...basePlayerSetsTextStatus } as PlayerSetsTextStatus;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.textStatus !== undefined && object.textStatus !== null) {
      message.textStatus = object.textStatus;
    }
    return message;
  },
};

const basePlayerSetsEmojiStatus: object = { encId: 0, emojiStatus: "" };

export const PlayerSetsEmojiStatus = {
  encode(message: PlayerSetsEmojiStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.emojiStatus !== "") {
      writer.uint32(18).string(message.emojiStatus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsEmojiStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsEmojiStatus } as PlayerSetsEmojiStatus;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.emojiStatus = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsEmojiStatus {
    const message = { ...basePlayerSetsEmojiStatus } as PlayerSetsEmojiStatus;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.emojiStatus !== undefined && object.emojiStatus !== null) {
      message.emojiStatus = String(object.emojiStatus);
    }
    return message;
  },

  toJSON(message: PlayerSetsEmojiStatus): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.emojiStatus !== undefined && (obj.emojiStatus = message.emojiStatus);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsEmojiStatus>): PlayerSetsEmojiStatus {
    const message = { ...basePlayerSetsEmojiStatus } as PlayerSetsEmojiStatus;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.emojiStatus !== undefined && object.emojiStatus !== null) {
      message.emojiStatus = object.emojiStatus;
    }
    return message;
  },
};

const basePlayerSetsAffiliation: object = { encId: 0, affiliation: "" };

export const PlayerSetsAffiliation = {
  encode(message: PlayerSetsAffiliation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.affiliation !== "") {
      writer.uint32(18).string(message.affiliation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsAffiliation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsAffiliation } as PlayerSetsAffiliation;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.affiliation = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsAffiliation {
    const message = { ...basePlayerSetsAffiliation } as PlayerSetsAffiliation;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.affiliation !== undefined && object.affiliation !== null) {
      message.affiliation = String(object.affiliation);
    }
    return message;
  },

  toJSON(message: PlayerSetsAffiliation): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.affiliation !== undefined && (obj.affiliation = message.affiliation);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsAffiliation>): PlayerSetsAffiliation {
    const message = { ...basePlayerSetsAffiliation } as PlayerSetsAffiliation;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.affiliation !== undefined && object.affiliation !== null) {
      message.affiliation = object.affiliation;
    }
    return message;
  },
};

const basePlayerExits: object = { encId: 0 };

export const PlayerExits = {
  encode(message: PlayerExits, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerExits {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerExits } as PlayerExits;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerExits {
    const message = { ...basePlayerExits } as PlayerExits;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    return message;
  },

  toJSON(message: PlayerExits): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerExits>): PlayerExits {
    const message = { ...basePlayerExits } as PlayerExits;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    return message;
  },
};

const basePlayerSetsSprite: object = { encId: 0, sprite: 0 };

export const PlayerSetsSprite = {
  encode(message: PlayerSetsSprite, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.sprite !== 0) {
      writer.uint32(16).uint32(message.sprite);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsSprite {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsSprite } as PlayerSetsSprite;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.sprite = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsSprite {
    const message = { ...basePlayerSetsSprite } as PlayerSetsSprite;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.sprite !== undefined && object.sprite !== null) {
      message.sprite = Number(object.sprite);
    }
    return message;
  },

  toJSON(message: PlayerSetsSprite): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.sprite !== undefined && (obj.sprite = message.sprite);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsSprite>): PlayerSetsSprite {
    const message = { ...basePlayerSetsSprite } as PlayerSetsSprite;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.sprite !== undefined && object.sprite !== null) {
      message.sprite = object.sprite;
    }
    return message;
  },
};

const basePlayerSetsOutfitString: object = { encId: 0, outfitString: "" };

export const PlayerSetsOutfitString = {
  encode(message: PlayerSetsOutfitString, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.outfitString !== "") {
      writer.uint32(18).string(message.outfitString);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsOutfitString {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsOutfitString } as PlayerSetsOutfitString;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.outfitString = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsOutfitString {
    const message = { ...basePlayerSetsOutfitString } as PlayerSetsOutfitString;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.outfitString !== undefined && object.outfitString !== null) {
      message.outfitString = String(object.outfitString);
    }
    return message;
  },

  toJSON(message: PlayerSetsOutfitString): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.outfitString !== undefined && (obj.outfitString = message.outfitString);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsOutfitString>): PlayerSetsOutfitString {
    const message = { ...basePlayerSetsOutfitString } as PlayerSetsOutfitString;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.outfitString !== undefined && object.outfitString !== null) {
      message.outfitString = object.outfitString;
    }
    return message;
  },
};

const basePlayerSetsIsSignedIn: object = { encId: 0, isSignedIn: false };

export const PlayerSetsIsSignedIn = {
  encode(message: PlayerSetsIsSignedIn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.isSignedIn === true) {
      writer.uint32(16).bool(message.isSignedIn);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsIsSignedIn {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsIsSignedIn } as PlayerSetsIsSignedIn;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.isSignedIn = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsIsSignedIn {
    const message = { ...basePlayerSetsIsSignedIn } as PlayerSetsIsSignedIn;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.isSignedIn !== undefined && object.isSignedIn !== null) {
      message.isSignedIn = Boolean(object.isSignedIn);
    }
    return message;
  },

  toJSON(message: PlayerSetsIsSignedIn): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.isSignedIn !== undefined && (obj.isSignedIn = message.isSignedIn);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsIsSignedIn>): PlayerSetsIsSignedIn {
    const message = { ...basePlayerSetsIsSignedIn } as PlayerSetsIsSignedIn;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.isSignedIn !== undefined && object.isSignedIn !== null) {
      message.isSignedIn = object.isSignedIn;
    }
    return message;
  },
};

const baseRespawnComplete: object = {};

export const RespawnComplete = {
  encode(_: RespawnComplete, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RespawnComplete {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseRespawnComplete } as RespawnComplete;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): RespawnComplete {
    const message = { ...baseRespawnComplete } as RespawnComplete;
    return message;
  },

  toJSON(_: RespawnComplete): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial(_: DeepPartial<RespawnComplete>): RespawnComplete {
    const message = { ...baseRespawnComplete } as RespawnComplete;
    return message;
  },
};

const baseMapUpdates: object = { mapId: "", diffJson: "" };

export const MapUpdates = {
  encode(message: MapUpdates, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.diffJson !== "") {
      writer.uint32(18).string(message.diffJson);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapUpdates {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapUpdates } as MapUpdates;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.diffJson = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapUpdates {
    const message = { ...baseMapUpdates } as MapUpdates;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.diffJson !== undefined && object.diffJson !== null) {
      message.diffJson = String(object.diffJson);
    }
    return message;
  },

  toJSON(message: MapUpdates): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.diffJson !== undefined && (obj.diffJson = message.diffJson);
    return obj;
  },

  fromPartial(object: DeepPartial<MapUpdates>): MapUpdates {
    const message = { ...baseMapUpdates } as MapUpdates;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.diffJson !== undefined && object.diffJson !== null) {
      message.diffJson = object.diffJson;
    }
    return message;
  },
};

const baseMapOverwrites: object = { mapId: "", mapJson: "" };

export const MapOverwrites = {
  encode(message: MapOverwrites, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.mapJson !== "") {
      writer.uint32(18).string(message.mapJson);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapOverwrites {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapOverwrites } as MapOverwrites;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.mapJson = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapOverwrites {
    const message = { ...baseMapOverwrites } as MapOverwrites;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.mapJson !== undefined && object.mapJson !== null) {
      message.mapJson = String(object.mapJson);
    }
    return message;
  },

  toJSON(message: MapOverwrites): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.mapJson !== undefined && (obj.mapJson = message.mapJson);
    return obj;
  },

  fromPartial(object: DeepPartial<MapOverwrites>): MapOverwrites {
    const message = { ...baseMapOverwrites } as MapOverwrites;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.mapJson !== undefined && object.mapJson !== null) {
      message.mapJson = object.mapJson;
    }
    return message;
  },
};

const baseSpaceOverwrites: object = { spaceData: "" };

export const SpaceOverwrites = {
  encode(message: SpaceOverwrites, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spaceData !== "") {
      writer.uint32(10).string(message.spaceData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpaceOverwrites {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSpaceOverwrites } as SpaceOverwrites;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.spaceData = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpaceOverwrites {
    const message = { ...baseSpaceOverwrites } as SpaceOverwrites;
    if (object.spaceData !== undefined && object.spaceData !== null) {
      message.spaceData = String(object.spaceData);
    }
    return message;
  },

  toJSON(message: SpaceOverwrites): unknown {
    const obj: any = {};
    message.spaceData !== undefined && (obj.spaceData = message.spaceData);
    return obj;
  },

  fromPartial(object: DeepPartial<SpaceOverwrites>): SpaceOverwrites {
    const message = { ...baseSpaceOverwrites } as SpaceOverwrites;
    if (object.spaceData !== undefined && object.spaceData !== null) {
      message.spaceData = object.spaceData;
    }
    return message;
  },
};

const baseSpaceIsClosed: object = {};

export const SpaceIsClosed = {
  encode(_: SpaceIsClosed, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpaceIsClosed {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSpaceIsClosed } as SpaceIsClosed;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): SpaceIsClosed {
    const message = { ...baseSpaceIsClosed } as SpaceIsClosed;
    return message;
  },

  toJSON(_: SpaceIsClosed): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial(_: DeepPartial<SpaceIsClosed>): SpaceIsClosed {
    const message = { ...baseSpaceIsClosed } as SpaceIsClosed;
    return message;
  },
};

const basePlayerEntersPortal: object = { targetUrl: "" };

export const PlayerEntersPortal = {
  encode(message: PlayerEntersPortal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetUrl !== "") {
      writer.uint32(10).string(message.targetUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerEntersPortal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerEntersPortal } as PlayerEntersPortal;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.targetUrl = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerEntersPortal {
    const message = { ...basePlayerEntersPortal } as PlayerEntersPortal;
    if (object.targetUrl !== undefined && object.targetUrl !== null) {
      message.targetUrl = String(object.targetUrl);
    }
    return message;
  },

  toJSON(message: PlayerEntersPortal): unknown {
    const obj: any = {};
    message.targetUrl !== undefined && (obj.targetUrl = message.targetUrl);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerEntersPortal>): PlayerEntersPortal {
    const message = { ...basePlayerEntersPortal } as PlayerEntersPortal;
    if (object.targetUrl !== undefined && object.targetUrl !== null) {
      message.targetUrl = object.targetUrl;
    }
    return message;
  },
};

const baseCookieFound: object = { encId: 0 };

export const CookieFound = {
  encode(message: CookieFound, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CookieFound {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseCookieFound } as CookieFound;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CookieFound {
    const message = { ...baseCookieFound } as CookieFound;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    return message;
  },

  toJSON(message: CookieFound): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    return obj;
  },

  fromPartial(object: DeepPartial<CookieFound>): CookieFound {
    const message = { ...baseCookieFound } as CookieFound;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    return message;
  },
};

const baseSpaceSetsIdMapping: object = { uid: "", encId: 0 };

export const SpaceSetsIdMapping = {
  encode(message: SpaceSetsIdMapping, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    if (message.encId !== 0) {
      writer.uint32(16).uint32(message.encId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpaceSetsIdMapping {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSpaceSetsIdMapping } as SpaceSetsIdMapping;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.uid = reader.string();
          break;
        case 2:
          message.encId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpaceSetsIdMapping {
    const message = { ...baseSpaceSetsIdMapping } as SpaceSetsIdMapping;
    if (object.uid !== undefined && object.uid !== null) {
      message.uid = String(object.uid);
    }
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    return message;
  },

  toJSON(message: SpaceSetsIdMapping): unknown {
    const obj: any = {};
    message.uid !== undefined && (obj.uid = message.uid);
    message.encId !== undefined && (obj.encId = message.encId);
    return obj;
  },

  fromPartial(object: DeepPartial<SpaceSetsIdMapping>): SpaceSetsIdMapping {
    const message = { ...baseSpaceSetsIdMapping } as SpaceSetsIdMapping;
    if (object.uid !== undefined && object.uid !== null) {
      message.uid = object.uid;
    }
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    return message;
  },
};

const basePlayerShootsConfetti: object = { encId: 0 };

export const PlayerShootsConfetti = {
  encode(message: PlayerShootsConfetti, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerShootsConfetti {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerShootsConfetti } as PlayerShootsConfetti;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerShootsConfetti {
    const message = { ...basePlayerShootsConfetti } as PlayerShootsConfetti;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    return message;
  },

  toJSON(message: PlayerShootsConfetti): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerShootsConfetti>): PlayerShootsConfetti {
    const message = { ...basePlayerShootsConfetti } as PlayerShootsConfetti;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    return message;
  },
};

const basePlayerSetsEventStatus: object = { encId: 0, eventStatus: "" };

export const PlayerSetsEventStatus = {
  encode(message: PlayerSetsEventStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.eventStatus !== "") {
      writer.uint32(18).string(message.eventStatus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsEventStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsEventStatus } as PlayerSetsEventStatus;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.eventStatus = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsEventStatus {
    const message = { ...basePlayerSetsEventStatus } as PlayerSetsEventStatus;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.eventStatus !== undefined && object.eventStatus !== null) {
      message.eventStatus = String(object.eventStatus);
    }
    return message;
  },

  toJSON(message: PlayerSetsEventStatus): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.eventStatus !== undefined && (obj.eventStatus = message.eventStatus);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsEventStatus>): PlayerSetsEventStatus {
    const message = { ...basePlayerSetsEventStatus } as PlayerSetsEventStatus;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.eventStatus !== undefined && object.eventStatus !== null) {
      message.eventStatus = object.eventStatus;
    }
    return message;
  },
};

const basePlayerSetsInConversation: object = { encId: 0, inConversation: false };

export const PlayerSetsInConversation = {
  encode(message: PlayerSetsInConversation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.inConversation === true) {
      writer.uint32(16).bool(message.inConversation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsInConversation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsInConversation } as PlayerSetsInConversation;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.inConversation = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsInConversation {
    const message = { ...basePlayerSetsInConversation } as PlayerSetsInConversation;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.inConversation !== undefined && object.inConversation !== null) {
      message.inConversation = Boolean(object.inConversation);
    }
    return message;
  },

  toJSON(message: PlayerSetsInConversation): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.inConversation !== undefined && (obj.inConversation = message.inConversation);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsInConversation>): PlayerSetsInConversation {
    const message = { ...basePlayerSetsInConversation } as PlayerSetsInConversation;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.inConversation !== undefined && object.inConversation !== null) {
      message.inConversation = object.inConversation;
    }
    return message;
  },
};

const basePlayerSetsCurrentDesk: object = { encId: 0, currentDesk: "" };

export const PlayerSetsCurrentDesk = {
  encode(message: PlayerSetsCurrentDesk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.currentDesk !== "") {
      writer.uint32(18).string(message.currentDesk);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsCurrentDesk {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsCurrentDesk } as PlayerSetsCurrentDesk;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.currentDesk = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsCurrentDesk {
    const message = { ...basePlayerSetsCurrentDesk } as PlayerSetsCurrentDesk;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.currentDesk !== undefined && object.currentDesk !== null) {
      message.currentDesk = String(object.currentDesk);
    }
    return message;
  },

  toJSON(message: PlayerSetsCurrentDesk): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.currentDesk !== undefined && (obj.currentDesk = message.currentDesk);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsCurrentDesk>): PlayerSetsCurrentDesk {
    const message = { ...basePlayerSetsCurrentDesk } as PlayerSetsCurrentDesk;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.currentDesk !== undefined && object.currentDesk !== null) {
      message.currentDesk = object.currentDesk;
    }
    return message;
  },
};

const basePlayerSetsCurrentArea: object = { encId: 0, currentArea: "" };

export const PlayerSetsCurrentArea = {
  encode(message: PlayerSetsCurrentArea, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.currentArea !== "") {
      writer.uint32(18).string(message.currentArea);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsCurrentArea {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsCurrentArea } as PlayerSetsCurrentArea;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.currentArea = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsCurrentArea {
    const message = { ...basePlayerSetsCurrentArea } as PlayerSetsCurrentArea;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.currentArea !== undefined && object.currentArea !== null) {
      message.currentArea = String(object.currentArea);
    }
    return message;
  },

  toJSON(message: PlayerSetsCurrentArea): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.currentArea !== undefined && (obj.currentArea = message.currentArea);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsCurrentArea>): PlayerSetsCurrentArea {
    const message = { ...basePlayerSetsCurrentArea } as PlayerSetsCurrentArea;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.currentArea !== undefined && object.currentArea !== null) {
      message.currentArea = object.currentArea;
    }
    return message;
  },
};

const basePlayerSetsGoKartId: object = { encId: 0, goKartId: "" };

export const PlayerSetsGoKartId = {
  encode(message: PlayerSetsGoKartId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encId !== 0) {
      writer.uint32(8).uint32(message.encId);
    }
    if (message.goKartId !== "") {
      writer.uint32(18).string(message.goKartId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSetsGoKartId {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePlayerSetsGoKartId } as PlayerSetsGoKartId;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.encId = reader.uint32();
          break;
        case 2:
          message.goKartId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSetsGoKartId {
    const message = { ...basePlayerSetsGoKartId } as PlayerSetsGoKartId;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = Number(object.encId);
    }
    if (object.goKartId !== undefined && object.goKartId !== null) {
      message.goKartId = String(object.goKartId);
    }
    return message;
  },

  toJSON(message: PlayerSetsGoKartId): unknown {
    const obj: any = {};
    message.encId !== undefined && (obj.encId = message.encId);
    message.goKartId !== undefined && (obj.goKartId = message.goKartId);
    return obj;
  },

  fromPartial(object: DeepPartial<PlayerSetsGoKartId>): PlayerSetsGoKartId {
    const message = { ...basePlayerSetsGoKartId } as PlayerSetsGoKartId;
    if (object.encId !== undefined && object.encId !== null) {
      message.encId = object.encId;
    }
    if (object.goKartId !== undefined && object.goKartId !== null) {
      message.goKartId = object.goKartId;
    }
    return message;
  },
};

const baseClientServerBatch: object = {};

export const ClientServerBatch = {
  encode(message: ClientServerBatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.actions) {
      ClientServerAction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClientServerBatch {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseClientServerBatch } as ClientServerBatch;
    message.actions = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actions.push(ClientServerAction.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ClientServerBatch {
    const message = { ...baseClientServerBatch } as ClientServerBatch;
    message.actions = [];
    if (object.actions !== undefined && object.actions !== null) {
      for (const e of object.actions) {
        message.actions.push(ClientServerAction.fromJSON(e));
      }
    }
    return message;
  },

  toJSON(message: ClientServerBatch): unknown {
    const obj: any = {};
    if (message.actions) {
      obj.actions = message.actions.map((e) => (e ? ClientServerAction.toJSON(e) : undefined));
    } else {
      obj.actions = [];
    }
    return obj;
  },

  fromPartial(object: DeepPartial<ClientServerBatch>): ClientServerBatch {
    const message = { ...baseClientServerBatch } as ClientServerBatch;
    message.actions = [];
    if (object.actions !== undefined && object.actions !== null) {
      for (const e of object.actions) {
        message.actions.push(ClientServerAction.fromPartial(e));
      }
    }
    return message;
  },
};

const baseClientServerAction: object = {};

export const ClientServerAction = {
  encode(message: ClientServerAction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.action?.$case === "clientHeartbeat") {
      ClientHeartbeat.encode(message.action.clientHeartbeat, writer.uint32(10).fork()).ldelim();
    }
    if (message.action?.$case === "updateSubscriptions") {
      UpdateSubscriptions.encode(
        message.action.updateSubscriptions,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    if (message.action?.$case === "move") {
      Move.encode(message.action.move, writer.uint32(42).fork()).ldelim();
    }
    if (message.action?.$case === "setSprite") {
      SetSprite.encode(message.action.setSprite, writer.uint32(50).fork()).ldelim();
    }
    if (message.action?.$case === "setAffiliation") {
      SetAffiliation.encode(message.action.setAffiliation, writer.uint32(58).fork()).ldelim();
    }
    if (message.action?.$case === "setStatus") {
      SetStatus.encode(message.action.setStatus, writer.uint32(66).fork()).ldelim();
    }
    if (message.action?.$case === "spotlight") {
      Spotlight.encode(message.action.spotlight, writer.uint32(74).fork()).ldelim();
    }
    if (message.action?.$case === "ring") {
      Ring.encode(message.action.ring, writer.uint32(82).fork()).ldelim();
    }
    if (message.action?.$case === "setPointer") {
      SetPointer.encode(message.action.setPointer, writer.uint32(90).fork()).ldelim();
    }
    if (message.action?.$case === "ban") {
      Ban.encode(message.action.ban, writer.uint32(98).fork()).ldelim();
    }
    if (message.action?.$case === "kick") {
      Kick.encode(message.action.kick, writer.uint32(106).fork()).ldelim();
    }
    if (message.action?.$case === "setImpassable") {
      SetImpassable.encode(message.action.setImpassable, writer.uint32(114).fork()).ldelim();
    }
    if (message.action?.$case === "chat") {
      Chat.encode(message.action.chat, writer.uint32(122).fork()).ldelim();
    }
    if (message.action?.$case === "setObject") {
      SetObject.encode(message.action.setObject, writer.uint32(130).fork()).ldelim();
    }
    if (message.action?.$case === "deleteObject") {
      DeleteObject.encode(message.action.deleteObject, writer.uint32(138).fork()).ldelim();
    }
    if (message.action?.$case === "interact") {
      Interact.encode(message.action.interact, writer.uint32(146).fork()).ldelim();
    }
    if (message.action?.$case === "enterWhisper") {
      EnterWhisper.encode(message.action.enterWhisper, writer.uint32(154).fork()).ldelim();
    }
    if (message.action?.$case === "leaveWhisper") {
      LeaveWhisper.encode(message.action.leaveWhisper, writer.uint32(162).fork()).ldelim();
    }
    if (message.action?.$case === "setEmojiStatus") {
      SetEmojiStatus.encode(message.action.setEmojiStatus, writer.uint32(170).fork()).ldelim();
    }
    if (message.action?.$case === "activelySpeaking") {
      ActivelySpeaking.encode(message.action.activelySpeaking, writer.uint32(178).fork()).ldelim();
    }
    if (message.action?.$case === "setEmote") {
      SetEmote.encode(message.action.setEmote, writer.uint32(186).fork()).ldelim();
    }
    if (message.action?.$case === "setName") {
      SetName.encode(message.action.setName, writer.uint32(194).fork()).ldelim();
    }
    if (message.action?.$case === "setTextStatus") {
      SetTextStatus.encode(message.action.setTextStatus, writer.uint32(202).fork()).ldelim();
    }
    if (message.action?.$case === "teleport") {
      Teleport.encode(message.action.teleport, writer.uint32(210).fork()).ldelim();
    }
    if (message.action?.$case === "exit") {
      Exit.encode(message.action.exit, writer.uint32(218).fork()).ldelim();
    }
    if (message.action?.$case === "enter") {
      Enter.encode(message.action.enter, writer.uint32(226).fork()).ldelim();
    }
    if (message.action?.$case === "setWorkCondition") {
      SetWorkCondition.encode(message.action.setWorkCondition, writer.uint32(234).fork()).ldelim();
    }
    if (message.action?.$case === "respawn") {
      Respawn.encode(message.action.respawn, writer.uint32(242).fork()).ldelim();
    }
    if (message.action?.$case === "spawn") {
      Spawn.encode(message.action.spawn, writer.uint32(250).fork()).ldelim();
    }
    if (message.action?.$case === "ghost") {
      Ghost.encode(message.action.ghost, writer.uint32(258).fork()).ldelim();
    }
    if (message.action?.$case === "init") {
      Init.encode(message.action.init, writer.uint32(266).fork()).ldelim();
    }
    if (message.action?.$case === "setOutfitString") {
      SetOutfitString.encode(message.action.setOutfitString, writer.uint32(274).fork()).ldelim();
    }
    if (message.action?.$case === "mapUpdate") {
      MapUpdate.encode(message.action.mapUpdate, writer.uint32(282).fork()).ldelim();
    }
    if (message.action?.$case === "shootConfetti") {
      ShootConfetti.encode(message.action.shootConfetti, writer.uint32(290).fork()).ldelim();
    }
    if (message.action?.$case === "setEventStatus") {
      SetEventStatus.encode(message.action.setEventStatus, writer.uint32(298).fork()).ldelim();
    }
    if (message.action?.$case === "setInConversation") {
      SetInConversation.encode(
        message.action.setInConversation,
        writer.uint32(306).fork(),
      ).ldelim();
    }
    if (message.action?.$case === "setCurrentDesk") {
      SetCurrentDesk.encode(message.action.setCurrentDesk, writer.uint32(314).fork()).ldelim();
    }
    if (message.action?.$case === "setCurrentArea") {
      SetCurrentArea.encode(message.action.setCurrentArea, writer.uint32(322).fork()).ldelim();
    }
    if (message.action?.$case === "setImagePointer") {
      SetImagePointer.encode(message.action.setImagePointer, writer.uint32(330).fork()).ldelim();
    }
    if (message.action?.$case === "setGoKartId") {
      SetGoKartId.encode(message.action.setGoKartId, writer.uint32(338).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetDimensions") {
      MapSetDimensions.encode(message.action.mapSetDimensions, writer.uint32(346).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetCollisions") {
      MapSetCollisions.encode(message.action.mapSetCollisions, writer.uint32(354).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetBackgroundImagePath") {
      MapSetBackgroundImagePath.encode(
        message.action.mapSetBackgroundImagePath,
        writer.uint32(362).fork(),
      ).ldelim();
    }
    if (message.action?.$case === "mapSetForegroundImagePath") {
      MapSetForegroundImagePath.encode(
        message.action.mapSetForegroundImagePath,
        writer.uint32(370).fork(),
      ).ldelim();
    }
    if (message.action?.$case === "mapSetSprites") {
      MapSetSprites.encode(message.action.mapSetSprites, writer.uint32(378).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetSpawns") {
      MapSetSpawns.encode(message.action.mapSetSpawns, writer.uint32(386).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetSpaces") {
      MapSetSpaces.encode(message.action.mapSetSpaces, writer.uint32(394).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetPortals") {
      MapSetPortals.encode(message.action.mapSetPortals, writer.uint32(402).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetAnnouncer") {
      MapSetAnnouncer.encode(message.action.mapSetAnnouncer, writer.uint32(410).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetAudio") {
      MapSetAudio.encode(message.action.mapSetAudio, writer.uint32(418).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetAnimations") {
      MapSetAnimations.encode(message.action.mapSetAnimations, writer.uint32(426).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetAssets") {
      MapSetAssets.encode(message.action.mapSetAssets, writer.uint32(434).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetObjects") {
      MapSetObjects.encode(message.action.mapSetObjects, writer.uint32(442).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetName") {
      MapSetName.encode(message.action.mapSetName, writer.uint32(450).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetDefaultChat") {
      MapSetDefaultChat.encode(
        message.action.mapSetDefaultChat,
        writer.uint32(458).fork(),
      ).ldelim();
    }
    if (message.action?.$case === "mapSetMuteOnEntry") {
      MapSetMuteOnEntry.encode(
        message.action.mapSetMuteOnEntry,
        writer.uint32(466).fork(),
      ).ldelim();
    }
    if (message.action?.$case === "mapSetUseDrawnBG") {
      MapSetUseDrawnBG.encode(message.action.mapSetUseDrawnBG, writer.uint32(474).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetWalls") {
      MapSetWalls.encode(message.action.mapSetWalls, writer.uint32(482).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetFloors") {
      MapSetFloors.encode(message.action.mapSetFloors, writer.uint32(490).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetAreas") {
      MapSetAreas.encode(message.action.mapSetAreas, writer.uint32(498).fork()).ldelim();
    }
    if (message.action?.$case === "mapAddObject") {
      MapAddObject.encode(message.action.mapAddObject, writer.uint32(506).fork()).ldelim();
    }
    if (message.action?.$case === "mapDeleteObject") {
      MapDeleteObject.encode(message.action.mapDeleteObject, writer.uint32(514).fork()).ldelim();
    }
    if (message.action?.$case === "mapSetSpawn") {
      MapSetSpawn.encode(message.action.mapSetSpawn, writer.uint32(522).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClientServerAction {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseClientServerAction } as ClientServerAction;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.action = {
            $case: "clientHeartbeat",
            clientHeartbeat: ClientHeartbeat.decode(reader, reader.uint32()),
          };
          break;
        case 3:
          message.action = {
            $case: "updateSubscriptions",
            updateSubscriptions: UpdateSubscriptions.decode(reader, reader.uint32()),
          };
          break;
        case 5:
          message.action = { $case: "move", move: Move.decode(reader, reader.uint32()) };
          break;
        case 6:
          message.action = {
            $case: "setSprite",
            setSprite: SetSprite.decode(reader, reader.uint32()),
          };
          break;
        case 7:
          message.action = {
            $case: "setAffiliation",
            setAffiliation: SetAffiliation.decode(reader, reader.uint32()),
          };
          break;
        case 8:
          message.action = {
            $case: "setStatus",
            setStatus: SetStatus.decode(reader, reader.uint32()),
          };
          break;
        case 9:
          message.action = {
            $case: "spotlight",
            spotlight: Spotlight.decode(reader, reader.uint32()),
          };
          break;
        case 10:
          message.action = { $case: "ring", ring: Ring.decode(reader, reader.uint32()) };
          break;
        case 11:
          message.action = {
            $case: "setPointer",
            setPointer: SetPointer.decode(reader, reader.uint32()),
          };
          break;
        case 12:
          message.action = { $case: "ban", ban: Ban.decode(reader, reader.uint32()) };
          break;
        case 13:
          message.action = { $case: "kick", kick: Kick.decode(reader, reader.uint32()) };
          break;
        case 14:
          message.action = {
            $case: "setImpassable",
            setImpassable: SetImpassable.decode(reader, reader.uint32()),
          };
          break;
        case 15:
          message.action = { $case: "chat", chat: Chat.decode(reader, reader.uint32()) };
          break;
        case 16:
          message.action = {
            $case: "setObject",
            setObject: SetObject.decode(reader, reader.uint32()),
          };
          break;
        case 17:
          message.action = {
            $case: "deleteObject",
            deleteObject: DeleteObject.decode(reader, reader.uint32()),
          };
          break;
        case 18:
          message.action = {
            $case: "interact",
            interact: Interact.decode(reader, reader.uint32()),
          };
          break;
        case 19:
          message.action = {
            $case: "enterWhisper",
            enterWhisper: EnterWhisper.decode(reader, reader.uint32()),
          };
          break;
        case 20:
          message.action = {
            $case: "leaveWhisper",
            leaveWhisper: LeaveWhisper.decode(reader, reader.uint32()),
          };
          break;
        case 21:
          message.action = {
            $case: "setEmojiStatus",
            setEmojiStatus: SetEmojiStatus.decode(reader, reader.uint32()),
          };
          break;
        case 22:
          message.action = {
            $case: "activelySpeaking",
            activelySpeaking: ActivelySpeaking.decode(reader, reader.uint32()),
          };
          break;
        case 23:
          message.action = {
            $case: "setEmote",
            setEmote: SetEmote.decode(reader, reader.uint32()),
          };
          break;
        case 24:
          message.action = { $case: "setName", setName: SetName.decode(reader, reader.uint32()) };
          break;
        case 25:
          message.action = {
            $case: "setTextStatus",
            setTextStatus: SetTextStatus.decode(reader, reader.uint32()),
          };
          break;
        case 26:
          message.action = {
            $case: "teleport",
            teleport: Teleport.decode(reader, reader.uint32()),
          };
          break;
        case 27:
          message.action = { $case: "exit", exit: Exit.decode(reader, reader.uint32()) };
          break;
        case 28:
          message.action = { $case: "enter", enter: Enter.decode(reader, reader.uint32()) };
          break;
        case 29:
          message.action = {
            $case: "setWorkCondition",
            setWorkCondition: SetWorkCondition.decode(reader, reader.uint32()),
          };
          break;
        case 30:
          message.action = { $case: "respawn", respawn: Respawn.decode(reader, reader.uint32()) };
          break;
        case 31:
          message.action = { $case: "spawn", spawn: Spawn.decode(reader, reader.uint32()) };
          break;
        case 32:
          message.action = { $case: "ghost", ghost: Ghost.decode(reader, reader.uint32()) };
          break;
        case 33:
          message.action = { $case: "init", init: Init.decode(reader, reader.uint32()) };
          break;
        case 34:
          message.action = {
            $case: "setOutfitString",
            setOutfitString: SetOutfitString.decode(reader, reader.uint32()),
          };
          break;
        case 35:
          message.action = {
            $case: "mapUpdate",
            mapUpdate: MapUpdate.decode(reader, reader.uint32()),
          };
          break;
        case 36:
          message.action = {
            $case: "shootConfetti",
            shootConfetti: ShootConfetti.decode(reader, reader.uint32()),
          };
          break;
        case 37:
          message.action = {
            $case: "setEventStatus",
            setEventStatus: SetEventStatus.decode(reader, reader.uint32()),
          };
          break;
        case 38:
          message.action = {
            $case: "setInConversation",
            setInConversation: SetInConversation.decode(reader, reader.uint32()),
          };
          break;
        case 39:
          message.action = {
            $case: "setCurrentDesk",
            setCurrentDesk: SetCurrentDesk.decode(reader, reader.uint32()),
          };
          break;
        case 40:
          message.action = {
            $case: "setCurrentArea",
            setCurrentArea: SetCurrentArea.decode(reader, reader.uint32()),
          };
          break;
        case 41:
          message.action = {
            $case: "setImagePointer",
            setImagePointer: SetImagePointer.decode(reader, reader.uint32()),
          };
          break;
        case 42:
          message.action = {
            $case: "setGoKartId",
            setGoKartId: SetGoKartId.decode(reader, reader.uint32()),
          };
          break;
        case 43:
          message.action = {
            $case: "mapSetDimensions",
            mapSetDimensions: MapSetDimensions.decode(reader, reader.uint32()),
          };
          break;
        case 44:
          message.action = {
            $case: "mapSetCollisions",
            mapSetCollisions: MapSetCollisions.decode(reader, reader.uint32()),
          };
          break;
        case 45:
          message.action = {
            $case: "mapSetBackgroundImagePath",
            mapSetBackgroundImagePath: MapSetBackgroundImagePath.decode(reader, reader.uint32()),
          };
          break;
        case 46:
          message.action = {
            $case: "mapSetForegroundImagePath",
            mapSetForegroundImagePath: MapSetForegroundImagePath.decode(reader, reader.uint32()),
          };
          break;
        case 47:
          message.action = {
            $case: "mapSetSprites",
            mapSetSprites: MapSetSprites.decode(reader, reader.uint32()),
          };
          break;
        case 48:
          message.action = {
            $case: "mapSetSpawns",
            mapSetSpawns: MapSetSpawns.decode(reader, reader.uint32()),
          };
          break;
        case 49:
          message.action = {
            $case: "mapSetSpaces",
            mapSetSpaces: MapSetSpaces.decode(reader, reader.uint32()),
          };
          break;
        case 50:
          message.action = {
            $case: "mapSetPortals",
            mapSetPortals: MapSetPortals.decode(reader, reader.uint32()),
          };
          break;
        case 51:
          message.action = {
            $case: "mapSetAnnouncer",
            mapSetAnnouncer: MapSetAnnouncer.decode(reader, reader.uint32()),
          };
          break;
        case 52:
          message.action = {
            $case: "mapSetAudio",
            mapSetAudio: MapSetAudio.decode(reader, reader.uint32()),
          };
          break;
        case 53:
          message.action = {
            $case: "mapSetAnimations",
            mapSetAnimations: MapSetAnimations.decode(reader, reader.uint32()),
          };
          break;
        case 54:
          message.action = {
            $case: "mapSetAssets",
            mapSetAssets: MapSetAssets.decode(reader, reader.uint32()),
          };
          break;
        case 55:
          message.action = {
            $case: "mapSetObjects",
            mapSetObjects: MapSetObjects.decode(reader, reader.uint32()),
          };
          break;
        case 56:
          message.action = {
            $case: "mapSetName",
            mapSetName: MapSetName.decode(reader, reader.uint32()),
          };
          break;
        case 57:
          message.action = {
            $case: "mapSetDefaultChat",
            mapSetDefaultChat: MapSetDefaultChat.decode(reader, reader.uint32()),
          };
          break;
        case 58:
          message.action = {
            $case: "mapSetMuteOnEntry",
            mapSetMuteOnEntry: MapSetMuteOnEntry.decode(reader, reader.uint32()),
          };
          break;
        case 59:
          message.action = {
            $case: "mapSetUseDrawnBG",
            mapSetUseDrawnBG: MapSetUseDrawnBG.decode(reader, reader.uint32()),
          };
          break;
        case 60:
          message.action = {
            $case: "mapSetWalls",
            mapSetWalls: MapSetWalls.decode(reader, reader.uint32()),
          };
          break;
        case 61:
          message.action = {
            $case: "mapSetFloors",
            mapSetFloors: MapSetFloors.decode(reader, reader.uint32()),
          };
          break;
        case 62:
          message.action = {
            $case: "mapSetAreas",
            mapSetAreas: MapSetAreas.decode(reader, reader.uint32()),
          };
          break;
        case 63:
          message.action = {
            $case: "mapAddObject",
            mapAddObject: MapAddObject.decode(reader, reader.uint32()),
          };
          break;
        case 64:
          message.action = {
            $case: "mapDeleteObject",
            mapDeleteObject: MapDeleteObject.decode(reader, reader.uint32()),
          };
          break;
        case 65:
          message.action = {
            $case: "mapSetSpawn",
            mapSetSpawn: MapSetSpawn.decode(reader, reader.uint32()),
          };
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ClientServerAction {
    const message = { ...baseClientServerAction } as ClientServerAction;
    if (object.clientHeartbeat !== undefined && object.clientHeartbeat !== null) {
      message.action = {
        $case: "clientHeartbeat",
        clientHeartbeat: ClientHeartbeat.fromJSON(object.clientHeartbeat),
      };
    }
    if (object.updateSubscriptions !== undefined && object.updateSubscriptions !== null) {
      message.action = {
        $case: "updateSubscriptions",
        updateSubscriptions: UpdateSubscriptions.fromJSON(object.updateSubscriptions),
      };
    }
    if (object.move !== undefined && object.move !== null) {
      message.action = { $case: "move", move: Move.fromJSON(object.move) };
    }
    if (object.setSprite !== undefined && object.setSprite !== null) {
      message.action = { $case: "setSprite", setSprite: SetSprite.fromJSON(object.setSprite) };
    }
    if (object.setAffiliation !== undefined && object.setAffiliation !== null) {
      message.action = {
        $case: "setAffiliation",
        setAffiliation: SetAffiliation.fromJSON(object.setAffiliation),
      };
    }
    if (object.setStatus !== undefined && object.setStatus !== null) {
      message.action = { $case: "setStatus", setStatus: SetStatus.fromJSON(object.setStatus) };
    }
    if (object.spotlight !== undefined && object.spotlight !== null) {
      message.action = { $case: "spotlight", spotlight: Spotlight.fromJSON(object.spotlight) };
    }
    if (object.ring !== undefined && object.ring !== null) {
      message.action = { $case: "ring", ring: Ring.fromJSON(object.ring) };
    }
    if (object.setPointer !== undefined && object.setPointer !== null) {
      message.action = { $case: "setPointer", setPointer: SetPointer.fromJSON(object.setPointer) };
    }
    if (object.ban !== undefined && object.ban !== null) {
      message.action = { $case: "ban", ban: Ban.fromJSON(object.ban) };
    }
    if (object.kick !== undefined && object.kick !== null) {
      message.action = { $case: "kick", kick: Kick.fromJSON(object.kick) };
    }
    if (object.setImpassable !== undefined && object.setImpassable !== null) {
      message.action = {
        $case: "setImpassable",
        setImpassable: SetImpassable.fromJSON(object.setImpassable),
      };
    }
    if (object.chat !== undefined && object.chat !== null) {
      message.action = { $case: "chat", chat: Chat.fromJSON(object.chat) };
    }
    if (object.setObject !== undefined && object.setObject !== null) {
      message.action = { $case: "setObject", setObject: SetObject.fromJSON(object.setObject) };
    }
    if (object.deleteObject !== undefined && object.deleteObject !== null) {
      message.action = {
        $case: "deleteObject",
        deleteObject: DeleteObject.fromJSON(object.deleteObject),
      };
    }
    if (object.interact !== undefined && object.interact !== null) {
      message.action = { $case: "interact", interact: Interact.fromJSON(object.interact) };
    }
    if (object.enterWhisper !== undefined && object.enterWhisper !== null) {
      message.action = {
        $case: "enterWhisper",
        enterWhisper: EnterWhisper.fromJSON(object.enterWhisper),
      };
    }
    if (object.leaveWhisper !== undefined && object.leaveWhisper !== null) {
      message.action = {
        $case: "leaveWhisper",
        leaveWhisper: LeaveWhisper.fromJSON(object.leaveWhisper),
      };
    }
    if (object.setEmojiStatus !== undefined && object.setEmojiStatus !== null) {
      message.action = {
        $case: "setEmojiStatus",
        setEmojiStatus: SetEmojiStatus.fromJSON(object.setEmojiStatus),
      };
    }
    if (object.activelySpeaking !== undefined && object.activelySpeaking !== null) {
      message.action = {
        $case: "activelySpeaking",
        activelySpeaking: ActivelySpeaking.fromJSON(object.activelySpeaking),
      };
    }
    if (object.setEmote !== undefined && object.setEmote !== null) {
      message.action = { $case: "setEmote", setEmote: SetEmote.fromJSON(object.setEmote) };
    }
    if (object.setName !== undefined && object.setName !== null) {
      message.action = { $case: "setName", setName: SetName.fromJSON(object.setName) };
    }
    if (object.setTextStatus !== undefined && object.setTextStatus !== null) {
      message.action = {
        $case: "setTextStatus",
        setTextStatus: SetTextStatus.fromJSON(object.setTextStatus),
      };
    }
    if (object.teleport !== undefined && object.teleport !== null) {
      message.action = { $case: "teleport", teleport: Teleport.fromJSON(object.teleport) };
    }
    if (object.exit !== undefined && object.exit !== null) {
      message.action = { $case: "exit", exit: Exit.fromJSON(object.exit) };
    }
    if (object.enter !== undefined && object.enter !== null) {
      message.action = { $case: "enter", enter: Enter.fromJSON(object.enter) };
    }
    if (object.setWorkCondition !== undefined && object.setWorkCondition !== null) {
      message.action = {
        $case: "setWorkCondition",
        setWorkCondition: SetWorkCondition.fromJSON(object.setWorkCondition),
      };
    }
    if (object.respawn !== undefined && object.respawn !== null) {
      message.action = { $case: "respawn", respawn: Respawn.fromJSON(object.respawn) };
    }
    if (object.spawn !== undefined && object.spawn !== null) {
      message.action = { $case: "spawn", spawn: Spawn.fromJSON(object.spawn) };
    }
    if (object.ghost !== undefined && object.ghost !== null) {
      message.action = { $case: "ghost", ghost: Ghost.fromJSON(object.ghost) };
    }
    if (object.init !== undefined && object.init !== null) {
      message.action = { $case: "init", init: Init.fromJSON(object.init) };
    }
    if (object.setOutfitString !== undefined && object.setOutfitString !== null) {
      message.action = {
        $case: "setOutfitString",
        setOutfitString: SetOutfitString.fromJSON(object.setOutfitString),
      };
    }
    if (object.mapUpdate !== undefined && object.mapUpdate !== null) {
      message.action = { $case: "mapUpdate", mapUpdate: MapUpdate.fromJSON(object.mapUpdate) };
    }
    if (object.shootConfetti !== undefined && object.shootConfetti !== null) {
      message.action = {
        $case: "shootConfetti",
        shootConfetti: ShootConfetti.fromJSON(object.shootConfetti),
      };
    }
    if (object.setEventStatus !== undefined && object.setEventStatus !== null) {
      message.action = {
        $case: "setEventStatus",
        setEventStatus: SetEventStatus.fromJSON(object.setEventStatus),
      };
    }
    if (object.setInConversation !== undefined && object.setInConversation !== null) {
      message.action = {
        $case: "setInConversation",
        setInConversation: SetInConversation.fromJSON(object.setInConversation),
      };
    }
    if (object.setCurrentDesk !== undefined && object.setCurrentDesk !== null) {
      message.action = {
        $case: "setCurrentDesk",
        setCurrentDesk: SetCurrentDesk.fromJSON(object.setCurrentDesk),
      };
    }
    if (object.setCurrentArea !== undefined && object.setCurrentArea !== null) {
      message.action = {
        $case: "setCurrentArea",
        setCurrentArea: SetCurrentArea.fromJSON(object.setCurrentArea),
      };
    }
    if (object.setImagePointer !== undefined && object.setImagePointer !== null) {
      message.action = {
        $case: "setImagePointer",
        setImagePointer: SetImagePointer.fromJSON(object.setImagePointer),
      };
    }
    if (object.setGoKartId !== undefined && object.setGoKartId !== null) {
      message.action = {
        $case: "setGoKartId",
        setGoKartId: SetGoKartId.fromJSON(object.setGoKartId),
      };
    }
    if (object.mapSetDimensions !== undefined && object.mapSetDimensions !== null) {
      message.action = {
        $case: "mapSetDimensions",
        mapSetDimensions: MapSetDimensions.fromJSON(object.mapSetDimensions),
      };
    }
    if (object.mapSetCollisions !== undefined && object.mapSetCollisions !== null) {
      message.action = {
        $case: "mapSetCollisions",
        mapSetCollisions: MapSetCollisions.fromJSON(object.mapSetCollisions),
      };
    }
    if (
      object.mapSetBackgroundImagePath !== undefined &&
      object.mapSetBackgroundImagePath !== null
    ) {
      message.action = {
        $case: "mapSetBackgroundImagePath",
        mapSetBackgroundImagePath: MapSetBackgroundImagePath.fromJSON(
          object.mapSetBackgroundImagePath,
        ),
      };
    }
    if (
      object.mapSetForegroundImagePath !== undefined &&
      object.mapSetForegroundImagePath !== null
    ) {
      message.action = {
        $case: "mapSetForegroundImagePath",
        mapSetForegroundImagePath: MapSetForegroundImagePath.fromJSON(
          object.mapSetForegroundImagePath,
        ),
      };
    }
    if (object.mapSetSprites !== undefined && object.mapSetSprites !== null) {
      message.action = {
        $case: "mapSetSprites",
        mapSetSprites: MapSetSprites.fromJSON(object.mapSetSprites),
      };
    }
    if (object.mapSetSpawns !== undefined && object.mapSetSpawns !== null) {
      message.action = {
        $case: "mapSetSpawns",
        mapSetSpawns: MapSetSpawns.fromJSON(object.mapSetSpawns),
      };
    }
    if (object.mapSetSpaces !== undefined && object.mapSetSpaces !== null) {
      message.action = {
        $case: "mapSetSpaces",
        mapSetSpaces: MapSetSpaces.fromJSON(object.mapSetSpaces),
      };
    }
    if (object.mapSetPortals !== undefined && object.mapSetPortals !== null) {
      message.action = {
        $case: "mapSetPortals",
        mapSetPortals: MapSetPortals.fromJSON(object.mapSetPortals),
      };
    }
    if (object.mapSetAnnouncer !== undefined && object.mapSetAnnouncer !== null) {
      message.action = {
        $case: "mapSetAnnouncer",
        mapSetAnnouncer: MapSetAnnouncer.fromJSON(object.mapSetAnnouncer),
      };
    }
    if (object.mapSetAudio !== undefined && object.mapSetAudio !== null) {
      message.action = {
        $case: "mapSetAudio",
        mapSetAudio: MapSetAudio.fromJSON(object.mapSetAudio),
      };
    }
    if (object.mapSetAnimations !== undefined && object.mapSetAnimations !== null) {
      message.action = {
        $case: "mapSetAnimations",
        mapSetAnimations: MapSetAnimations.fromJSON(object.mapSetAnimations),
      };
    }
    if (object.mapSetAssets !== undefined && object.mapSetAssets !== null) {
      message.action = {
        $case: "mapSetAssets",
        mapSetAssets: MapSetAssets.fromJSON(object.mapSetAssets),
      };
    }
    if (object.mapSetObjects !== undefined && object.mapSetObjects !== null) {
      message.action = {
        $case: "mapSetObjects",
        mapSetObjects: MapSetObjects.fromJSON(object.mapSetObjects),
      };
    }
    if (object.mapSetName !== undefined && object.mapSetName !== null) {
      message.action = { $case: "mapSetName", mapSetName: MapSetName.fromJSON(object.mapSetName) };
    }
    if (object.mapSetDefaultChat !== undefined && object.mapSetDefaultChat !== null) {
      message.action = {
        $case: "mapSetDefaultChat",
        mapSetDefaultChat: MapSetDefaultChat.fromJSON(object.mapSetDefaultChat),
      };
    }
    if (object.mapSetMuteOnEntry !== undefined && object.mapSetMuteOnEntry !== null) {
      message.action = {
        $case: "mapSetMuteOnEntry",
        mapSetMuteOnEntry: MapSetMuteOnEntry.fromJSON(object.mapSetMuteOnEntry),
      };
    }
    if (object.mapSetUseDrawnBG !== undefined && object.mapSetUseDrawnBG !== null) {
      message.action = {
        $case: "mapSetUseDrawnBG",
        mapSetUseDrawnBG: MapSetUseDrawnBG.fromJSON(object.mapSetUseDrawnBG),
      };
    }
    if (object.mapSetWalls !== undefined && object.mapSetWalls !== null) {
      message.action = {
        $case: "mapSetWalls",
        mapSetWalls: MapSetWalls.fromJSON(object.mapSetWalls),
      };
    }
    if (object.mapSetFloors !== undefined && object.mapSetFloors !== null) {
      message.action = {
        $case: "mapSetFloors",
        mapSetFloors: MapSetFloors.fromJSON(object.mapSetFloors),
      };
    }
    if (object.mapSetAreas !== undefined && object.mapSetAreas !== null) {
      message.action = {
        $case: "mapSetAreas",
        mapSetAreas: MapSetAreas.fromJSON(object.mapSetAreas),
      };
    }
    if (object.mapAddObject !== undefined && object.mapAddObject !== null) {
      message.action = {
        $case: "mapAddObject",
        mapAddObject: MapAddObject.fromJSON(object.mapAddObject),
      };
    }
    if (object.mapDeleteObject !== undefined && object.mapDeleteObject !== null) {
      message.action = {
        $case: "mapDeleteObject",
        mapDeleteObject: MapDeleteObject.fromJSON(object.mapDeleteObject),
      };
    }
    if (object.mapSetSpawn !== undefined && object.mapSetSpawn !== null) {
      message.action = {
        $case: "mapSetSpawn",
        mapSetSpawn: MapSetSpawn.fromJSON(object.mapSetSpawn),
      };
    }
    return message;
  },

  toJSON(message: ClientServerAction): unknown {
    const obj: any = {};
    message.action?.$case === "clientHeartbeat" &&
      (obj.clientHeartbeat = message.action?.clientHeartbeat
        ? ClientHeartbeat.toJSON(message.action?.clientHeartbeat)
        : undefined);
    message.action?.$case === "updateSubscriptions" &&
      (obj.updateSubscriptions = message.action?.updateSubscriptions
        ? UpdateSubscriptions.toJSON(message.action?.updateSubscriptions)
        : undefined);
    message.action?.$case === "move" &&
      (obj.move = message.action?.move ? Move.toJSON(message.action?.move) : undefined);
    message.action?.$case === "setSprite" &&
      (obj.setSprite = message.action?.setSprite
        ? SetSprite.toJSON(message.action?.setSprite)
        : undefined);
    message.action?.$case === "setAffiliation" &&
      (obj.setAffiliation = message.action?.setAffiliation
        ? SetAffiliation.toJSON(message.action?.setAffiliation)
        : undefined);
    message.action?.$case === "setStatus" &&
      (obj.setStatus = message.action?.setStatus
        ? SetStatus.toJSON(message.action?.setStatus)
        : undefined);
    message.action?.$case === "spotlight" &&
      (obj.spotlight = message.action?.spotlight
        ? Spotlight.toJSON(message.action?.spotlight)
        : undefined);
    message.action?.$case === "ring" &&
      (obj.ring = message.action?.ring ? Ring.toJSON(message.action?.ring) : undefined);
    message.action?.$case === "setPointer" &&
      (obj.setPointer = message.action?.setPointer
        ? SetPointer.toJSON(message.action?.setPointer)
        : undefined);
    message.action?.$case === "ban" &&
      (obj.ban = message.action?.ban ? Ban.toJSON(message.action?.ban) : undefined);
    message.action?.$case === "kick" &&
      (obj.kick = message.action?.kick ? Kick.toJSON(message.action?.kick) : undefined);
    message.action?.$case === "setImpassable" &&
      (obj.setImpassable = message.action?.setImpassable
        ? SetImpassable.toJSON(message.action?.setImpassable)
        : undefined);
    message.action?.$case === "chat" &&
      (obj.chat = message.action?.chat ? Chat.toJSON(message.action?.chat) : undefined);
    message.action?.$case === "setObject" &&
      (obj.setObject = message.action?.setObject
        ? SetObject.toJSON(message.action?.setObject)
        : undefined);
    message.action?.$case === "deleteObject" &&
      (obj.deleteObject = message.action?.deleteObject
        ? DeleteObject.toJSON(message.action?.deleteObject)
        : undefined);
    message.action?.$case === "interact" &&
      (obj.interact = message.action?.interact
        ? Interact.toJSON(message.action?.interact)
        : undefined);
    message.action?.$case === "enterWhisper" &&
      (obj.enterWhisper = message.action?.enterWhisper
        ? EnterWhisper.toJSON(message.action?.enterWhisper)
        : undefined);
    message.action?.$case === "leaveWhisper" &&
      (obj.leaveWhisper = message.action?.leaveWhisper
        ? LeaveWhisper.toJSON(message.action?.leaveWhisper)
        : undefined);
    message.action?.$case === "setEmojiStatus" &&
      (obj.setEmojiStatus = message.action?.setEmojiStatus
        ? SetEmojiStatus.toJSON(message.action?.setEmojiStatus)
        : undefined);
    message.action?.$case === "activelySpeaking" &&
      (obj.activelySpeaking = message.action?.activelySpeaking
        ? ActivelySpeaking.toJSON(message.action?.activelySpeaking)
        : undefined);
    message.action?.$case === "setEmote" &&
      (obj.setEmote = message.action?.setEmote
        ? SetEmote.toJSON(message.action?.setEmote)
        : undefined);
    message.action?.$case === "setName" &&
      (obj.setName = message.action?.setName ? SetName.toJSON(message.action?.setName) : undefined);
    message.action?.$case === "setTextStatus" &&
      (obj.setTextStatus = message.action?.setTextStatus
        ? SetTextStatus.toJSON(message.action?.setTextStatus)
        : undefined);
    message.action?.$case === "teleport" &&
      (obj.teleport = message.action?.teleport
        ? Teleport.toJSON(message.action?.teleport)
        : undefined);
    message.action?.$case === "exit" &&
      (obj.exit = message.action?.exit ? Exit.toJSON(message.action?.exit) : undefined);
    message.action?.$case === "enter" &&
      (obj.enter = message.action?.enter ? Enter.toJSON(message.action?.enter) : undefined);
    message.action?.$case === "setWorkCondition" &&
      (obj.setWorkCondition = message.action?.setWorkCondition
        ? SetWorkCondition.toJSON(message.action?.setWorkCondition)
        : undefined);
    message.action?.$case === "respawn" &&
      (obj.respawn = message.action?.respawn ? Respawn.toJSON(message.action?.respawn) : undefined);
    message.action?.$case === "spawn" &&
      (obj.spawn = message.action?.spawn ? Spawn.toJSON(message.action?.spawn) : undefined);
    message.action?.$case === "ghost" &&
      (obj.ghost = message.action?.ghost ? Ghost.toJSON(message.action?.ghost) : undefined);
    message.action?.$case === "init" &&
      (obj.init = message.action?.init ? Init.toJSON(message.action?.init) : undefined);
    message.action?.$case === "setOutfitString" &&
      (obj.setOutfitString = message.action?.setOutfitString
        ? SetOutfitString.toJSON(message.action?.setOutfitString)
        : undefined);
    message.action?.$case === "mapUpdate" &&
      (obj.mapUpdate = message.action?.mapUpdate
        ? MapUpdate.toJSON(message.action?.mapUpdate)
        : undefined);
    message.action?.$case === "shootConfetti" &&
      (obj.shootConfetti = message.action?.shootConfetti
        ? ShootConfetti.toJSON(message.action?.shootConfetti)
        : undefined);
    message.action?.$case === "setEventStatus" &&
      (obj.setEventStatus = message.action?.setEventStatus
        ? SetEventStatus.toJSON(message.action?.setEventStatus)
        : undefined);
    message.action?.$case === "setInConversation" &&
      (obj.setInConversation = message.action?.setInConversation
        ? SetInConversation.toJSON(message.action?.setInConversation)
        : undefined);
    message.action?.$case === "setCurrentDesk" &&
      (obj.setCurrentDesk = message.action?.setCurrentDesk
        ? SetCurrentDesk.toJSON(message.action?.setCurrentDesk)
        : undefined);
    message.action?.$case === "setCurrentArea" &&
      (obj.setCurrentArea = message.action?.setCurrentArea
        ? SetCurrentArea.toJSON(message.action?.setCurrentArea)
        : undefined);
    message.action?.$case === "setImagePointer" &&
      (obj.setImagePointer = message.action?.setImagePointer
        ? SetImagePointer.toJSON(message.action?.setImagePointer)
        : undefined);
    message.action?.$case === "setGoKartId" &&
      (obj.setGoKartId = message.action?.setGoKartId
        ? SetGoKartId.toJSON(message.action?.setGoKartId)
        : undefined);
    message.action?.$case === "mapSetDimensions" &&
      (obj.mapSetDimensions = message.action?.mapSetDimensions
        ? MapSetDimensions.toJSON(message.action?.mapSetDimensions)
        : undefined);
    message.action?.$case === "mapSetCollisions" &&
      (obj.mapSetCollisions = message.action?.mapSetCollisions
        ? MapSetCollisions.toJSON(message.action?.mapSetCollisions)
        : undefined);
    message.action?.$case === "mapSetBackgroundImagePath" &&
      (obj.mapSetBackgroundImagePath = message.action?.mapSetBackgroundImagePath
        ? MapSetBackgroundImagePath.toJSON(message.action?.mapSetBackgroundImagePath)
        : undefined);
    message.action?.$case === "mapSetForegroundImagePath" &&
      (obj.mapSetForegroundImagePath = message.action?.mapSetForegroundImagePath
        ? MapSetForegroundImagePath.toJSON(message.action?.mapSetForegroundImagePath)
        : undefined);
    message.action?.$case === "mapSetSprites" &&
      (obj.mapSetSprites = message.action?.mapSetSprites
        ? MapSetSprites.toJSON(message.action?.mapSetSprites)
        : undefined);
    message.action?.$case === "mapSetSpawns" &&
      (obj.mapSetSpawns = message.action?.mapSetSpawns
        ? MapSetSpawns.toJSON(message.action?.mapSetSpawns)
        : undefined);
    message.action?.$case === "mapSetSpaces" &&
      (obj.mapSetSpaces = message.action?.mapSetSpaces
        ? MapSetSpaces.toJSON(message.action?.mapSetSpaces)
        : undefined);
    message.action?.$case === "mapSetPortals" &&
      (obj.mapSetPortals = message.action?.mapSetPortals
        ? MapSetPortals.toJSON(message.action?.mapSetPortals)
        : undefined);
    message.action?.$case === "mapSetAnnouncer" &&
      (obj.mapSetAnnouncer = message.action?.mapSetAnnouncer
        ? MapSetAnnouncer.toJSON(message.action?.mapSetAnnouncer)
        : undefined);
    message.action?.$case === "mapSetAudio" &&
      (obj.mapSetAudio = message.action?.mapSetAudio
        ? MapSetAudio.toJSON(message.action?.mapSetAudio)
        : undefined);
    message.action?.$case === "mapSetAnimations" &&
      (obj.mapSetAnimations = message.action?.mapSetAnimations
        ? MapSetAnimations.toJSON(message.action?.mapSetAnimations)
        : undefined);
    message.action?.$case === "mapSetAssets" &&
      (obj.mapSetAssets = message.action?.mapSetAssets
        ? MapSetAssets.toJSON(message.action?.mapSetAssets)
        : undefined);
    message.action?.$case === "mapSetObjects" &&
      (obj.mapSetObjects = message.action?.mapSetObjects
        ? MapSetObjects.toJSON(message.action?.mapSetObjects)
        : undefined);
    message.action?.$case === "mapSetName" &&
      (obj.mapSetName = message.action?.mapSetName
        ? MapSetName.toJSON(message.action?.mapSetName)
        : undefined);
    message.action?.$case === "mapSetDefaultChat" &&
      (obj.mapSetDefaultChat = message.action?.mapSetDefaultChat
        ? MapSetDefaultChat.toJSON(message.action?.mapSetDefaultChat)
        : undefined);
    message.action?.$case === "mapSetMuteOnEntry" &&
      (obj.mapSetMuteOnEntry = message.action?.mapSetMuteOnEntry
        ? MapSetMuteOnEntry.toJSON(message.action?.mapSetMuteOnEntry)
        : undefined);
    message.action?.$case === "mapSetUseDrawnBG" &&
      (obj.mapSetUseDrawnBG = message.action?.mapSetUseDrawnBG
        ? MapSetUseDrawnBG.toJSON(message.action?.mapSetUseDrawnBG)
        : undefined);
    message.action?.$case === "mapSetWalls" &&
      (obj.mapSetWalls = message.action?.mapSetWalls
        ? MapSetWalls.toJSON(message.action?.mapSetWalls)
        : undefined);
    message.action?.$case === "mapSetFloors" &&
      (obj.mapSetFloors = message.action?.mapSetFloors
        ? MapSetFloors.toJSON(message.action?.mapSetFloors)
        : undefined);
    message.action?.$case === "mapSetAreas" &&
      (obj.mapSetAreas = message.action?.mapSetAreas
        ? MapSetAreas.toJSON(message.action?.mapSetAreas)
        : undefined);
    message.action?.$case === "mapAddObject" &&
      (obj.mapAddObject = message.action?.mapAddObject
        ? MapAddObject.toJSON(message.action?.mapAddObject)
        : undefined);
    message.action?.$case === "mapDeleteObject" &&
      (obj.mapDeleteObject = message.action?.mapDeleteObject
        ? MapDeleteObject.toJSON(message.action?.mapDeleteObject)
        : undefined);
    message.action?.$case === "mapSetSpawn" &&
      (obj.mapSetSpawn = message.action?.mapSetSpawn
        ? MapSetSpawn.toJSON(message.action?.mapSetSpawn)
        : undefined);
    return obj;
  },

  fromPartial(object: DeepPartial<ClientServerAction>): ClientServerAction {
    const message = { ...baseClientServerAction } as ClientServerAction;
    if (
      object.action?.$case === "clientHeartbeat" &&
      object.action?.clientHeartbeat !== undefined &&
      object.action?.clientHeartbeat !== null
    ) {
      message.action = {
        $case: "clientHeartbeat",
        clientHeartbeat: ClientHeartbeat.fromPartial(object.action.clientHeartbeat),
      };
    }
    if (
      object.action?.$case === "updateSubscriptions" &&
      object.action?.updateSubscriptions !== undefined &&
      object.action?.updateSubscriptions !== null
    ) {
      message.action = {
        $case: "updateSubscriptions",
        updateSubscriptions: UpdateSubscriptions.fromPartial(object.action.updateSubscriptions),
      };
    }
    if (
      object.action?.$case === "move" &&
      object.action?.move !== undefined &&
      object.action?.move !== null
    ) {
      message.action = { $case: "move", move: Move.fromPartial(object.action.move) };
    }
    if (
      object.action?.$case === "setSprite" &&
      object.action?.setSprite !== undefined &&
      object.action?.setSprite !== null
    ) {
      message.action = {
        $case: "setSprite",
        setSprite: SetSprite.fromPartial(object.action.setSprite),
      };
    }
    if (
      object.action?.$case === "setAffiliation" &&
      object.action?.setAffiliation !== undefined &&
      object.action?.setAffiliation !== null
    ) {
      message.action = {
        $case: "setAffiliation",
        setAffiliation: SetAffiliation.fromPartial(object.action.setAffiliation),
      };
    }
    if (
      object.action?.$case === "setStatus" &&
      object.action?.setStatus !== undefined &&
      object.action?.setStatus !== null
    ) {
      message.action = {
        $case: "setStatus",
        setStatus: SetStatus.fromPartial(object.action.setStatus),
      };
    }
    if (
      object.action?.$case === "spotlight" &&
      object.action?.spotlight !== undefined &&
      object.action?.spotlight !== null
    ) {
      message.action = {
        $case: "spotlight",
        spotlight: Spotlight.fromPartial(object.action.spotlight),
      };
    }
    if (
      object.action?.$case === "ring" &&
      object.action?.ring !== undefined &&
      object.action?.ring !== null
    ) {
      message.action = { $case: "ring", ring: Ring.fromPartial(object.action.ring) };
    }
    if (
      object.action?.$case === "setPointer" &&
      object.action?.setPointer !== undefined &&
      object.action?.setPointer !== null
    ) {
      message.action = {
        $case: "setPointer",
        setPointer: SetPointer.fromPartial(object.action.setPointer),
      };
    }
    if (
      object.action?.$case === "ban" &&
      object.action?.ban !== undefined &&
      object.action?.ban !== null
    ) {
      message.action = { $case: "ban", ban: Ban.fromPartial(object.action.ban) };
    }
    if (
      object.action?.$case === "kick" &&
      object.action?.kick !== undefined &&
      object.action?.kick !== null
    ) {
      message.action = { $case: "kick", kick: Kick.fromPartial(object.action.kick) };
    }
    if (
      object.action?.$case === "setImpassable" &&
      object.action?.setImpassable !== undefined &&
      object.action?.setImpassable !== null
    ) {
      message.action = {
        $case: "setImpassable",
        setImpassable: SetImpassable.fromPartial(object.action.setImpassable),
      };
    }
    if (
      object.action?.$case === "chat" &&
      object.action?.chat !== undefined &&
      object.action?.chat !== null
    ) {
      message.action = { $case: "chat", chat: Chat.fromPartial(object.action.chat) };
    }
    if (
      object.action?.$case === "setObject" &&
      object.action?.setObject !== undefined &&
      object.action?.setObject !== null
    ) {
      message.action = {
        $case: "setObject",
        setObject: SetObject.fromPartial(object.action.setObject),
      };
    }
    if (
      object.action?.$case === "deleteObject" &&
      object.action?.deleteObject !== undefined &&
      object.action?.deleteObject !== null
    ) {
      message.action = {
        $case: "deleteObject",
        deleteObject: DeleteObject.fromPartial(object.action.deleteObject),
      };
    }
    if (
      object.action?.$case === "interact" &&
      object.action?.interact !== undefined &&
      object.action?.interact !== null
    ) {
      message.action = {
        $case: "interact",
        interact: Interact.fromPartial(object.action.interact),
      };
    }
    if (
      object.action?.$case === "enterWhisper" &&
      object.action?.enterWhisper !== undefined &&
      object.action?.enterWhisper !== null
    ) {
      message.action = {
        $case: "enterWhisper",
        enterWhisper: EnterWhisper.fromPartial(object.action.enterWhisper),
      };
    }
    if (
      object.action?.$case === "leaveWhisper" &&
      object.action?.leaveWhisper !== undefined &&
      object.action?.leaveWhisper !== null
    ) {
      message.action = {
        $case: "leaveWhisper",
        leaveWhisper: LeaveWhisper.fromPartial(object.action.leaveWhisper),
      };
    }
    if (
      object.action?.$case === "setEmojiStatus" &&
      object.action?.setEmojiStatus !== undefined &&
      object.action?.setEmojiStatus !== null
    ) {
      message.action = {
        $case: "setEmojiStatus",
        setEmojiStatus: SetEmojiStatus.fromPartial(object.action.setEmojiStatus),
      };
    }
    if (
      object.action?.$case === "activelySpeaking" &&
      object.action?.activelySpeaking !== undefined &&
      object.action?.activelySpeaking !== null
    ) {
      message.action = {
        $case: "activelySpeaking",
        activelySpeaking: ActivelySpeaking.fromPartial(object.action.activelySpeaking),
      };
    }
    if (
      object.action?.$case === "setEmote" &&
      object.action?.setEmote !== undefined &&
      object.action?.setEmote !== null
    ) {
      message.action = {
        $case: "setEmote",
        setEmote: SetEmote.fromPartial(object.action.setEmote),
      };
    }
    if (
      object.action?.$case === "setName" &&
      object.action?.setName !== undefined &&
      object.action?.setName !== null
    ) {
      message.action = { $case: "setName", setName: SetName.fromPartial(object.action.setName) };
    }
    if (
      object.action?.$case === "setTextStatus" &&
      object.action?.setTextStatus !== undefined &&
      object.action?.setTextStatus !== null
    ) {
      message.action = {
        $case: "setTextStatus",
        setTextStatus: SetTextStatus.fromPartial(object.action.setTextStatus),
      };
    }
    if (
      object.action?.$case === "teleport" &&
      object.action?.teleport !== undefined &&
      object.action?.teleport !== null
    ) {
      message.action = {
        $case: "teleport",
        teleport: Teleport.fromPartial(object.action.teleport),
      };
    }
    if (
      object.action?.$case === "exit" &&
      object.action?.exit !== undefined &&
      object.action?.exit !== null
    ) {
      message.action = { $case: "exit", exit: Exit.fromPartial(object.action.exit) };
    }
    if (
      object.action?.$case === "enter" &&
      object.action?.enter !== undefined &&
      object.action?.enter !== null
    ) {
      message.action = { $case: "enter", enter: Enter.fromPartial(object.action.enter) };
    }
    if (
      object.action?.$case === "setWorkCondition" &&
      object.action?.setWorkCondition !== undefined &&
      object.action?.setWorkCondition !== null
    ) {
      message.action = {
        $case: "setWorkCondition",
        setWorkCondition: SetWorkCondition.fromPartial(object.action.setWorkCondition),
      };
    }
    if (
      object.action?.$case === "respawn" &&
      object.action?.respawn !== undefined &&
      object.action?.respawn !== null
    ) {
      message.action = { $case: "respawn", respawn: Respawn.fromPartial(object.action.respawn) };
    }
    if (
      object.action?.$case === "spawn" &&
      object.action?.spawn !== undefined &&
      object.action?.spawn !== null
    ) {
      message.action = { $case: "spawn", spawn: Spawn.fromPartial(object.action.spawn) };
    }
    if (
      object.action?.$case === "ghost" &&
      object.action?.ghost !== undefined &&
      object.action?.ghost !== null
    ) {
      message.action = { $case: "ghost", ghost: Ghost.fromPartial(object.action.ghost) };
    }
    if (
      object.action?.$case === "init" &&
      object.action?.init !== undefined &&
      object.action?.init !== null
    ) {
      message.action = { $case: "init", init: Init.fromPartial(object.action.init) };
    }
    if (
      object.action?.$case === "setOutfitString" &&
      object.action?.setOutfitString !== undefined &&
      object.action?.setOutfitString !== null
    ) {
      message.action = {
        $case: "setOutfitString",
        setOutfitString: SetOutfitString.fromPartial(object.action.setOutfitString),
      };
    }
    if (
      object.action?.$case === "mapUpdate" &&
      object.action?.mapUpdate !== undefined &&
      object.action?.mapUpdate !== null
    ) {
      message.action = {
        $case: "mapUpdate",
        mapUpdate: MapUpdate.fromPartial(object.action.mapUpdate),
      };
    }
    if (
      object.action?.$case === "shootConfetti" &&
      object.action?.shootConfetti !== undefined &&
      object.action?.shootConfetti !== null
    ) {
      message.action = {
        $case: "shootConfetti",
        shootConfetti: ShootConfetti.fromPartial(object.action.shootConfetti),
      };
    }
    if (
      object.action?.$case === "setEventStatus" &&
      object.action?.setEventStatus !== undefined &&
      object.action?.setEventStatus !== null
    ) {
      message.action = {
        $case: "setEventStatus",
        setEventStatus: SetEventStatus.fromPartial(object.action.setEventStatus),
      };
    }
    if (
      object.action?.$case === "setInConversation" &&
      object.action?.setInConversation !== undefined &&
      object.action?.setInConversation !== null
    ) {
      message.action = {
        $case: "setInConversation",
        setInConversation: SetInConversation.fromPartial(object.action.setInConversation),
      };
    }
    if (
      object.action?.$case === "setCurrentDesk" &&
      object.action?.setCurrentDesk !== undefined &&
      object.action?.setCurrentDesk !== null
    ) {
      message.action = {
        $case: "setCurrentDesk",
        setCurrentDesk: SetCurrentDesk.fromPartial(object.action.setCurrentDesk),
      };
    }
    if (
      object.action?.$case === "setCurrentArea" &&
      object.action?.setCurrentArea !== undefined &&
      object.action?.setCurrentArea !== null
    ) {
      message.action = {
        $case: "setCurrentArea",
        setCurrentArea: SetCurrentArea.fromPartial(object.action.setCurrentArea),
      };
    }
    if (
      object.action?.$case === "setImagePointer" &&
      object.action?.setImagePointer !== undefined &&
      object.action?.setImagePointer !== null
    ) {
      message.action = {
        $case: "setImagePointer",
        setImagePointer: SetImagePointer.fromPartial(object.action.setImagePointer),
      };
    }
    if (
      object.action?.$case === "setGoKartId" &&
      object.action?.setGoKartId !== undefined &&
      object.action?.setGoKartId !== null
    ) {
      message.action = {
        $case: "setGoKartId",
        setGoKartId: SetGoKartId.fromPartial(object.action.setGoKartId),
      };
    }
    if (
      object.action?.$case === "mapSetDimensions" &&
      object.action?.mapSetDimensions !== undefined &&
      object.action?.mapSetDimensions !== null
    ) {
      message.action = {
        $case: "mapSetDimensions",
        mapSetDimensions: MapSetDimensions.fromPartial(object.action.mapSetDimensions),
      };
    }
    if (
      object.action?.$case === "mapSetCollisions" &&
      object.action?.mapSetCollisions !== undefined &&
      object.action?.mapSetCollisions !== null
    ) {
      message.action = {
        $case: "mapSetCollisions",
        mapSetCollisions: MapSetCollisions.fromPartial(object.action.mapSetCollisions),
      };
    }
    if (
      object.action?.$case === "mapSetBackgroundImagePath" &&
      object.action?.mapSetBackgroundImagePath !== undefined &&
      object.action?.mapSetBackgroundImagePath !== null
    ) {
      message.action = {
        $case: "mapSetBackgroundImagePath",
        mapSetBackgroundImagePath: MapSetBackgroundImagePath.fromPartial(
          object.action.mapSetBackgroundImagePath,
        ),
      };
    }
    if (
      object.action?.$case === "mapSetForegroundImagePath" &&
      object.action?.mapSetForegroundImagePath !== undefined &&
      object.action?.mapSetForegroundImagePath !== null
    ) {
      message.action = {
        $case: "mapSetForegroundImagePath",
        mapSetForegroundImagePath: MapSetForegroundImagePath.fromPartial(
          object.action.mapSetForegroundImagePath,
        ),
      };
    }
    if (
      object.action?.$case === "mapSetSprites" &&
      object.action?.mapSetSprites !== undefined &&
      object.action?.mapSetSprites !== null
    ) {
      message.action = {
        $case: "mapSetSprites",
        mapSetSprites: MapSetSprites.fromPartial(object.action.mapSetSprites),
      };
    }
    if (
      object.action?.$case === "mapSetSpawns" &&
      object.action?.mapSetSpawns !== undefined &&
      object.action?.mapSetSpawns !== null
    ) {
      message.action = {
        $case: "mapSetSpawns",
        mapSetSpawns: MapSetSpawns.fromPartial(object.action.mapSetSpawns),
      };
    }
    if (
      object.action?.$case === "mapSetSpaces" &&
      object.action?.mapSetSpaces !== undefined &&
      object.action?.mapSetSpaces !== null
    ) {
      message.action = {
        $case: "mapSetSpaces",
        mapSetSpaces: MapSetSpaces.fromPartial(object.action.mapSetSpaces),
      };
    }
    if (
      object.action?.$case === "mapSetPortals" &&
      object.action?.mapSetPortals !== undefined &&
      object.action?.mapSetPortals !== null
    ) {
      message.action = {
        $case: "mapSetPortals",
        mapSetPortals: MapSetPortals.fromPartial(object.action.mapSetPortals),
      };
    }
    if (
      object.action?.$case === "mapSetAnnouncer" &&
      object.action?.mapSetAnnouncer !== undefined &&
      object.action?.mapSetAnnouncer !== null
    ) {
      message.action = {
        $case: "mapSetAnnouncer",
        mapSetAnnouncer: MapSetAnnouncer.fromPartial(object.action.mapSetAnnouncer),
      };
    }
    if (
      object.action?.$case === "mapSetAudio" &&
      object.action?.mapSetAudio !== undefined &&
      object.action?.mapSetAudio !== null
    ) {
      message.action = {
        $case: "mapSetAudio",
        mapSetAudio: MapSetAudio.fromPartial(object.action.mapSetAudio),
      };
    }
    if (
      object.action?.$case === "mapSetAnimations" &&
      object.action?.mapSetAnimations !== undefined &&
      object.action?.mapSetAnimations !== null
    ) {
      message.action = {
        $case: "mapSetAnimations",
        mapSetAnimations: MapSetAnimations.fromPartial(object.action.mapSetAnimations),
      };
    }
    if (
      object.action?.$case === "mapSetAssets" &&
      object.action?.mapSetAssets !== undefined &&
      object.action?.mapSetAssets !== null
    ) {
      message.action = {
        $case: "mapSetAssets",
        mapSetAssets: MapSetAssets.fromPartial(object.action.mapSetAssets),
      };
    }
    if (
      object.action?.$case === "mapSetObjects" &&
      object.action?.mapSetObjects !== undefined &&
      object.action?.mapSetObjects !== null
    ) {
      message.action = {
        $case: "mapSetObjects",
        mapSetObjects: MapSetObjects.fromPartial(object.action.mapSetObjects),
      };
    }
    if (
      object.action?.$case === "mapSetName" &&
      object.action?.mapSetName !== undefined &&
      object.action?.mapSetName !== null
    ) {
      message.action = {
        $case: "mapSetName",
        mapSetName: MapSetName.fromPartial(object.action.mapSetName),
      };
    }
    if (
      object.action?.$case === "mapSetDefaultChat" &&
      object.action?.mapSetDefaultChat !== undefined &&
      object.action?.mapSetDefaultChat !== null
    ) {
      message.action = {
        $case: "mapSetDefaultChat",
        mapSetDefaultChat: MapSetDefaultChat.fromPartial(object.action.mapSetDefaultChat),
      };
    }
    if (
      object.action?.$case === "mapSetMuteOnEntry" &&
      object.action?.mapSetMuteOnEntry !== undefined &&
      object.action?.mapSetMuteOnEntry !== null
    ) {
      message.action = {
        $case: "mapSetMuteOnEntry",
        mapSetMuteOnEntry: MapSetMuteOnEntry.fromPartial(object.action.mapSetMuteOnEntry),
      };
    }
    if (
      object.action?.$case === "mapSetUseDrawnBG" &&
      object.action?.mapSetUseDrawnBG !== undefined &&
      object.action?.mapSetUseDrawnBG !== null
    ) {
      message.action = {
        $case: "mapSetUseDrawnBG",
        mapSetUseDrawnBG: MapSetUseDrawnBG.fromPartial(object.action.mapSetUseDrawnBG),
      };
    }
    if (
      object.action?.$case === "mapSetWalls" &&
      object.action?.mapSetWalls !== undefined &&
      object.action?.mapSetWalls !== null
    ) {
      message.action = {
        $case: "mapSetWalls",
        mapSetWalls: MapSetWalls.fromPartial(object.action.mapSetWalls),
      };
    }
    if (
      object.action?.$case === "mapSetFloors" &&
      object.action?.mapSetFloors !== undefined &&
      object.action?.mapSetFloors !== null
    ) {
      message.action = {
        $case: "mapSetFloors",
        mapSetFloors: MapSetFloors.fromPartial(object.action.mapSetFloors),
      };
    }
    if (
      object.action?.$case === "mapSetAreas" &&
      object.action?.mapSetAreas !== undefined &&
      object.action?.mapSetAreas !== null
    ) {
      message.action = {
        $case: "mapSetAreas",
        mapSetAreas: MapSetAreas.fromPartial(object.action.mapSetAreas),
      };
    }
    if (
      object.action?.$case === "mapAddObject" &&
      object.action?.mapAddObject !== undefined &&
      object.action?.mapAddObject !== null
    ) {
      message.action = {
        $case: "mapAddObject",
        mapAddObject: MapAddObject.fromPartial(object.action.mapAddObject),
      };
    }
    if (
      object.action?.$case === "mapDeleteObject" &&
      object.action?.mapDeleteObject !== undefined &&
      object.action?.mapDeleteObject !== null
    ) {
      message.action = {
        $case: "mapDeleteObject",
        mapDeleteObject: MapDeleteObject.fromPartial(object.action.mapDeleteObject),
      };
    }
    if (
      object.action?.$case === "mapSetSpawn" &&
      object.action?.mapSetSpawn !== undefined &&
      object.action?.mapSetSpawn !== null
    ) {
      message.action = {
        $case: "mapSetSpawn",
        mapSetSpawn: MapSetSpawn.fromPartial(object.action.mapSetSpawn),
      };
    }
    return message;
  },
};

const baseClientHeartbeat: object = {};

export const ClientHeartbeat = {
  encode(_: ClientHeartbeat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClientHeartbeat {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseClientHeartbeat } as ClientHeartbeat;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): ClientHeartbeat {
    const message = { ...baseClientHeartbeat } as ClientHeartbeat;
    return message;
  },

  toJSON(_: ClientHeartbeat): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial(_: DeepPartial<ClientHeartbeat>): ClientHeartbeat {
    const message = { ...baseClientHeartbeat } as ClientHeartbeat;
    return message;
  },
};

const baseUpdateSubscriptions: object = {};

export const UpdateSubscriptions = {
  encode(message: UpdateSubscriptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.subscriptions).forEach(([key, value]) => {
      UpdateSubscriptions_SubscriptionsEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSubscriptions {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseUpdateSubscriptions } as UpdateSubscriptions;
    message.subscriptions = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = UpdateSubscriptions_SubscriptionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.subscriptions[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateSubscriptions {
    const message = { ...baseUpdateSubscriptions } as UpdateSubscriptions;
    message.subscriptions = {};
    if (object.subscriptions !== undefined && object.subscriptions !== null) {
      Object.entries(object.subscriptions).forEach(([key, value]) => {
        message.subscriptions[key] = Boolean(value);
      });
    }
    return message;
  },

  toJSON(message: UpdateSubscriptions): unknown {
    const obj: any = {};
    obj.subscriptions = {};
    if (message.subscriptions) {
      Object.entries(message.subscriptions).forEach(([k, v]) => {
        obj.subscriptions[k] = v;
      });
    }
    return obj;
  },

  fromPartial(object: DeepPartial<UpdateSubscriptions>): UpdateSubscriptions {
    const message = { ...baseUpdateSubscriptions } as UpdateSubscriptions;
    message.subscriptions = {};
    if (object.subscriptions !== undefined && object.subscriptions !== null) {
      Object.entries(object.subscriptions).forEach(([key, value]) => {
        if (value !== undefined) {
          message.subscriptions[key] = Boolean(value);
        }
      });
    }
    return message;
  },
};

const baseUpdateSubscriptions_SubscriptionsEntry: object = { key: "", value: false };

export const UpdateSubscriptions_SubscriptionsEntry = {
  encode(
    message: UpdateSubscriptions_SubscriptionsEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value === true) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSubscriptions_SubscriptionsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = {
      ...baseUpdateSubscriptions_SubscriptionsEntry,
    } as UpdateSubscriptions_SubscriptionsEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateSubscriptions_SubscriptionsEntry {
    const message = {
      ...baseUpdateSubscriptions_SubscriptionsEntry,
    } as UpdateSubscriptions_SubscriptionsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = Boolean(object.value);
    }
    return message;
  },

  toJSON(message: UpdateSubscriptions_SubscriptionsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial(
    object: DeepPartial<UpdateSubscriptions_SubscriptionsEntry>,
  ): UpdateSubscriptions_SubscriptionsEntry {
    const message = {
      ...baseUpdateSubscriptions_SubscriptionsEntry,
    } as UpdateSubscriptions_SubscriptionsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    return message;
  },
};

const baseMove: object = { dir: 0, stopped: false, inputId: 0 };

export const Move = {
  encode(message: Move, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dir !== 0) {
      writer.uint32(8).int32(message.dir);
    }
    if (message.stopped === true) {
      writer.uint32(16).bool(message.stopped);
    }
    if (message.inputId !== 0) {
      writer.uint32(24).uint32(message.inputId);
    }
    if (message.targetId !== undefined) {
      writer.uint32(34).string(message.targetId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Move {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMove } as Move;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.dir = reader.int32() as any;
          break;
        case 2:
          message.stopped = reader.bool();
          break;
        case 3:
          message.inputId = reader.uint32();
          break;
        case 4:
          message.targetId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Move {
    const message = { ...baseMove } as Move;
    if (object.dir !== undefined && object.dir !== null) {
      message.dir = moveDirectionEnum_ENUMFromJSON(object.dir);
    }
    if (object.stopped !== undefined && object.stopped !== null) {
      message.stopped = Boolean(object.stopped);
    }
    if (object.inputId !== undefined && object.inputId !== null) {
      message.inputId = Number(object.inputId);
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = String(object.targetId);
    }
    return message;
  },

  toJSON(message: Move): unknown {
    const obj: any = {};
    message.dir !== undefined && (obj.dir = moveDirectionEnum_ENUMToJSON(message.dir));
    message.stopped !== undefined && (obj.stopped = message.stopped);
    message.inputId !== undefined && (obj.inputId = message.inputId);
    message.targetId !== undefined && (obj.targetId = message.targetId);
    return obj;
  },

  fromPartial(object: DeepPartial<Move>): Move {
    const message = { ...baseMove } as Move;
    if (object.dir !== undefined && object.dir !== null) {
      message.dir = object.dir;
    }
    if (object.stopped !== undefined && object.stopped !== null) {
      message.stopped = object.stopped;
    }
    if (object.inputId !== undefined && object.inputId !== null) {
      message.inputId = object.inputId;
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = object.targetId;
    }
    return message;
  },
};

const baseSetSprite: object = { sprite: 0 };

export const SetSprite = {
  encode(message: SetSprite, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sprite !== 0) {
      writer.uint32(8).uint32(message.sprite);
    }
    if (message.targetId !== undefined) {
      writer.uint32(18).string(message.targetId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetSprite {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetSprite } as SetSprite;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sprite = reader.uint32();
          break;
        case 2:
          message.targetId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetSprite {
    const message = { ...baseSetSprite } as SetSprite;
    if (object.sprite !== undefined && object.sprite !== null) {
      message.sprite = Number(object.sprite);
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = String(object.targetId);
    }
    return message;
  },

  toJSON(message: SetSprite): unknown {
    const obj: any = {};
    message.sprite !== undefined && (obj.sprite = message.sprite);
    message.targetId !== undefined && (obj.targetId = message.targetId);
    return obj;
  },

  fromPartial(object: DeepPartial<SetSprite>): SetSprite {
    const message = { ...baseSetSprite } as SetSprite;
    if (object.sprite !== undefined && object.sprite !== null) {
      message.sprite = object.sprite;
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = object.targetId;
    }
    return message;
  },
};

const baseSetAffiliation: object = { affiliation: "" };

export const SetAffiliation = {
  encode(message: SetAffiliation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.affiliation !== "") {
      writer.uint32(10).string(message.affiliation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetAffiliation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetAffiliation } as SetAffiliation;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.affiliation = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetAffiliation {
    const message = { ...baseSetAffiliation } as SetAffiliation;
    if (object.affiliation !== undefined && object.affiliation !== null) {
      message.affiliation = String(object.affiliation);
    }
    return message;
  },

  toJSON(message: SetAffiliation): unknown {
    const obj: any = {};
    message.affiliation !== undefined && (obj.affiliation = message.affiliation);
    return obj;
  },

  fromPartial(object: DeepPartial<SetAffiliation>): SetAffiliation {
    const message = { ...baseSetAffiliation } as SetAffiliation;
    if (object.affiliation !== undefined && object.affiliation !== null) {
      message.affiliation = object.affiliation;
    }
    return message;
  },
};

const baseSetStatus: object = { status: false };

export const SetStatus = {
  encode(message: SetStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status === true) {
      writer.uint32(8).bool(message.status);
    }
    if (message.targetId !== undefined) {
      writer.uint32(18).string(message.targetId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetStatus } as SetStatus;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.status = reader.bool();
          break;
        case 2:
          message.targetId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetStatus {
    const message = { ...baseSetStatus } as SetStatus;
    if (object.status !== undefined && object.status !== null) {
      message.status = Boolean(object.status);
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = String(object.targetId);
    }
    return message;
  },

  toJSON(message: SetStatus): unknown {
    const obj: any = {};
    message.status !== undefined && (obj.status = message.status);
    message.targetId !== undefined && (obj.targetId = message.targetId);
    return obj;
  },

  fromPartial(object: DeepPartial<SetStatus>): SetStatus {
    const message = { ...baseSetStatus } as SetStatus;
    if (object.status !== undefined && object.status !== null) {
      message.status = object.status;
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = object.targetId;
    }
    return message;
  },
};

const baseSetOutfitString: object = { outfitString: "" };

export const SetOutfitString = {
  encode(message: SetOutfitString, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.outfitString !== "") {
      writer.uint32(10).string(message.outfitString);
    }
    if (message.targetId !== undefined) {
      writer.uint32(26).string(message.targetId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetOutfitString {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetOutfitString } as SetOutfitString;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.outfitString = reader.string();
          break;
        case 3:
          message.targetId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetOutfitString {
    const message = { ...baseSetOutfitString } as SetOutfitString;
    if (object.outfitString !== undefined && object.outfitString !== null) {
      message.outfitString = String(object.outfitString);
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = String(object.targetId);
    }
    return message;
  },

  toJSON(message: SetOutfitString): unknown {
    const obj: any = {};
    message.outfitString !== undefined && (obj.outfitString = message.outfitString);
    message.targetId !== undefined && (obj.targetId = message.targetId);
    return obj;
  },

  fromPartial(object: DeepPartial<SetOutfitString>): SetOutfitString {
    const message = { ...baseSetOutfitString } as SetOutfitString;
    if (object.outfitString !== undefined && object.outfitString !== null) {
      message.outfitString = object.outfitString;
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = object.targetId;
    }
    return message;
  },
};

const baseSpotlight: object = { spotlightedUser: "", isSpotlighted: false };

export const Spotlight = {
  encode(message: Spotlight, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spotlightedUser !== "") {
      writer.uint32(10).string(message.spotlightedUser);
    }
    if (message.isSpotlighted === true) {
      writer.uint32(16).bool(message.isSpotlighted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Spotlight {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSpotlight } as Spotlight;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.spotlightedUser = reader.string();
          break;
        case 2:
          message.isSpotlighted = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Spotlight {
    const message = { ...baseSpotlight } as Spotlight;
    if (object.spotlightedUser !== undefined && object.spotlightedUser !== null) {
      message.spotlightedUser = String(object.spotlightedUser);
    }
    if (object.isSpotlighted !== undefined && object.isSpotlighted !== null) {
      message.isSpotlighted = Boolean(object.isSpotlighted);
    }
    return message;
  },

  toJSON(message: Spotlight): unknown {
    const obj: any = {};
    message.spotlightedUser !== undefined && (obj.spotlightedUser = message.spotlightedUser);
    message.isSpotlighted !== undefined && (obj.isSpotlighted = message.isSpotlighted);
    return obj;
  },

  fromPartial(object: DeepPartial<Spotlight>): Spotlight {
    const message = { ...baseSpotlight } as Spotlight;
    if (object.spotlightedUser !== undefined && object.spotlightedUser !== null) {
      message.spotlightedUser = object.spotlightedUser;
    }
    if (object.isSpotlighted !== undefined && object.isSpotlighted !== null) {
      message.isSpotlighted = object.isSpotlighted;
    }
    return message;
  },
};

const baseRing: object = { user: "" };

export const Ring = {
  encode(message: Ring, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Ring {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseRing } as Ring;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Ring {
    const message = { ...baseRing } as Ring;
    if (object.user !== undefined && object.user !== null) {
      message.user = String(object.user);
    }
    return message;
  },

  toJSON(message: Ring): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user);
    return obj;
  },

  fromPartial(object: DeepPartial<Ring>): Ring {
    const message = { ...baseRing } as Ring;
    if (object.user !== undefined && object.user !== null) {
      message.user = object.user;
    }
    return message;
  },
};

const baseSetPointer: object = { objectId: "", x: 0, y: 0 };

export const SetPointer = {
  encode(message: SetPointer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.objectId !== "") {
      writer.uint32(10).string(message.objectId);
    }
    if (message.x !== 0) {
      writer.uint32(16).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(24).uint32(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetPointer {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetPointer } as SetPointer;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.objectId = reader.string();
          break;
        case 2:
          message.x = reader.uint32();
          break;
        case 3:
          message.y = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetPointer {
    const message = { ...baseSetPointer } as SetPointer;
    if (object.objectId !== undefined && object.objectId !== null) {
      message.objectId = String(object.objectId);
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    return message;
  },

  toJSON(message: SetPointer): unknown {
    const obj: any = {};
    message.objectId !== undefined && (obj.objectId = message.objectId);
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    return obj;
  },

  fromPartial(object: DeepPartial<SetPointer>): SetPointer {
    const message = { ...baseSetPointer } as SetPointer;
    if (object.objectId !== undefined && object.objectId !== null) {
      message.objectId = object.objectId;
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    return message;
  },
};

const baseSetImagePointer: object = { objectId: "", x: 0, y: 0 };

export const SetImagePointer = {
  encode(message: SetImagePointer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.objectId !== "") {
      writer.uint32(10).string(message.objectId);
    }
    if (message.x !== 0) {
      writer.uint32(17).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(25).double(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetImagePointer {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetImagePointer } as SetImagePointer;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.objectId = reader.string();
          break;
        case 2:
          message.x = reader.double();
          break;
        case 3:
          message.y = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetImagePointer {
    const message = { ...baseSetImagePointer } as SetImagePointer;
    if (object.objectId !== undefined && object.objectId !== null) {
      message.objectId = String(object.objectId);
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    return message;
  },

  toJSON(message: SetImagePointer): unknown {
    const obj: any = {};
    message.objectId !== undefined && (obj.objectId = message.objectId);
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    return obj;
  },

  fromPartial(object: DeepPartial<SetImagePointer>): SetImagePointer {
    const message = { ...baseSetImagePointer } as SetImagePointer;
    if (object.objectId !== undefined && object.objectId !== null) {
      message.objectId = object.objectId;
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    return message;
  },
};

const baseBan: object = { user: "" };

export const Ban = {
  encode(message: Ban, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Ban {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseBan } as Ban;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Ban {
    const message = { ...baseBan } as Ban;
    if (object.user !== undefined && object.user !== null) {
      message.user = String(object.user);
    }
    return message;
  },

  toJSON(message: Ban): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user);
    return obj;
  },

  fromPartial(object: DeepPartial<Ban>): Ban {
    const message = { ...baseBan } as Ban;
    if (object.user !== undefined && object.user !== null) {
      message.user = object.user;
    }
    return message;
  },
};

const baseKick: object = { user: "" };

export const Kick = {
  encode(message: Kick, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Kick {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseKick } as Kick;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Kick {
    const message = { ...baseKick } as Kick;
    if (object.user !== undefined && object.user !== null) {
      message.user = String(object.user);
    }
    return message;
  },

  toJSON(message: Kick): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user);
    return obj;
  },

  fromPartial(object: DeepPartial<Kick>): Kick {
    const message = { ...baseKick } as Kick;
    if (object.user !== undefined && object.user !== null) {
      message.user = object.user;
    }
    return message;
  },
};

const baseSetImpassable: object = { mapId: "", x: 0, y: 0, impassable: false };

export const SetImpassable = {
  encode(message: SetImpassable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.x !== 0) {
      writer.uint32(16).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(24).uint32(message.y);
    }
    if (message.impassable === true) {
      writer.uint32(32).bool(message.impassable);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetImpassable {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetImpassable } as SetImpassable;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.x = reader.uint32();
          break;
        case 3:
          message.y = reader.uint32();
          break;
        case 4:
          message.impassable = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetImpassable {
    const message = { ...baseSetImpassable } as SetImpassable;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    if (object.impassable !== undefined && object.impassable !== null) {
      message.impassable = Boolean(object.impassable);
    }
    return message;
  },

  toJSON(message: SetImpassable): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.impassable !== undefined && (obj.impassable = message.impassable);
    return obj;
  },

  fromPartial(object: DeepPartial<SetImpassable>): SetImpassable {
    const message = { ...baseSetImpassable } as SetImpassable;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    if (object.impassable !== undefined && object.impassable !== null) {
      message.impassable = object.impassable;
    }
    return message;
  },
};

const baseChat: object = { chatRecipient: "", contents: "", localPlayerIds: "", mapId: "" };

export const Chat = {
  encode(message: Chat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chatRecipient !== "") {
      writer.uint32(10).string(message.chatRecipient);
    }
    if (message.contents !== "") {
      writer.uint32(18).string(message.contents);
    }
    for (const v of message.localPlayerIds) {
      writer.uint32(26).string(v!);
    }
    if (message.mapId !== "") {
      writer.uint32(34).string(message.mapId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Chat {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseChat } as Chat;
    message.localPlayerIds = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.chatRecipient = reader.string();
          break;
        case 2:
          message.contents = reader.string();
          break;
        case 3:
          message.localPlayerIds.push(reader.string());
          break;
        case 4:
          message.mapId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Chat {
    const message = { ...baseChat } as Chat;
    message.localPlayerIds = [];
    if (object.chatRecipient !== undefined && object.chatRecipient !== null) {
      message.chatRecipient = String(object.chatRecipient);
    }
    if (object.contents !== undefined && object.contents !== null) {
      message.contents = String(object.contents);
    }
    if (object.localPlayerIds !== undefined && object.localPlayerIds !== null) {
      for (const e of object.localPlayerIds) {
        message.localPlayerIds.push(String(e));
      }
    }
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    return message;
  },

  toJSON(message: Chat): unknown {
    const obj: any = {};
    message.chatRecipient !== undefined && (obj.chatRecipient = message.chatRecipient);
    message.contents !== undefined && (obj.contents = message.contents);
    if (message.localPlayerIds) {
      obj.localPlayerIds = message.localPlayerIds.map((e) => e);
    } else {
      obj.localPlayerIds = [];
    }
    message.mapId !== undefined && (obj.mapId = message.mapId);
    return obj;
  },

  fromPartial(object: DeepPartial<Chat>): Chat {
    const message = { ...baseChat } as Chat;
    message.localPlayerIds = [];
    if (object.chatRecipient !== undefined && object.chatRecipient !== null) {
      message.chatRecipient = object.chatRecipient;
    }
    if (object.contents !== undefined && object.contents !== null) {
      message.contents = object.contents;
    }
    if (object.localPlayerIds !== undefined && object.localPlayerIds !== null) {
      for (const e of object.localPlayerIds) {
        message.localPlayerIds.push(e);
      }
    }
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    return message;
  },
};

const baseSetObject: object = { mapId: "", objectId: "" };

export const SetObject = {
  encode(message: SetObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.objectId !== "") {
      writer.uint32(18).string(message.objectId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetObject } as SetObject;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.objectId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetObject {
    const message = { ...baseSetObject } as SetObject;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.objectId !== undefined && object.objectId !== null) {
      message.objectId = String(object.objectId);
    }
    return message;
  },

  toJSON(message: SetObject): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.objectId !== undefined && (obj.objectId = message.objectId);
    return obj;
  },

  fromPartial(object: DeepPartial<SetObject>): SetObject {
    const message = { ...baseSetObject } as SetObject;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.objectId !== undefined && object.objectId !== null) {
      message.objectId = object.objectId;
    }
    return message;
  },
};

const baseDeleteObject: object = { mapId: "", objectId: "" };

export const DeleteObject = {
  encode(message: DeleteObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.objectId !== "") {
      writer.uint32(18).string(message.objectId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseDeleteObject } as DeleteObject;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.objectId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteObject {
    const message = { ...baseDeleteObject } as DeleteObject;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.objectId !== undefined && object.objectId !== null) {
      message.objectId = String(object.objectId);
    }
    return message;
  },

  toJSON(message: DeleteObject): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.objectId !== undefined && (obj.objectId = message.objectId);
    return obj;
  },

  fromPartial(object: DeepPartial<DeleteObject>): DeleteObject {
    const message = { ...baseDeleteObject } as DeleteObject;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.objectId !== undefined && object.objectId !== null) {
      message.objectId = object.objectId;
    }
    return message;
  },
};

const baseInteract: object = { objId: "" };

export const Interact = {
  encode(message: Interact, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.objId !== "") {
      writer.uint32(10).string(message.objId);
    }
    if (message.dataJson !== undefined) {
      writer.uint32(18).string(message.dataJson);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Interact {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseInteract } as Interact;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.objId = reader.string();
          break;
        case 2:
          message.dataJson = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Interact {
    const message = { ...baseInteract } as Interact;
    if (object.objId !== undefined && object.objId !== null) {
      message.objId = String(object.objId);
    }
    if (object.dataJson !== undefined && object.dataJson !== null) {
      message.dataJson = String(object.dataJson);
    }
    return message;
  },

  toJSON(message: Interact): unknown {
    const obj: any = {};
    message.objId !== undefined && (obj.objId = message.objId);
    message.dataJson !== undefined && (obj.dataJson = message.dataJson);
    return obj;
  },

  fromPartial(object: DeepPartial<Interact>): Interact {
    const message = { ...baseInteract } as Interact;
    if (object.objId !== undefined && object.objId !== null) {
      message.objId = object.objId;
    }
    if (object.dataJson !== undefined && object.dataJson !== null) {
      message.dataJson = object.dataJson;
    }
    return message;
  },
};

const baseActivelySpeaking: object = { activelySpeaking: false };

export const ActivelySpeaking = {
  encode(message: ActivelySpeaking, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.activelySpeaking === true) {
      writer.uint32(8).bool(message.activelySpeaking);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActivelySpeaking {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseActivelySpeaking } as ActivelySpeaking;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.activelySpeaking = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ActivelySpeaking {
    const message = { ...baseActivelySpeaking } as ActivelySpeaking;
    if (object.activelySpeaking !== undefined && object.activelySpeaking !== null) {
      message.activelySpeaking = Boolean(object.activelySpeaking);
    }
    return message;
  },

  toJSON(message: ActivelySpeaking): unknown {
    const obj: any = {};
    message.activelySpeaking !== undefined && (obj.activelySpeaking = message.activelySpeaking);
    return obj;
  },

  fromPartial(object: DeepPartial<ActivelySpeaking>): ActivelySpeaking {
    const message = { ...baseActivelySpeaking } as ActivelySpeaking;
    if (object.activelySpeaking !== undefined && object.activelySpeaking !== null) {
      message.activelySpeaking = object.activelySpeaking;
    }
    return message;
  },
};

const baseEnterWhisper: object = { recipientId: "", dir: 0 };

export const EnterWhisper = {
  encode(message: EnterWhisper, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.recipientId !== "") {
      writer.uint32(10).string(message.recipientId);
    }
    if (message.dir !== 0) {
      writer.uint32(16).int32(message.dir);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EnterWhisper {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseEnterWhisper } as EnterWhisper;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.recipientId = reader.string();
          break;
        case 2:
          message.dir = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EnterWhisper {
    const message = { ...baseEnterWhisper } as EnterWhisper;
    if (object.recipientId !== undefined && object.recipientId !== null) {
      message.recipientId = String(object.recipientId);
    }
    if (object.dir !== undefined && object.dir !== null) {
      message.dir = moveDirectionEnum_ENUMFromJSON(object.dir);
    }
    return message;
  },

  toJSON(message: EnterWhisper): unknown {
    const obj: any = {};
    message.recipientId !== undefined && (obj.recipientId = message.recipientId);
    message.dir !== undefined && (obj.dir = moveDirectionEnum_ENUMToJSON(message.dir));
    return obj;
  },

  fromPartial(object: DeepPartial<EnterWhisper>): EnterWhisper {
    const message = { ...baseEnterWhisper } as EnterWhisper;
    if (object.recipientId !== undefined && object.recipientId !== null) {
      message.recipientId = object.recipientId;
    }
    if (object.dir !== undefined && object.dir !== null) {
      message.dir = object.dir;
    }
    return message;
  },
};

const baseLeaveWhisper: object = {};

export const LeaveWhisper = {
  encode(_: LeaveWhisper, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LeaveWhisper {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseLeaveWhisper } as LeaveWhisper;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): LeaveWhisper {
    const message = { ...baseLeaveWhisper } as LeaveWhisper;
    return message;
  },

  toJSON(_: LeaveWhisper): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial(_: DeepPartial<LeaveWhisper>): LeaveWhisper {
    const message = { ...baseLeaveWhisper } as LeaveWhisper;
    return message;
  },
};

const baseGhost: object = { ghost: 0 };

export const Ghost = {
  encode(message: Ghost, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ghost !== 0) {
      writer.uint32(8).uint32(message.ghost);
    }
    if (message.targetId !== undefined) {
      writer.uint32(18).string(message.targetId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Ghost {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseGhost } as Ghost;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ghost = reader.uint32();
          break;
        case 2:
          message.targetId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Ghost {
    const message = { ...baseGhost } as Ghost;
    if (object.ghost !== undefined && object.ghost !== null) {
      message.ghost = Number(object.ghost);
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = String(object.targetId);
    }
    return message;
  },

  toJSON(message: Ghost): unknown {
    const obj: any = {};
    message.ghost !== undefined && (obj.ghost = message.ghost);
    message.targetId !== undefined && (obj.targetId = message.targetId);
    return obj;
  },

  fromPartial(object: DeepPartial<Ghost>): Ghost {
    const message = { ...baseGhost } as Ghost;
    if (object.ghost !== undefined && object.ghost !== null) {
      message.ghost = object.ghost;
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = object.targetId;
    }
    return message;
  },
};

const baseSetEmote: object = { emote: 0 };

export const SetEmote = {
  encode(message: SetEmote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.emote !== 0) {
      writer.uint32(8).int32(message.emote);
    }
    if (message.targetId !== undefined) {
      writer.uint32(18).string(message.targetId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetEmote {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetEmote } as SetEmote;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.emote = reader.int32() as any;
          break;
        case 2:
          message.targetId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetEmote {
    const message = { ...baseSetEmote } as SetEmote;
    if (object.emote !== undefined && object.emote !== null) {
      message.emote = emoteEnum_ENUMFromJSON(object.emote);
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = String(object.targetId);
    }
    return message;
  },

  toJSON(message: SetEmote): unknown {
    const obj: any = {};
    message.emote !== undefined && (obj.emote = emoteEnum_ENUMToJSON(message.emote));
    message.targetId !== undefined && (obj.targetId = message.targetId);
    return obj;
  },

  fromPartial(object: DeepPartial<SetEmote>): SetEmote {
    const message = { ...baseSetEmote } as SetEmote;
    if (object.emote !== undefined && object.emote !== null) {
      message.emote = object.emote;
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = object.targetId;
    }
    return message;
  },
};

const baseSetName: object = { name: "" };

export const SetName = {
  encode(message: SetName, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.targetId !== undefined) {
      writer.uint32(18).string(message.targetId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetName {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetName } as SetName;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.targetId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetName {
    const message = { ...baseSetName } as SetName;
    if (object.name !== undefined && object.name !== null) {
      message.name = String(object.name);
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = String(object.targetId);
    }
    return message;
  },

  toJSON(message: SetName): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.targetId !== undefined && (obj.targetId = message.targetId);
    return obj;
  },

  fromPartial(object: DeepPartial<SetName>): SetName {
    const message = { ...baseSetName } as SetName;
    if (object.name !== undefined && object.name !== null) {
      message.name = object.name;
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = object.targetId;
    }
    return message;
  },
};

const baseSetTextStatus: object = { textStatus: "" };

export const SetTextStatus = {
  encode(message: SetTextStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.textStatus !== "") {
      writer.uint32(10).string(message.textStatus);
    }
    if (message.targetId !== undefined) {
      writer.uint32(18).string(message.targetId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetTextStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetTextStatus } as SetTextStatus;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.textStatus = reader.string();
          break;
        case 2:
          message.targetId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetTextStatus {
    const message = { ...baseSetTextStatus } as SetTextStatus;
    if (object.textStatus !== undefined && object.textStatus !== null) {
      message.textStatus = String(object.textStatus);
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = String(object.targetId);
    }
    return message;
  },

  toJSON(message: SetTextStatus): unknown {
    const obj: any = {};
    message.textStatus !== undefined && (obj.textStatus = message.textStatus);
    message.targetId !== undefined && (obj.targetId = message.targetId);
    return obj;
  },

  fromPartial(object: DeepPartial<SetTextStatus>): SetTextStatus {
    const message = { ...baseSetTextStatus } as SetTextStatus;
    if (object.textStatus !== undefined && object.textStatus !== null) {
      message.textStatus = object.textStatus;
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = object.targetId;
    }
    return message;
  },
};

const baseExit: object = {};

export const Exit = {
  encode(_: Exit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Exit {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseExit } as Exit;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): Exit {
    const message = { ...baseExit } as Exit;
    return message;
  },

  toJSON(_: Exit): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial(_: DeepPartial<Exit>): Exit {
    const message = { ...baseExit } as Exit;
    return message;
  },
};

const baseEnter: object = {};

export const Enter = {
  encode(message: Enter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.info !== undefined) {
      SpaceUserInfo.encode(message.info, writer.uint32(10).fork()).ldelim();
    }
    if (message.spawnToken !== undefined) {
      writer.uint32(18).string(message.spawnToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Enter {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseEnter } as Enter;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.info = SpaceUserInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.spawnToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Enter {
    const message = { ...baseEnter } as Enter;
    if (object.info !== undefined && object.info !== null) {
      message.info = SpaceUserInfo.fromJSON(object.info);
    }
    if (object.spawnToken !== undefined && object.spawnToken !== null) {
      message.spawnToken = String(object.spawnToken);
    }
    return message;
  },

  toJSON(message: Enter): unknown {
    const obj: any = {};
    message.info !== undefined &&
      (obj.info = message.info ? SpaceUserInfo.toJSON(message.info) : undefined);
    message.spawnToken !== undefined && (obj.spawnToken = message.spawnToken);
    return obj;
  },

  fromPartial(object: DeepPartial<Enter>): Enter {
    const message = { ...baseEnter } as Enter;
    if (object.info !== undefined && object.info !== null) {
      message.info = SpaceUserInfo.fromPartial(object.info);
    }
    if (object.spawnToken !== undefined && object.spawnToken !== null) {
      message.spawnToken = object.spawnToken;
    }
    return message;
  },
};

const baseSetEmojiStatus: object = { emojiStatus: "" };

export const SetEmojiStatus = {
  encode(message: SetEmojiStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.emojiStatus !== "") {
      writer.uint32(10).string(message.emojiStatus);
    }
    if (message.targetId !== undefined) {
      writer.uint32(18).string(message.targetId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetEmojiStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetEmojiStatus } as SetEmojiStatus;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.emojiStatus = reader.string();
          break;
        case 2:
          message.targetId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetEmojiStatus {
    const message = { ...baseSetEmojiStatus } as SetEmojiStatus;
    if (object.emojiStatus !== undefined && object.emojiStatus !== null) {
      message.emojiStatus = String(object.emojiStatus);
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = String(object.targetId);
    }
    return message;
  },

  toJSON(message: SetEmojiStatus): unknown {
    const obj: any = {};
    message.emojiStatus !== undefined && (obj.emojiStatus = message.emojiStatus);
    message.targetId !== undefined && (obj.targetId = message.targetId);
    return obj;
  },

  fromPartial(object: DeepPartial<SetEmojiStatus>): SetEmojiStatus {
    const message = { ...baseSetEmojiStatus } as SetEmojiStatus;
    if (object.emojiStatus !== undefined && object.emojiStatus !== null) {
      message.emojiStatus = object.emojiStatus;
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = object.targetId;
    }
    return message;
  },
};

const baseTeleport: object = { mapId: "", x: 0, y: 0 };

export const Teleport = {
  encode(message: Teleport, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.x !== 0) {
      writer.uint32(16).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(24).uint32(message.y);
    }
    if (message.targetId !== undefined) {
      writer.uint32(34).string(message.targetId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Teleport {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseTeleport } as Teleport;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.x = reader.uint32();
          break;
        case 3:
          message.y = reader.uint32();
          break;
        case 4:
          message.targetId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Teleport {
    const message = { ...baseTeleport } as Teleport;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = Number(object.x);
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = Number(object.y);
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = String(object.targetId);
    }
    return message;
  },

  toJSON(message: Teleport): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.targetId !== undefined && (obj.targetId = message.targetId);
    return obj;
  },

  fromPartial(object: DeepPartial<Teleport>): Teleport {
    const message = { ...baseTeleport } as Teleport;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.x !== undefined && object.x !== null) {
      message.x = object.x;
    }
    if (object.y !== undefined && object.y !== null) {
      message.y = object.y;
    }
    if (object.targetId !== undefined && object.targetId !== null) {
      message.targetId = object.targetId;
    }
    return message;
  },
};

const baseSetWorkCondition: object = { workCondition: false };

export const SetWorkCondition = {
  encode(message: SetWorkCondition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.workCondition === true) {
      writer.uint32(8).bool(message.workCondition);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetWorkCondition {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetWorkCondition } as SetWorkCondition;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.workCondition = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetWorkCondition {
    const message = { ...baseSetWorkCondition } as SetWorkCondition;
    if (object.workCondition !== undefined && object.workCondition !== null) {
      message.workCondition = Boolean(object.workCondition);
    }
    return message;
  },

  toJSON(message: SetWorkCondition): unknown {
    const obj: any = {};
    message.workCondition !== undefined && (obj.workCondition = message.workCondition);
    return obj;
  },

  fromPartial(object: DeepPartial<SetWorkCondition>): SetWorkCondition {
    const message = { ...baseSetWorkCondition } as SetWorkCondition;
    if (object.workCondition !== undefined && object.workCondition !== null) {
      message.workCondition = object.workCondition;
    }
    return message;
  },
};

const baseSpawn: object = { spawnToken: "" };

export const Spawn = {
  encode(message: Spawn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spawnToken !== "") {
      writer.uint32(10).string(message.spawnToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Spawn {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSpawn } as Spawn;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.spawnToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Spawn {
    const message = { ...baseSpawn } as Spawn;
    if (object.spawnToken !== undefined && object.spawnToken !== null) {
      message.spawnToken = String(object.spawnToken);
    }
    return message;
  },

  toJSON(message: Spawn): unknown {
    const obj: any = {};
    message.spawnToken !== undefined && (obj.spawnToken = message.spawnToken);
    return obj;
  },

  fromPartial(object: DeepPartial<Spawn>): Spawn {
    const message = { ...baseSpawn } as Spawn;
    if (object.spawnToken !== undefined && object.spawnToken !== null) {
      message.spawnToken = object.spawnToken;
    }
    return message;
  },
};

const baseRespawn: object = {};

export const Respawn = {
  encode(message: Respawn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spaceUserInfo !== undefined) {
      SpaceUserInfo.encode(message.spaceUserInfo, writer.uint32(10).fork()).ldelim();
    }
    if (message.spawnToken !== undefined) {
      writer.uint32(18).string(message.spawnToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Respawn {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseRespawn } as Respawn;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.spaceUserInfo = SpaceUserInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.spawnToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Respawn {
    const message = { ...baseRespawn } as Respawn;
    if (object.spaceUserInfo !== undefined && object.spaceUserInfo !== null) {
      message.spaceUserInfo = SpaceUserInfo.fromJSON(object.spaceUserInfo);
    }
    if (object.spawnToken !== undefined && object.spawnToken !== null) {
      message.spawnToken = String(object.spawnToken);
    }
    return message;
  },

  toJSON(message: Respawn): unknown {
    const obj: any = {};
    message.spaceUserInfo !== undefined &&
      (obj.spaceUserInfo = message.spaceUserInfo
        ? SpaceUserInfo.toJSON(message.spaceUserInfo)
        : undefined);
    message.spawnToken !== undefined && (obj.spawnToken = message.spawnToken);
    return obj;
  },

  fromPartial(object: DeepPartial<Respawn>): Respawn {
    const message = { ...baseRespawn } as Respawn;
    if (object.spaceUserInfo !== undefined && object.spaceUserInfo !== null) {
      message.spaceUserInfo = SpaceUserInfo.fromPartial(object.spaceUserInfo);
    }
    if (object.spawnToken !== undefined && object.spawnToken !== null) {
      message.spawnToken = object.spawnToken;
    }
    return message;
  },
};

const baseInit: object = { spaceId: "" };

export const Init = {
  encode(message: Init, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spaceId !== "") {
      writer.uint32(10).string(message.spaceId);
    }
    if (message.auth?.$case === "token") {
      writer.uint32(18).string(message.auth.token);
    }
    if (message.auth?.$case === "apiKey") {
      writer.uint32(26).string(message.auth.apiKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Init {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseInit } as Init;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.spaceId = reader.string();
          break;
        case 2:
          message.auth = { $case: "token", token: reader.string() };
          break;
        case 3:
          message.auth = { $case: "apiKey", apiKey: reader.string() };
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Init {
    const message = { ...baseInit } as Init;
    if (object.spaceId !== undefined && object.spaceId !== null) {
      message.spaceId = String(object.spaceId);
    }
    if (object.token !== undefined && object.token !== null) {
      message.auth = { $case: "token", token: String(object.token) };
    }
    if (object.apiKey !== undefined && object.apiKey !== null) {
      message.auth = { $case: "apiKey", apiKey: String(object.apiKey) };
    }
    return message;
  },

  toJSON(message: Init): unknown {
    const obj: any = {};
    message.spaceId !== undefined && (obj.spaceId = message.spaceId);
    message.auth?.$case === "token" && (obj.token = message.auth?.token);
    message.auth?.$case === "apiKey" && (obj.apiKey = message.auth?.apiKey);
    return obj;
  },

  fromPartial(object: DeepPartial<Init>): Init {
    const message = { ...baseInit } as Init;
    if (object.spaceId !== undefined && object.spaceId !== null) {
      message.spaceId = object.spaceId;
    }
    if (
      object.auth?.$case === "token" &&
      object.auth?.token !== undefined &&
      object.auth?.token !== null
    ) {
      message.auth = { $case: "token", token: object.auth.token };
    }
    if (
      object.auth?.$case === "apiKey" &&
      object.auth?.apiKey !== undefined &&
      object.auth?.apiKey !== null
    ) {
      message.auth = { $case: "apiKey", apiKey: object.auth.apiKey };
    }
    return message;
  },
};

const baseMapUpdate: object = { mapId: "", diffJson: "" };

export const MapUpdate = {
  encode(message: MapUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.diffJson !== "") {
      writer.uint32(18).string(message.diffJson);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapUpdate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapUpdate } as MapUpdate;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.diffJson = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapUpdate {
    const message = { ...baseMapUpdate } as MapUpdate;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.diffJson !== undefined && object.diffJson !== null) {
      message.diffJson = String(object.diffJson);
    }
    return message;
  },

  toJSON(message: MapUpdate): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.diffJson !== undefined && (obj.diffJson = message.diffJson);
    return obj;
  },

  fromPartial(object: DeepPartial<MapUpdate>): MapUpdate {
    const message = { ...baseMapUpdate } as MapUpdate;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.diffJson !== undefined && object.diffJson !== null) {
      message.diffJson = object.diffJson;
    }
    return message;
  },
};

const baseMapAddObject: object = { mapId: "" };

export const MapAddObject = {
  encode(message: MapAddObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapId !== "") {
      writer.uint32(10).string(message.mapId);
    }
    if (message.object !== undefined) {
      WireObject.encode(message.object, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapAddObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMapAddObject } as MapAddObject;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.string();
          break;
        case 2:
          message.object = WireObject.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MapAddObject {
    const message = { ...baseMapAddObject } as MapAddObject;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = String(object.mapId);
    }
    if (object.object !== undefined && object.object !== null) {
      message.object = WireObject.fromJSON(object.object);
    }
    return message;
  },

  toJSON(message: MapAddObject): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = message.mapId);
    message.object !== undefined &&
      (obj.object = message.object ? WireObject.toJSON(message.object) : undefined);
    return obj;
  },

  fromPartial(object: DeepPartial<MapAddObject>): MapAddObject {
    const message = { ...baseMapAddObject } as MapAddObject;
    if (object.mapId !== undefined && object.mapId !== null) {
      message.mapId = object.mapId;
    }
    if (object.object !== undefined && object.object !== null) {
      message.object = WireObject.fromPartial(object.object);
    }
    return message;
  },
};

const baseShootConfetti: object = {};

export const ShootConfetti = {
  encode(_: ShootConfetti, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ShootConfetti {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseShootConfetti } as ShootConfetti;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): ShootConfetti {
    const message = { ...baseShootConfetti } as ShootConfetti;
    return message;
  },

  toJSON(_: ShootConfetti): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial(_: DeepPartial<ShootConfetti>): ShootConfetti {
    const message = { ...baseShootConfetti } as ShootConfetti;
    return message;
  },
};

const baseSetEventStatus: object = { eventStatus: "" };

export const SetEventStatus = {
  encode(message: SetEventStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventStatus !== "") {
      writer.uint32(10).string(message.eventStatus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetEventStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetEventStatus } as SetEventStatus;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.eventStatus = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetEventStatus {
    const message = { ...baseSetEventStatus } as SetEventStatus;
    if (object.eventStatus !== undefined && object.eventStatus !== null) {
      message.eventStatus = String(object.eventStatus);
    }
    return message;
  },

  toJSON(message: SetEventStatus): unknown {
    const obj: any = {};
    message.eventStatus !== undefined && (obj.eventStatus = message.eventStatus);
    return obj;
  },

  fromPartial(object: DeepPartial<SetEventStatus>): SetEventStatus {
    const message = { ...baseSetEventStatus } as SetEventStatus;
    if (object.eventStatus !== undefined && object.eventStatus !== null) {
      message.eventStatus = object.eventStatus;
    }
    return message;
  },
};

const baseSetInConversation: object = { inConversation: false };

export const SetInConversation = {
  encode(message: SetInConversation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.inConversation === true) {
      writer.uint32(8).bool(message.inConversation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetInConversation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetInConversation } as SetInConversation;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.inConversation = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetInConversation {
    const message = { ...baseSetInConversation } as SetInConversation;
    if (object.inConversation !== undefined && object.inConversation !== null) {
      message.inConversation = Boolean(object.inConversation);
    }
    return message;
  },

  toJSON(message: SetInConversation): unknown {
    const obj: any = {};
    message.inConversation !== undefined && (obj.inConversation = message.inConversation);
    return obj;
  },

  fromPartial(object: DeepPartial<SetInConversation>): SetInConversation {
    const message = { ...baseSetInConversation } as SetInConversation;
    if (object.inConversation !== undefined && object.inConversation !== null) {
      message.inConversation = object.inConversation;
    }
    return message;
  },
};

const baseSetCurrentDesk: object = { currentDesk: "" };

export const SetCurrentDesk = {
  encode(message: SetCurrentDesk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currentDesk !== "") {
      writer.uint32(10).string(message.currentDesk);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetCurrentDesk {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetCurrentDesk } as SetCurrentDesk;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.currentDesk = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetCurrentDesk {
    const message = { ...baseSetCurrentDesk } as SetCurrentDesk;
    if (object.currentDesk !== undefined && object.currentDesk !== null) {
      message.currentDesk = String(object.currentDesk);
    }
    return message;
  },

  toJSON(message: SetCurrentDesk): unknown {
    const obj: any = {};
    message.currentDesk !== undefined && (obj.currentDesk = message.currentDesk);
    return obj;
  },

  fromPartial(object: DeepPartial<SetCurrentDesk>): SetCurrentDesk {
    const message = { ...baseSetCurrentDesk } as SetCurrentDesk;
    if (object.currentDesk !== undefined && object.currentDesk !== null) {
      message.currentDesk = object.currentDesk;
    }
    return message;
  },
};

const baseSetCurrentArea: object = { currentArea: "" };

export const SetCurrentArea = {
  encode(message: SetCurrentArea, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currentArea !== "") {
      writer.uint32(10).string(message.currentArea);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetCurrentArea {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetCurrentArea } as SetCurrentArea;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.currentArea = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetCurrentArea {
    const message = { ...baseSetCurrentArea } as SetCurrentArea;
    if (object.currentArea !== undefined && object.currentArea !== null) {
      message.currentArea = String(object.currentArea);
    }
    return message;
  },

  toJSON(message: SetCurrentArea): unknown {
    const obj: any = {};
    message.currentArea !== undefined && (obj.currentArea = message.currentArea);
    return obj;
  },

  fromPartial(object: DeepPartial<SetCurrentArea>): SetCurrentArea {
    const message = { ...baseSetCurrentArea } as SetCurrentArea;
    if (object.currentArea !== undefined && object.currentArea !== null) {
      message.currentArea = object.currentArea;
    }
    return message;
  },
};

const baseSetGoKartId: object = { goKartId: "" };

export const SetGoKartId = {
  encode(message: SetGoKartId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.goKartId !== "") {
      writer.uint32(10).string(message.goKartId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetGoKartId {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSetGoKartId } as SetGoKartId;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.goKartId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetGoKartId {
    const message = { ...baseSetGoKartId } as SetGoKartId;
    if (object.goKartId !== undefined && object.goKartId !== null) {
      message.goKartId = String(object.goKartId);
    }
    return message;
  },

  toJSON(message: SetGoKartId): unknown {
    const obj: any = {};
    message.goKartId !== undefined && (obj.goKartId = message.goKartId);
    return obj;
  },

  fromPartial(object: DeepPartial<SetGoKartId>): SetGoKartId {
    const message = { ...baseSetGoKartId } as SetGoKartId;
    if (object.goKartId !== undefined && object.goKartId !== null) {
      message.goKartId = object.goKartId;
    }
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
var globalThis: any = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string }
  ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}
