export interface Position {
  readonly x: number;
  readonly y: number;
}

export const isPosEqual = (a: Position, b: Position): boolean => {
  return a.x === b.x && a.y === b.y;
};

// TODO: write a simple test for serialize + deserialize
export function serializePosition(p: Position): string {
  return serializePositionCoordinates(p.x, p.y);
}

// Use this over serializePosition() to avoid unnecessary obj allocation.
export function serializePositionCoordinates(x: number, y: number): string {
  return `${x} ${y}`;
}

// Utility functions for row-major order: maps an X/Y coordinate to a one-dimensional array,
// given a predefined grid width. (If you're trying to reference world positions, you should use
// the map's width.)
export function positionToIndex(pos: Position, width: number): number {
  return coordinatesToIndex(pos.x, pos.y, width);
}
export function coordinatesToIndex(x: number, y: number, width: number): number {
  return y * width + x;
}

// Utility function for row-major order: maps an array index to an XY coordinate, given a predefined
// grid width. (If you're trying to reference world positions, you should use the map's width.)
let _x: number, _y: number;
export function indexToPosition(index: number, width: number): Position {
  _y = (index / width) | 0;
  _x = index - _y * width;
  return { x: _x, y: _y };
}

// This should only be called on strings output from serializePosition()
export function deserializePosition(s: string): Position {
  const parts = s.split(" ");
  return { x: parseFloat(parts[0]), y: parseFloat(parts[1]) };
}

export function manhattanDistance(a: Position, b: Position): number {
  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

export function euclideanDistance(a: Position, b: Position): number {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}

export function isPosWithinRect(
  position: Position,
  rectBounds: {
    readonly x: number;
    readonly y: number;
    readonly width: number;
    readonly height: number;
  },
) {
  return (
    position.x >= rectBounds.x &&
    position.y >= rectBounds.y &&
    position.x < rectBounds.x + rectBounds.width &&
    position.y < rectBounds.y + rectBounds.height
  );
}

export function calcCentroid(coords: Position[]): Position {
  let x_mean = 0;
  let y_mean = 0;
  for (const { x, y } of coords) {
    x_mean += x;
    y_mean += y;
  }
  return { x: x_mean / coords.length, y: y_mean / coords.length };
}

export function getBoundingBox(
  coords: Position[],
): { x: number; y: number; width: number; height: number } {
  const bound = { x1: Infinity, y1: Infinity, x2: 0, y2: 0 };
  for (const { x, y } of coords) {
    if (x < bound.x1) {
      bound.x1 = x;
    }
    if (y < bound.y1) {
      bound.y1 = y;
    }
    if (x > bound.x2) {
      bound.x2 = x;
    }
    if (y > bound.y2) {
      bound.y2 = y;
    }
  }
  return {
    x: bound.x1,
    y: bound.y1,
    width: bound.x2 - bound.x1 + 1,
    height: bound.y2 - bound.y1 + 1,
  };
}
