"use strict";
exports.__esModule = true;
exports.areaToCoords = exports.interactionOpensModal = exports.TileType = exports.convertStringToAreaCategory = exports.convertMapObjectToWireObject = exports.convertWireObjectToMapObject = exports.findMissingMapObjectFields = exports.Tile = exports.WallFloorDB = exports.FloorBlock = exports.WallBlock = exports.GameMap = exports.Interaction = void 0;
// Note: When adding to or modifying these types, please also adjust the types in modules/gather-http-server/src/v2/db/spaceRoom.ts
var lodash_1 = require("lodash");
var events_1 = require("./generated_DO_NOT_TOUCH/events");
exports.Interaction = events_1.InteractionEnum_ENUM;
// Ideally we will consolidate this in a single place, but for now we have to manually sync them.
var GameMap = /** @class */ (function () {
    function GameMap() {
    }
    return GameMap;
}());
exports.GameMap = GameMap;
var WallBlock = /** @class */ (function () {
    function WallBlock() {
    }
    return WallBlock;
}());
exports.WallBlock = WallBlock;
var FloorBlock = /** @class */ (function () {
    function FloorBlock() {
    }
    return FloorBlock;
}());
exports.FloorBlock = FloorBlock;
/*
  In code logic, walls and floors are represented as WallBlock or Floorblock
  In Firestore, for the sake of memory, it is represented as a map:
  {
    floorWallType1 (string): bytearray (string),
    floorWallType2 (string): bytearray (string),
    ...
  }
  where the bytearray is 0x01 if a wall/floor exists there, and 0x00 otherwise
  (like collisions)
*/
var WallFloorDB = /** @class */ (function () {
    function WallFloorDB() {
    }
    return WallFloorDB;
}());
exports.WallFloorDB = WallFloorDB;
var Tile = /** @class */ (function () {
    function Tile() {
    }
    return Tile;
}());
exports.Tile = Tile;
function findMissingMapObjectFields(object) {
    var requiredFields = ["x", "y", "normal", "highlighted", "type", "width", "height"];
    var missingFields = [];
    for (var _i = 0, requiredFields_1 = requiredFields; _i < requiredFields_1.length; _i++) {
        var field = requiredFields_1[_i];
        if (object[field] === undefined) {
            missingFields.push(field);
        }
    }
    return missingFields;
}
exports.findMissingMapObjectFields = findMissingMapObjectFields;
// Note: this function is safe only because we use findMissingMapObjectFields
function convertWireObjectToMapObject(wireObject) {
    var mapObject = lodash_1.cloneDeep(wireObject);
    if (wireObject.propertiesJson) {
        mapObject.properties = JSON.parse(wireObject.propertiesJson);
        delete mapObject.propertiesJson;
    }
    if (wireObject._tags && wireObject._tags.length === 0) {
        delete mapObject._tags;
    }
    var missingFields = findMissingMapObjectFields(mapObject);
    if (missingFields.length > 0) {
        throw "Failed to convert to MapObject because the following required fields were missing: " + missingFields;
    }
    return mapObject;
}
exports.convertWireObjectToMapObject = convertWireObjectToMapObject;
function convertMapObjectToWireObject(mapObject) {
    var wireObject = lodash_1.cloneDeep(mapObject);
    if (mapObject.properties) {
        wireObject.propertiesJson = JSON.stringify(mapObject.properties);
        delete wireObject.properties;
    }
    if (!mapObject._tags) {
        wireObject._tags = [];
    }
    return wireObject;
}
exports.convertMapObjectToWireObject = convertMapObjectToWireObject;
var AreaCategory;
(function (AreaCategory) {
    AreaCategory["RW_OFFICE_LOBBY"] = "RW_OFFICE_LOBBY";
    AreaCategory["RW_OFFICE_MEETING"] = "RW_OFFICE_MEETING";
})(AreaCategory || (AreaCategory = {}));
// Note, there is an analog in events.proto called Area that needs to be changed whenever this is changed
var DBAreas = /** @class */ (function () {
    function DBAreas() {
    }
    return DBAreas;
}());
function convertStringToAreaCategory(s) {
    if (!(s in AreaCategory)) {
        throw "Invalid area category";
    }
    return s;
}
exports.convertStringToAreaCategory = convertStringToAreaCategory;
var TileType;
(function (TileType) {
    TileType[TileType["Impassable"] = 1] = "Impassable";
    TileType[TileType["Spawn"] = 2] = "Spawn";
    TileType[TileType["Portal"] = 3] = "Portal";
    TileType[TileType["Announcer"] = 4] = "Announcer";
    TileType[TileType["Space"] = 5] = "Space";
})(TileType = exports.TileType || (exports.TileType = {}));
var MODAL_INTERACTIONS = [
    events_1.InteractionEnum_ENUM.EMBEDDED_WEBSITE,
    events_1.InteractionEnum_ENUM.POSTER,
    events_1.InteractionEnum_ENUM.VIDEO,
    events_1.InteractionEnum_ENUM.EXTERNAL_CALL,
    events_1.InteractionEnum_ENUM.NOTE,
    events_1.InteractionEnum_ENUM.MODAL_EXTENSION,
    events_1.InteractionEnum_ENUM.COMPONENT_MODAL,
];
function interactionOpensModal(i) {
    return MODAL_INTERACTIONS.includes(i);
}
exports.interactionOpensModal = interactionOpensModal;
function areaToCoords(coordsMap) {
    var coords = [];
    for (var y = 0; y < coordsMap.length; y++) {
        for (var x = 0; x < coordsMap[0].length; x++) {
            if (coordsMap[y][x] === true) {
                coords.push({ x: x, y: y });
            }
        }
    }
    return coords;
}
exports.areaToCoords = areaToCoords;
//# sourceMappingURL=GameMap.js.map